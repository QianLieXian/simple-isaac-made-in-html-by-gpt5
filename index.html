<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>简易以撒-like</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#151923; --ink:#e6e6e6; --muted:#9aa4b2; --accent:#6ee7ff; --accent2:#a78bfa; --danger:#ff6b6b; --ok:#86efac;
    }
    html,body{height:100%;}
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 600px at 50% -10%,#1a2030 0%,#0f1115 55%,#0b0d12 100%);color:var(--ink);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;}
    .wrap{max-width:960px;margin:24px auto;padding:16px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-weight:700;letter-spacing:.5px}
    .badge{padding:4px 8px;border:1px solid #2a3142;border-radius:999px;color:var(--muted)}
    .panel{background:linear-gradient(180deg,#121623,#0f131e);border:1px solid #202736;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .canvas-wrap{position:relative;aspect-ratio:4/3}
    canvas{width:100%;height:100%;display:block;border-radius:16px}
    .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;margin-top:10px;flex-wrap:wrap}
    .hud-section{display:flex;align-items:center;gap:6px}
    .hud-stats{flex:1 1 100%;display:flex;flex-wrap:wrap;gap:10px;font-size:13px;color:var(--muted);letter-spacing:.2px}
    .hud-stats span{display:flex;align-items:center;gap:4px;padding:2px 6px;border:1px solid #222a38;border-radius:8px;background:rgba(17,21,29,.65);color:var(--muted)}
    .hud-stats span strong{color:var(--ink);font-weight:600;min-width:36px;text-align:right;font-variant-numeric:tabular-nums}
    .hud-tools{display:flex;gap:10px;margin-left:auto;align-items:flex-start;position:relative}
    .hud-tools>div{position:relative}
    .hud-tools button{background:rgba(31,36,52,.9);color:var(--ink);border:1px solid #2c3448;border-radius:8px;padding:6px 10px;cursor:pointer;font-size:13px;letter-spacing:.4px;transition:all .2s ease}
    .hud-tools button:hover,.hud-tools button.active{border-color:#3a4c6f;background:rgba(45,52,72,.95)}
    .hud-virtual{display:flex;flex-direction:column;gap:8px;align-items:flex-end}
    .hud-cheat{position:relative;display:flex;align-items:flex-start}
    .cheat-toggle{background:rgba(31,36,52,.9);color:var(--ink);border:1px solid #2c3448;border-radius:8px;padding:6px 10px;cursor:pointer;font-size:13px;letter-spacing:.4px;transition:all .2s ease}
    .cheat-toggle:hover{border-color:#3a4c6f;background:rgba(45,52,72,.95)}
    .cheat-panel{display:none;position:absolute;top:110%;right:0;z-index:20;min-width:240px;max-width:280px;padding:12px 14px;border-radius:12px;background:rgba(15,19,28,.95);border:1px solid #273146;box-shadow:0 16px 32px rgba(0,0,0,.45);gap:14px;flex-direction:column}
    .cheat-panel.show{display:flex}
    .cheat-panel h4{margin:0 0 6px 0;font-size:13px;color:var(--accent2);letter-spacing:.3px}
    .cheat-section{display:flex;flex-direction:column;gap:6px}
    .cheat-section label{display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted)}
    .cheat-section input{background:#111521;border:1px solid #2c3448;border-radius:6px;color:var(--ink);padding:5px 6px;font-size:12px}
    .cheat-section input:focus{outline:none;border-color:var(--accent)}
    .cheat-section button{align-self:flex-end;background:linear-gradient(180deg,#2c3348,#222735);border:1px solid #2f3a52;border-radius:8px;color:var(--ink);padding:6px 10px;font-size:12px;cursor:pointer;transition:all .2s ease}
    .cheat-section button:hover{border-color:#3c4c6a;background:linear-gradient(180deg,#34405a,#273044)}
    .hud-stats span small{font-size:12px;color:var(--muted);opacity:.8}
    .kbd{padding:2px 6px;border:1px solid #2a3142;border-radius:6px;color:var(--muted)}
    .virtual-kb{display:none;position:absolute;top:110%;right:0;z-index:19;min-width:260px;background:rgba(15,19,28,.86);border:1px solid rgba(39,49,70,.85);border-radius:12px;padding:10px;box-shadow:0 16px 28px rgba(0,0,0,.35);gap:10px;backdrop-filter:blur(6px)}
    .virtual-kb.show{display:grid}
    .virtual-kb-cluster{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;align-items:end}
    .virtual-kb-block{display:grid;gap:8px}
    .virtual-kb-row{display:grid;gap:8px}
    .virtual-kb-row[data-type="movement"]{grid-template-columns:repeat(3,1fr)}
    .virtual-kb-row[data-type="arrows"]{grid-template-columns:repeat(3,1fr)}
    .virtual-kb-row[data-type="actions"]{grid-template-columns:repeat(4,1fr)}
    .virtual-kb-row[data-type="system"]{grid-template-columns:repeat(3,1fr)}
    .virtual-kb button{padding:10px 8px;border-radius:10px;border:1px solid rgba(47,58,82,.85);background:linear-gradient(180deg,rgba(44,51,72,.88),rgba(34,39,53,.82));color:var(--ink);font-weight:600;font-size:13px;min-width:0;transition:all .15s ease;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;touch-action:none}
    .virtual-kb button:active,.virtual-kb button.active{transform:translateY(1px);border-color:#3c4c6a;background:linear-gradient(180deg,rgba(52,64,90,.9),rgba(39,48,68,.86))}
    .virtual-kb button.small{font-size:12px;font-weight:500}
    .virtual-kb-spacer{visibility:hidden}
    .item-codex{margin-top:14px;padding:16px 18px;display:flex;flex-direction:column;gap:14px}
    .codex-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .codex-title{font-size:15px;font-weight:600;letter-spacing:.3px}
    .codex-progress{font-size:12px;color:var(--muted);letter-spacing:.3px}
    .codex-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
    .codex-entry{display:grid;grid-template-columns:48px 1fr;gap:12px;padding:12px 14px;border:1px solid #222a38;border-radius:12px;background:rgba(17,21,29,.7);box-shadow:inset 0 0 0 1px rgba(65,76,104,.18)}
    .codex-icon{width:48px;height:48px;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 35% 30%,rgba(110,231,255,.18),rgba(167,139,250,.12) 55%,transparent 100%);border-radius:12px}
    .codex-icon canvas{width:42px;height:42px}
    .codex-info{display:flex;flex-direction:column}
    .codex-name{font-size:13px;font-weight:600;color:var(--ink);letter-spacing:.2px}
    .codex-desc{margin-top:4px;font-size:12px;color:var(--muted);line-height:1.5}
    .codex-remark{margin-top:4px;font-size:11px;color:var(--accent2);letter-spacing:.3px}
    .codex-empty{grid-column:1/-1;text-align:center;padding:28px 18px;border:1px dashed #293347;border-radius:12px;color:var(--muted);font-size:13px;background:rgba(12,15,22,.65)}
    .cheat-feedback{margin-top:6px;font-size:12px;color:var(--muted);min-height:18px}
    @media (max-width:720px){
      .hud{flex-direction:column;align-items:stretch}
      .hud-tools{align-self:flex-end}
      .virtual-kb{position:fixed;left:50%;bottom:16px;top:auto;right:auto;transform:translateX(-50%);z-index:30;display:none;grid-template-columns:repeat(1,minmax(240px,1fr));width:min(92vw,400px)}
      .virtual-kb.show{display:grid}
      .virtual-kb-cluster{grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
      .virtual-kb-block{gap:10px}
      .virtual-kb-row{grid-template-columns:repeat(4,1fr)}
      .virtual-kb-row[data-type="movement"]{grid-template-columns:repeat(3,1fr)}
      .virtual-kb-row[data-type="arrows"]{grid-template-columns:repeat(3,1fr)}
      .virtual-kb-row[data-type="system"]{grid-template-columns:repeat(3,1fr)}
    }
    footer{margin-top:16px;color:var(--muted);text-align:center}
    /* overlays */
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;padding:24px}
    .overlay.show{display:flex}
    .card{max-width:520px;padding:18px 18px;border-radius:14px;background:rgba(15,17,21,.85);backdrop-filter: blur(6px);border:1px solid #202736}
    .card h2{margin:0 0 8px 0}
    .card p{margin:8px 0;color:var(--muted)}
    .card ul{margin:10px 0 0 1.2em;color:var(--muted)}
    .card li{margin:4px 0}
    a.btn{display:inline-block;margin-top:10px;padding:8px 12px;border-radius:10px;border:1px solid #273044;color:var(--ink);text-decoration:none}
    a.btn:hover{border-color:#3a4764}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">地窖速通实验室 · HTML5 Canvas</div>
      <div class="badge">WASD 移动 · 方向键射击 · E 放置炸弹 · F 购买 · Q 释放卡牌 · 回车开始 · P 暂停 · R 重开 · 记得深呼吸</div>
    </header>
    <div class="panel canvas-wrap">
      <canvas id="game" width="800" height="600"></canvas>
      <div class="overlay" id="menu">
        <div class="card">
          <h2>地窖暖场中…</h2>
          <p>这是款极简的房间制顶视角射击。先伸个懒腰再闯关——清空房间敌人，门才会知趣地打开。</p>
          <ul>
            <li><b>W/A/S/D</b> 移动，<b>↑/↓/←/→</b> 射击</li>
            <li><b>Enter</b> 开始 · <b>P</b> 暂停/继续 · <b>R</b> 重开</li>
          </ul>
          <a class="btn" href="#" id="startBtn">我要出发！</a>
        </div>
      </div>
      <div class="overlay" id="paused">
        <div class="card">
          <h2>暂时打个盹</h2>
          <p>按 <b>P</b> 继续。关卡在原地等你，敌人也在发呆。</p>
        </div>
      </div>
      <div class="overlay" id="gameover">
        <div class="card">
          <h2>勇者累趴了</h2>
          <p>按 <b>R</b> 重开，或者 <b>Enter</b> 回到主菜单准备再战。</p>
        </div>
      </div>
      <div class="overlay" id="ending">
        <div class="card">
          <h2 id="ending-title">轮回终章</h2>
          <p id="ending-summary">你跨越了未知的地窖。</p>
          <p id="ending-detail">按 <b>Enter</b> 返回主菜单，或 <b>R</b> 立刻再来一遍。</p>
          <a class="btn" href="#" id="ending-loop-btn">继续轮回</a>
        </div>
      </div>
    </div>
    <div class="panel hud">
      <div id="hud-left" class="hud-section"></div>
      <div id="hud-stats" class="hud-stats"></div>
      <div id="hud-right" class="hud-section"></div>
      <div class="hud-tools">
        <div class="hud-virtual">
          <button id="vk-toggle" type="button" aria-controls="virtual-kb" aria-expanded="false">屏幕键盘</button>
          <div id="virtual-kb" class="virtual-kb" aria-hidden="true"></div>
        </div>
        <div class="hud-cheat">
          <button id="cheat-toggle" class="cheat-toggle" type="button" aria-controls="cheat-panel" aria-expanded="false">作弊台</button>
          <div id="cheat-panel" class="cheat-panel">
          <div class="cheat-section">
            <h4>状态</h4>
            <label>当前血量 <input id="cheat-hp" type="number" min="0" max="20" step="1"></label>
            <label>生命上限 <input id="cheat-maxhp" type="number" min="1" max="20" step="1"></label>
            <label>基础伤害 <input id="cheat-damage" type="number" min="0" step="0.1"></label>
            <label>移动速度 <input id="cheat-speed" type="number" min="0" step="1"></label>
            <label>射速(次/秒) <input id="cheat-firerate" type="number" min="0.1" step="0.1"></label>
            <label>子弹速度 <input id="cheat-tearspeed" type="number" min="1" step="1"></label>
            <button id="cheat-apply-stats" type="button">应用状态</button>
          </div>
          <div class="cheat-section">
            <h4>资源</h4>
            <label>炸弹 <input id="cheat-bombs" type="number" min="0" max="99" step="1"></label>
            <label>钥匙 <input id="cheat-keys" type="number" min="0" max="99" step="1"></label>
            <label>金币 <input id="cheat-coins" type="number" min="0" max="99" step="1"></label>
            <button id="cheat-apply-resources" type="button">应用资源</button>
          </div>
          <div class="cheat-section">
            <h4>道具</h4>
            <label>道具 ID <input id="cheat-item-id" type="number" min="1" step="1" placeholder="例如 1"></label>
            <button id="cheat-give-item" type="button">给予道具</button>
            <div id="cheat-item-result" class="cheat-feedback" aria-live="polite"></div>
          </div>
          </div>
        </div>
      </div>
    </div>
    <div id="item-codex" class="panel item-codex" aria-live="polite">
      <div class="codex-header">
        <span class="codex-title">道具图鉴</span>
        <span class="codex-progress">已解锁 <span id="codex-count">0</span> / <span id="codex-total">0</span></span>
      </div>
      <div id="codex-grid" class="codex-grid"></div>
    </div>
    <footer>纯前端单文件 · 无素材 · 轻便又俏皮</footer>
  </div>

<script>
(() => {
  'use strict';
  // ======= 配置 =======
  const CONFIG = {
    roomW: 800, roomH: 600,
    grid: 9, // 更大的潜在网格，随机游走生成不规则结构
    roomsToMake: 9, // 随机游走生成房间数量
    itemRooms: 1,
    player: {
      speed: 210,
      radius: 12,
      hp: 6,
      fireCd: 360,
      tearSpeed: 230,
      tearLife: 0.65,
      accelTime: 0.13,     // 0 → 正常移动速度所需时间（秒）
      decelTime: 0.18,      // 正常移动速度 → 0 所需时间（秒）
      maxSpeedScale: 1.1, // 允许的速度上限倍率，给予一点惯性裕度
      activeMaxCharge: 4,
    }, // fireCd 毫秒
    enemy: {
      baseHP: 2,
      speed: 90,
      spawnMin: 3, spawnMax: 6,
      maxPerRoom: 5,
      gasbag: {speed: 95, safeRadius: 180, triggerRange: 70, triggerChance: 0.55, triggerCooldown: 0.9, fuse: 1.1, explosionRadius: 68, spawnMin: 3, spawnMax: 5},
      bomber: {speed: 70, wanderSpeed: 48, cooldown: 4, fuse: 2.4},
      tinyFly: {speed: 80},
      elderFly: {speed: 60, minRange: 130, maxRange: 220, fireInterval: 2.5, telegraph: 1, projectileSpeed: 200},
      spider: {leapSpeed: 320, maxDistance: 320, telegraph: 1, cooldown: 3.2},
      splitter: {speed: 80, radius: 14, maxSplits: 3, pause: 1, radiusDecay: 0.9, hpDecay: 0.75},
      volatile: {speed: 150, triggerMultiplier: 2, fuse: 0.55, explosionRadiusMultiplier: 1.5, damage: 2},
      sentry: {rotateSpeed: 2.6, fireInterval: 2.3, telegraph: 0.45, burst: 3, burstSpacing: 0.16, spread: 0.22, projectileSpeed: 230, projectileLife: 2.2},
      dashling: {speed: 115, dashSpeed: 340, dashDuration: 0.32, windup: 0.55, recover: 0.6, preferredRange: 150},
      burrower: {idleSpeed: 70, surfaceMin: 1.6, surfaceMax: 2.9, burrowTime: 1.1, burrowSpeed: 160, emergeSpeed: 300, emergeDuration: 0.36},
      spark: {driftSpeed: 46, orbitSpeed: 1.7, rangeMin: 48, rangeMax: 86, fireInterval: 2.8, burst: 2, burstSpacing: 0.22, bolts: 6, projectileSpeed: 210, projectileLife: 1.6},
      brood: {speed: 68, preferredRange: 180, spawnInterval: 4.4, spawnMax: 3, minionSpread: 26},
    },
    drops: {
      heartPerEnemy: 0.2,
      heartRoomClear: 0.25,
      doubleHeartChance: 0.18,
      soulHeartChance: 0.12,
      resourcePerEnemy: 0.14,
      roomClearResource: 0.5,
      resourceTypes: ['bomb','key','coin'],
    },
    pickupSpawnGrace: 0.7,
    resources: {
      bombStart: 5,
      keyStart: 5,
      coinStart: 5,
    },
    bomb: {damage:65, radius:62, fuse:3, playerDamage:1, knock:270, spawnGrace:0.7},
    obstacles: {
      min:2,
      max:4,
      tileSizePlayerRatio:1.4,
      maxTiles:6,
      maxClusterArea:30,
      hiddenChance:0.005,
      hiddenItemChance:0.001,
      hollowChance:0.55,
    },
    shop: {
      itemChance: 0.95,
      doubleItemChance: 0.05,
      dropPrice: 5,
      itemPrice: 15,
      rareItemChance: 0.035,
    },
    loot: {
      bossRareChance: 0.06,
    },
    cards: {
      price: 5,
      dropChanceOnItemPickup: 0.35,
      shopCardChance: 0.22,
    },
    roomTransition: {
      duration: 0.42,
      lockDuration: 0.3,
    },
    lifeTrade: {
      spawnChance: 0.25,
      defaultCost: 2,
      spawnPosition: { x: 120, y: 150 },
    },
    brimstone: {
      tickFrames: 8,
      beamDuration: 2,
      damageScale: 0.7,
      widthGrowth: 1.5,
      chargeScale: 4,
    },
    progression: {
      enemyHp: 1.15,
      enemySpeed: 1.08,
      enemyAggression: 1.08,
    },
    combat: {
      shotInertia: 0.32,
      shotForwardBoost: 0.7,
      shotLateralInfluence: 0.65,
      shotLateralAngle: 32,
      shotLateralCurve: 1.2,
      shotReverseBoost: 0.8,
    },
    portal: {
      radius: 36,
      interactRadius: 52,
      spawnDelay: 0.45,
      exchangeMinChance: 0.05,
      exchangePityStep: 0.18,
    },
    rngSeed: Date.now() % 1000000,
  };

  // ======= 基础工具 =======
  const rand = mulberry32(CONFIG.rngSeed);
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}};
  function randRange(min,max){return min + (max-min)*rand()}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
  const PICKUP_BANNER_TIME_SCALE = 1.6;
  function isTimeStopActive(){
    return !!(runtime && runtime.timeStopTimer>0);
  }
  function rectOverlap(a,b){
    return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
  }
  function hexToRgb(color){
    if(typeof color !== 'string') return null;
    let hex = color.trim();
    if(!hex) return null;
    if(hex.startsWith('#')) hex = hex.slice(1);
    if(hex.length===3){
      hex = hex.split('').map(ch => ch + ch).join('');
    }
    if(hex.length!==6 && hex.length!==8) return null;
    const r = parseInt(hex.slice(0,2),16);
    const g = parseInt(hex.slice(2,4),16);
    const b = parseInt(hex.slice(4,6),16);
    const a = hex.length===8 ? parseInt(hex.slice(6,8),16)/255 : 1;
    if(Number.isNaN(r) || Number.isNaN(g) || Number.isNaN(b)) return null;
    return {r,g,b,a};
  }
  function shadeColor(color, amount){
    const rgb = hexToRgb(color);
    if(!rgb) return color;
    const lum = clamp(amount, -1, 1);
    const mix = (c)=>{
      const delta = lum<0 ? c*lum : (255-c)*lum;
      return Math.max(0, Math.min(255, Math.round(c + delta)));
    };
    const toHex = (c)=>c.toString(16).padStart(2,'0');
    return `#${toHex(mix(rgb.r))}${toHex(mix(rgb.g))}${toHex(mix(rgb.b))}`;
  }
  function colorWithAlpha(color, alpha){
    const rgb = hexToRgb(color);
    if(!rgb) return color;
    const a = clamp(Number(alpha) || 0, 0, 1);
    return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
  }
  function mixHexColor(colorA, colorB, t){
    const from = hexToRgb(colorA);
    const to = hexToRgb(colorB);
    if(!from || !to){
      return t<0.5 ? colorA : colorB;
    }
    const mix = clamp(Number(t) || 0, 0, 1);
    const lerp = (a,b)=>Math.round(a + (b-a)*mix);
    const toHex = (c)=>c.toString(16).padStart(2,'0');
    return `#${toHex(lerp(from.r,to.r))}${toHex(lerp(from.g,to.g))}${toHex(lerp(from.b,to.b))}`;
  }

  function createRunTimer(){
    const pauseSources = new Set();
    const scaleSources = new Map();
    let elapsed = 0;
    let started = false;

    function totalScale(){
      if(scaleSources.size===0) return 1;
      let scale = 1;
      for(const value of scaleSources.values()){
        if(!Number.isFinite(value)) continue;
        scale *= value;
      }
      return Math.max(0, scale);
    }

    return {
      reset(){
        elapsed = 0;
        started = false;
        pauseSources.clear();
        scaleSources.clear();
      },
      start(){ started = true; },
      stop(){ started = false; },
      setPauseSource(source, active){
        if(!source) return;
        if(active){ pauseSources.add(source); }
        else { pauseSources.delete(source); }
      },
      setScaleSource(source, factor){
        if(!source) return;
        if(!Number.isFinite(factor) || factor===1){
          scaleSources.delete(source);
        } else {
          scaleSources.set(source, Math.max(0, factor));
        }
      },
      tick(dt){
        if(!started) return;
        if(pauseSources.size>0) return;
        if(!Number.isFinite(dt)) return;
        if(dt===0) return;
        const scale = totalScale();
        if(scale<=0) return;
        const delta = dt * scale;
        if(!Number.isFinite(delta) || delta===0) return;
        elapsed = Math.max(0, elapsed + delta);
      },
      rewind(amount){
        if(Number.isFinite(amount) && amount>0){
          elapsed = Math.max(0, elapsed - amount);
        }
        return elapsed;
      },
      addTime(amount){
        if(Number.isFinite(amount) && amount!==0){
          elapsed = Math.max(0, elapsed + amount);
        }
        return elapsed;
      },
      getElapsed(){ return elapsed; },
      isRunning(){ return started && pauseSources.size===0; },
      format(){
        const total = Math.max(0, elapsed);
        const minutes = Math.floor(total / 60);
        const seconds = Math.floor(total % 60);
        const fraction = Math.floor((total - Math.floor(total)) * 100);
        return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(fraction).padStart(2,'0')}`;
      },
      snapshot(){
        return {elapsed, started, pauseCount: pauseSources.size};
      },
    };
  }

  function createAudioManager(){
    const AudioCtx = typeof window !== 'undefined' ? (window.AudioContext || window.webkitAudioContext) : null;
    const ctxRef = {ctx:null, unlocked:false};
    const buffers = new Map();

    function ensureContext(){
      if(!AudioCtx) return null;
      if(ctxRef.ctx) return ctxRef.ctx;
      try {
        ctxRef.ctx = new AudioCtx();
      } catch(err){
        console.warn('Audio init failed', err);
        ctxRef.ctx = null;
      }
      return ctxRef.ctx;
    }

    function buildBuffer(duration, composer){
      const ctx = ensureContext();
      if(!ctx) return null;
      const sampleRate = ctx.sampleRate || 44100;
      const length = Math.max(1, Math.floor(duration * sampleRate));
      const buffer = ctx.createBuffer(1, length, sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<length;i++){
        const t = i / sampleRate;
        data[i] = clamp(composer(t, i, length), -1, 1);
      }
      return buffer;
    }

    function getBuffer(name){
      if(buffers.has(name)) return buffers.get(name);
      let buffer=null;
      switch(name){
        case 'enemyDeath':
          buffer = buildBuffer(0.26, (t)=>{
            const tone = Math.sin(Math.pow(t,0.8) * 340 * Math.PI * 2);
            return tone * Math.exp(-t*6.5);
          });
          break;
        case 'pickupPassive':
          buffer = buildBuffer(0.32, (t)=>{
            const chirp = Math.sin((220 + t*680) * Math.PI * 2 * t);
            return chirp * Math.pow(1-t, 1.1);
          });
          break;
        case 'pickupActive':
          buffer = buildBuffer(0.36, (t)=>{
            const base = Math.sin((160 + t*520) * Math.PI * 2 * t);
            const overtone = Math.sin((base>0?1:-1) * (320 + t*360) * Math.PI * 2 * t);
            return (base*0.7 + overtone*0.3) * Math.pow(1-t, 0.8);
          });
          break;
        case 'activeUse':
          buffer = buildBuffer(0.45, (t)=>{
            const sweep = Math.sin((120 + t*1020) * Math.PI * 2 * t);
            const rumble = Math.sin(60 * Math.PI * 2 * t) * 0.4;
            return (sweep*0.7 + rumble) * Math.exp(-t*3.6);
          });
          break;
        case 'playerShoot':
          buffer = buildBuffer(0.2, (t)=>{
            const env = Math.exp(-t*11.5);
            const tone = Math.sin((420 + t*720) * Math.PI * 2 * t);
            const click = Math.sin(Math.pow(t*1800 + 30, 1.12)) * Math.pow(1 - t, 2);
            return (tone*0.7 + click*0.4) * env;
          });
          break;
        case 'playerHurt':
          buffer = buildBuffer(0.48, (t)=>{
            const env = Math.exp(-t*4.2);
            const growl = Math.sin((90 + Math.sin(t*6)*18) * Math.PI * 2 * t) * 0.6;
            const rasp = Math.sin(520 * Math.PI * 2 * t) * Math.sin(80 * Math.PI * 2 * t) * 0.4;
            const tone = Math.sin((180 - t*120) * Math.PI * 2 * t) * 0.5;
            return (growl + rasp + tone) * env;
          });
          break;
        case 'dashReady':
          buffer = buildBuffer(0.3, (t)=>{
            const env = Math.pow(1 - t, 1.6);
            const chime = Math.sin((760 + t*680) * Math.PI * 2 * t);
            const shimmer = Math.sin((chime>0?1:-1) * (1180 + t*360) * Math.PI * 2 * t) * 0.55;
            return (chime*0.7 + shimmer*0.5) * env;
          });
          break;
        case 'brimstoneReady':
          buffer = buildBuffer(0.46, (t)=>{
            const env = Math.pow(1 - t, 1.4);
            const rumble = Math.sin((70 + Math.sin(t*4)*18) * Math.PI * 2 * t) * 0.55;
            const flare = Math.sin((280 + t*920) * Math.PI * 2 * t) * 0.65;
            return (flare + rumble) * env;
          });
          break;
        case 'bossRumble':
          buffer = buildBuffer(1.2, (t)=>{
            const env = Math.pow(1 - t, 1.05);
            const pulse = Math.sin(2 * Math.PI * t * 2.4) * Math.exp(-t*2.6);
            const low = Math.sin((36 + Math.sin(t*3)*6) * Math.PI * 2 * t) * 0.7;
            const grit = Math.sin(440 * Math.PI * 2 * t) * Math.sin(90 * Math.PI * 2 * t) * 0.25;
            return (low + pulse*0.6 + grit) * env;
          });
          break;
        case 'roomTransition':
          buffer = buildBuffer(0.38, (t)=>{
            const env = Math.pow(1 - t, 1.8);
            const sweep = Math.sin((240 + t*980) * Math.PI * 2 * t);
            const hush = Math.sin(Math.pow(t*2100 + 40, 1.1)) * 0.4;
            return (sweep*0.7 + hush*0.5) * env;
          });
          break;
        case 'enemySpawn':
          buffer = buildBuffer(0.34, (t)=>{
            const env = Math.pow(1 - t, 1.9);
            const breath = Math.sin((110 + t*260) * Math.PI * 2 * t) * 0.6;
            const dust = Math.sin(620 * Math.PI * 2 * t) * Math.sin(140 * Math.PI * 2 * t) * 0.45;
            return (breath + dust) * env;
          });
          break;
        case 'brimstoneTick':
          buffer = buildBuffer(0.18, (t)=>{
            const buzz = Math.sin(420 * Math.PI * 2 * t);
            return buzz * (1 - t);
          });
          break;
        default:
          break;
      }
      if(buffer){ buffers.set(name, buffer); }
      return buffer;
    }

    function play(name, options={}){
      const ctx = ensureContext();
      if(!ctx || !ctxRef.unlocked) return;
      const buffer = getBuffer(name);
      if(!buffer) return;
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      const gain = ctx.createGain();
      const volume = clamp(options.volume ?? 1, 0, 1);
      gain.gain.value = volume * 0.8;
      source.connect(gain).connect(ctx.destination);
      source.start();
    }

    async function unlock(){
      const ctx = ensureContext();
      if(!ctx) return;
      if(ctxRef.unlocked) return;
      if(ctx.state === 'suspended'){
        try {
          await ctx.resume();
        } catch(err){
          console.warn('Audio resume failed', err);
        }
      }
      ctxRef.unlocked = ctx.state === 'running' || ctx.state === 'interactive';
    }

    return { play, unlock, ensureContext };
  }

  const audio = createAudioManager();
  if(typeof window !== 'undefined'){
    ['pointerdown','touchstart','keydown'].forEach(eventName=>{
      window.addEventListener(eventName, ()=>audio.unlock(), {once:true});
    });
  }
  function adjustFireRate(player, delta){
    if(!player) return;
    const currentRate = player.fireInterval>0 ? 1000/player.fireInterval : 0;
    const newRate = Math.max(0.1, currentRate + delta);
    player.fireInterval = 1000 / newRate;
    player.fireCd = Math.min(player.fireCd, player.fireInterval);
    if(typeof player.updateBrimstoneChargeMetrics === 'function'){
      player.updateBrimstoneChargeMetrics();
    }
  }
  const DIRS = [
    {di:-1,dj:0,key:'up',opp:'down'},
    {di:1,dj:0,key:'down',opp:'up'},
    {di:0,dj:-1,key:'left',opp:'right'},
    {di:0,dj:1,key:'right',opp:'left'}
  ];
  const BOSS_TYPES = [
    {id:'idol', name:'哭泣塑像 · 社畜蛹', tier:'default'},
    {id:'master', name:'余烬教官 · Master', tier:'default'},
    {id:'hydra', name:'缠鳞九首 · 海德拉', tier:'default'},
    {id:'seer', name:'裂隙先知 · 星瞳使者', tier:'default'},
    {id:'titan', name:'震颤机偶 · 玄铁执事', tier:'default'},
    {id:'umbra', name:'黯影穿梭者 · 深渊夜行', tier:'penultimate'},
    {id:'paradox', name:'终焉织主 · 循环之心', tier:'final'},
  ];
  const FINAL_FLOOR = 7;
  function rollBossType(){
    const runtimeFloor = (typeof runtime !== 'undefined' && runtime && Number.isFinite(runtime.floor))
      ? runtime.floor
      : currentFloor;
    const floorLevel = Math.max(1, Math.floor(Number.isFinite(runtimeFloor) ? runtimeFloor : currentFloor || 1));
    if(floorLevel >= FINAL_FLOOR){
      return getBossMeta('paradox');
    }
    if(floorLevel === FINAL_FLOOR - 1){
      return getBossMeta('umbra');
    }
    const pool = BOSS_TYPES.filter(b=>!b.tier || b.tier==='default');
    const base = pool.length ? pool[Math.floor(rand()*pool.length)] : BOSS_TYPES[0];
    return base;
  }
  function getBossMeta(id){
    return BOSS_TYPES.find(b=>b.id===id) || BOSS_TYPES[0];
  }
  let currentFloor = 1;
  function safeProgressionValue(base){
    return (typeof base === 'number' && isFinite(base) && base>0) ? base : 1;
  }
  function sanitizeScalingValue(value, fallback=1){
    return (typeof value === 'number' && isFinite(value) && value>0) ? value : fallback;
  }
  function getFloorScalingFactors(floor = currentFloor){
    const progression = CONFIG.progression || {};
    if(typeof progression.getEnemyScaling === 'function'){
      const custom = progression.getEnemyScaling(floor) || {};
      const hp = custom.hp ?? custom.enemyHp;
      const speed = custom.speed ?? custom.enemySpeed;
      const aggression = custom.aggression ?? custom.enemyAggression;
      return {
        floor: Math.max(1, floor|0),
        hp: sanitizeScalingValue(hp),
        speed: sanitizeScalingValue(speed),
        aggression: sanitizeScalingValue(aggression),
      };
    }
    const level = Math.max(1, floor|0);
    const exponent = level - 1;
    return {
      floor: level,
      hp: Math.pow(safeProgressionValue(progression.enemyHp), exponent),
      speed: Math.pow(safeProgressionValue(progression.enemySpeed), exponent),
      aggression: Math.pow(safeProgressionValue(progression.enemyAggression), exponent),
    };
  }

  function initializeEnemyStats(enemy, options = {}){
    if(!enemy) return enemy;
    const scaling = getFloorScalingFactors();
    enemy.scaling = scaling;
    const baseHp = (options.hpBase!==undefined ? options.hpBase : enemy.hp);
    if(baseHp!==undefined){
      enemy.hp = Math.max(1, Math.round(baseHp * scaling.hp));
    }
    const { speedFields = ['speed'], aggressionField = 'aggression', extra } = options;
    if(Array.isArray(speedFields)){
      for(const field of speedFields){
        if(field && typeof enemy[field] === 'number'){
          enemy[field] *= scaling.speed;
        }
      }
    } else if(speedFields === true && typeof enemy.speed === 'number'){
      enemy.speed *= scaling.speed;
    }
    if(aggressionField){
      enemy[aggressionField] = scaling.aggression;
    }
    if(typeof extra === 'function'){
      extra(enemy, scaling);
    }
    return enemy;
  }

  const ENEMY_DAMAGE_FLASH_DURATION = 0.1;
  function prepareEnemy(enemy){
    if(!enemy) return enemy;
    if(typeof enemy.damageFlashTimer !== 'number'){ enemy.damageFlashTimer = 0; }
    if(typeof enemy.damage === 'function' && !enemy._damageFlashWrapped){
      const originalDamage = enemy.damage;
      enemy.damage = function(...args){
        const prevHp = (typeof this.hp === 'number') ? this.hp : null;
        const result = originalDamage.apply(this, args);
        if(prevHp !== null && typeof this.hp === 'number' && this.hp < prevHp){
          this.damageFlashTimer = ENEMY_DAMAGE_FLASH_DURATION;
        }
        return result;
      };
      enemy._damageFlashWrapped = true;
    }
    ensureEnemyKnockState(enemy);
    return enemy;
  }

  function ensureEnemyKnockState(enemy){
    if(!enemy) return;
    if(typeof enemy.hitKnockTimer !== 'number') enemy.hitKnockTimer = 0;
    if(typeof enemy.hitKnockVx !== 'number') enemy.hitKnockVx = 0;
    if(typeof enemy.hitKnockVy !== 'number') enemy.hitKnockVy = 0;
    if(typeof enemy.knockDamping !== 'number') enemy.knockDamping = 6.5;
    if(typeof enemy.hitSlowTimer !== 'number') enemy.hitSlowTimer = 0;
    if(typeof enemy.hitSlowFactor !== 'number' || enemy.hitSlowFactor<=0) enemy.hitSlowFactor = 1;
  }

  function applyEnemyKnockback(enemy, dx, dy, options={}){
    if(!enemy) return;
    const len = Math.hypot(dx, dy);
    if(!(len>1e-5)) return;
    ensureEnemyKnockState(enemy);
    const nx = dx / len;
    const ny = dy / len;
    const power = Number.isFinite(options.power) ? options.power : 150;
    enemy.hitKnockVx += nx * power;
    enemy.hitKnockVy += ny * power;
    const maxSpeed = Number.isFinite(options.maxSpeed) ? options.maxSpeed : (enemy.maxKnockSpeed || 280);
    const speed = Math.hypot(enemy.hitKnockVx, enemy.hitKnockVy);
    if(speed > maxSpeed && maxSpeed>0){
      const scale = maxSpeed / speed;
      enemy.hitKnockVx *= scale;
      enemy.hitKnockVy *= scale;
    }
    const duration = Number.isFinite(options.duration) ? Math.max(0.05, options.duration) : 0.2;
    enemy.hitKnockTimer = Math.max(enemy.hitKnockTimer, duration);
    if(typeof enemy.knock === 'number'){
      enemy.knock = Math.max(enemy.knock, duration);
    }
    if(enemy.knockVx !== undefined){
      enemy.knockVx += nx * power;
    }
    if(enemy.knockVy !== undefined){
      enemy.knockVy += ny * power;
    }
    if(options.slowFactor && options.slowFactor < 1){
      enemy.hitSlowFactor = Math.min(enemy.hitSlowFactor || 1, options.slowFactor);
      const slowDuration = Number.isFinite(options.slowDuration) ? Math.max(0, options.slowDuration) : duration;
      enemy.hitSlowTimer = Math.max(enemy.hitSlowTimer || 0, slowDuration);
    }
  }

  function resolveEnemyKnockback(enemy, dt){
    if(!enemy) return false;
    ensureEnemyKnockState(enemy);
    let active = false;
    if(enemy.hitKnockTimer>0){
      enemy.x += enemy.hitKnockVx * dt;
      enemy.y += enemy.hitKnockVy * dt;
      const damping = Math.max(0.1, enemy.knockDamping || 6.5);
      const decay = Math.exp(-dt * damping);
      enemy.hitKnockVx *= decay;
      enemy.hitKnockVy *= decay;
      enemy.hitKnockTimer = Math.max(0, enemy.hitKnockTimer - dt);
      active = true;
      if(enemy.hitKnockTimer<=0){
        enemy.hitKnockTimer = 0;
        enemy.hitKnockVx = 0;
        enemy.hitKnockVy = 0;
      }
    } else {
      enemy.hitKnockTimer = 0;
      enemy.hitKnockVx = 0;
      enemy.hitKnockVy = 0;
    }
    if(enemy.hitSlowTimer>0){
      enemy.hitSlowTimer = Math.max(0, enemy.hitSlowTimer - dt);
      if(enemy.hitSlowTimer<=0){
        enemy.hitSlowTimer = 0;
        enemy.hitSlowFactor = 1;
      }
    }
    return active;
  }

  function getEnemyGlobalSpeedMultiplier(){
    if(player && typeof player.getEnemySpeedMultiplier === 'function'){
      return player.getEnemySpeedMultiplier();
    }
    return 1;
  }

  function getExchangePortalChance(){
    const value = clamp(runtime?.exchangePortalChance ?? 1, 0, 1);
    return value >= 0.999 ? 1 : value;
  }

  function adjustExchangePortalChance(multiplier){
    if(!Number.isFinite(multiplier)) return getExchangePortalChance();
    const current = runtime?.exchangePortalChance ?? 1;
    const minChance = Math.max(0, CONFIG.portal?.exchangeMinChance ?? 0);
    let next = clamp(current * multiplier, 0, 1);
    if(next > 0 && next < minChance){
      next = minChance;
    }
    const normalized = next >= 0.999 ? 1 : next;
    if(runtime){
      runtime.exchangePortalChance = normalized;
      if(normalized >= 1){
        runtime.exchangePortalPity = 0;
      } else if(runtime.exchangePortalPity>0){
        const cap = Math.max(0, 1 - normalized);
        runtime.exchangePortalPity = Math.min(cap, runtime.exchangePortalPity);
      }
    }
    return normalized;
  }


  function normalizeAngle(angle){
    if(!isFinite(angle)) return 0;
    angle %= Math.PI * 2;
    if(angle > Math.PI) angle -= Math.PI * 2;
    if(angle < -Math.PI) angle += Math.PI * 2;
    return angle;
  }

  function stepTowardsAngle(current, target, maxStep){
    const diff = normalizeAngle(target - current);
    if(Math.abs(diff) <= maxStep) return target;
    return current + Math.sign(diff || 1) * maxStep;
  }
  const WEIGHT_PRESETS = {
    item: 10,
    shop: 10,
    boss: 10,
    lifeTrade: 10,
  };

  const ITEM_POOL = [
    {
      slug:'onion',
      name:'洋葱',
      weight: WEIGHT_PRESETS.item,
      description:'泪腺更发达，射速 +0.75 次/秒',
      apply(player){ adjustFireRate(player, 0.75); }
    },
    {
      slug:'tar',
      name:'焦油抹布',
      weight: WEIGHT_PRESETS.item,
      description:'伤害 +0.5，泪滴更厚重',
      apply(player){ player.addDamage(0.5); }
    },
    {
      slug:'sneaker',
      name:'小短跑鞋',
      weight: WEIGHT_PRESETS.item,
      description:'移动速度 +35，轻盈不少',
      apply(player){ player.speed += 35; }
    },
    {
      slug:'winged-socks',
      name:'凌云袜套',
      weight: WEIGHT_PRESETS.item,
      description:'被动：移动速度 +45，射速 +0.2 次/秒，最大移动速度阈值略微提高。',
      apply(player){
        if(!player) return;
        player.speed += 45;
        adjustFireRate(player,0.2);
        player.maxSpeedScale = Math.max(player.maxSpeedScale || 1.1, 1.3);
      }
    },
    {
      slug:'wind-sprint-medal',
      name:'疾风勋章',
      weight: WEIGHT_PRESETS.item,
      description:'被动：移动速度 +40，加速与减速时间缩短 12%。',
      apply(player){
        if(!player) return;
        player.speed += 40;
        if(Number.isFinite(player.accelTime)){ player.accelTime = Math.max(0.32, player.accelTime * 0.88); }
        if(Number.isFinite(player.decelTime)){ player.decelTime = Math.max(0.36, player.decelTime * 0.88); }
      }
    },
    {
      slug:'lightstep-tonic',
      name:'轻步药剂',
      weight: WEIGHT_PRESETS.item,
      description:'被动：移动速度 +30，子弹速度 x1.05，射程 x1.1。',
      apply(player){
        if(!player) return;
        player.speed += 30;
        player.tearSpeed *= 1.05;
        player.tearLife *= 1.1;
      }
    },
    {
      slug:'pepper-steak',
      name:'胡椒牛排',
      weight: WEIGHT_PRESETS.item,
      description:'全身沸腾，伤害 +1，攻速 +1，射程 x1.5，血上限 +1',
      apply(player){ player.addDamage(1); adjustFireRate(player,1); player.tearLife*=1.5; if(typeof player.adjustMaxHp==='function'){ player.adjustMaxHp(1); } else { player.maxHp+=1; player.hp=Math.min(player.maxHp, player.hp+1); } }
    },
    {
      slug:'rope',
      name:'绳子',
      weight: WEIGHT_PRESETS.item,
      description:'轻盈漂浮，飞行不再畏惧地形。额外的绳子会小幅提升移动与弹速。',
      apply(player){ player.flying = true; }
    },
    {
      slug:'spirit-date',
      name:'酒枣',
      weight: WEIGHT_PRESETS.item,
      description:'射程 x1.5，泪滴可穿透障碍',
      apply(player){ player.tearLife*=1.5; player.canPierceObstacles = true; }
    },
    {
      slug:'compressed-peach',
      name:'压缩桃子',
      weight: WEIGHT_PRESETS.item * 0.6,
      description:'被动：泪弹压缩成定距弹。飞行约 4 个身位后分裂为 3 枚穿透弹，随后顺时针旋转往返，持续时间等同当前射程。',
      apply(player){
        if(!player) return;
        if(typeof player.incrementItemStack === 'function'){ player.incrementItemStack('compressed-peach'); }
        if(typeof player.enableCompressedPeach === 'function'){ player.enableCompressedPeach(); }
        else {
          player.compressedPeachStacks = Math.max(1, (player.compressedPeachStacks||0) + 1);
        }
      }
    },
    {
      slug:'betrayal-hound',
      name:'伙伴倒戈犬',
      weight: WEIGHT_PRESETS.item,
      description:'狂暴背叛，伤害 x2 +1.5，射速 -0.25 次/秒',
      apply(player){ player.damageMultiplier *= 2; player.addDamage(1.5); adjustFireRate(player,-0.25); }
    },
    {
      slug:'despair-shout',
      name:'绝望呐喊',
      weight: WEIGHT_PRESETS.item,
      description:'撕裂呐喊，射程 x5',
      apply(player){ player.tearLife*=5; }
    },
    {
      slug:'bad-thing',
      name:'坏东西',
      weight: WEIGHT_PRESETS.item,
      description:'速度有点危险，子弹速度 x1.1',
      apply(player){ player.tearSpeed*=1.1; }
    },
    {
      slug:'good-thing',
      name:'好东西',
      weight: WEIGHT_PRESETS.item,
      description:'越看越顺眼，子弹速度 x0.75，射速 +0.75，射程 x1.25',
      apply(player){ player.tearSpeed*=0.75; adjustFireRate(player,0.75); player.tearLife*=1.25; }
    },
    {
      slug:'double-gaze',
      name:'双瞳',
      weight: WEIGHT_PRESETS.item,
      description:'双发齐射，攻击 x0.9。负面效果仅触发一次。',
      apply(player){
        if(!player) return;
        const firstPickup = !(typeof player.hasItem === 'function' && player.hasItem('double-gaze'));
        if(typeof player.registerEyePattern === 'function'){
          player.registerEyePattern('double-gaze', {
            extraShots: 1,
            step: 0.18,
            penalty: firstPickup ? {damage: 0.9} : null,
          });
        } else {
          if(firstPickup){ player.damageMultiplier *= 0.9; }
        }
      }
    },
    {
      slug:'triple-gaze',
      name:'三瞳',
      weight: WEIGHT_PRESETS.item,
      description:'三道视线，射速 x0.75。负面效果仅触发一次。',
      apply(player){
        if(!player) return;
        const firstPickup = !(typeof player.hasItem === 'function' && player.hasItem('triple-gaze'));
        const firePenalty = 1/0.75;
        if(typeof player.registerEyePattern === 'function'){
          player.registerEyePattern('triple-gaze', {
            extraShots: 2,
            step: 0.22,
            penalty: firstPickup ? {fireInterval: firePenalty} : null,
          });
        } else {
          if(firstPickup){
            player.fireInterval = Math.max(12, player.fireInterval * firePenalty);
            player.fireCd = Math.min(player.fireCd, player.fireInterval);
            player.updateBrimstoneChargeMetrics?.();
          }
        }
      }
    },
    {
      slug:'quad-gaze',
      name:'四瞳',
      weight: WEIGHT_PRESETS.item,
      description:'四向齐鸣，攻击 x0.9，射速 x0.75。负面效果仅触发一次。',
      apply(player){
        if(!player) return;
        const firstPickup = !(typeof player.hasItem === 'function' && player.hasItem('quad-gaze'));
        const firePenalty = 1/0.75;
        if(typeof player.registerEyePattern === 'function'){
          player.registerEyePattern('quad-gaze', {
            extraShots: 3,
            step: 0.26,
            penalty: firstPickup ? {damage: 0.9, fireInterval: firePenalty} : null,
          });
        } else {
          if(firstPickup){
            player.damageMultiplier *= 0.9;
            player.fireInterval = Math.max(12, player.fireInterval * firePenalty);
            player.fireCd = Math.min(player.fireCd, player.fireInterval);
            player.updateBrimstoneChargeMetrics?.();
          }
        }
      }
    },
    {
      slug:'impact-chocolate',
      name:'冲击巧克力',
      weight: WEIGHT_PRESETS.item,
      description:'被动：双击同方向键即可高速冲刺，冲刺期间无敌并留下一道造成高额伤害的冲击光带。额外巧克力：冲刺距离每层 +3 身位、无敌同步延长且冷却 -0.5 秒。持有 4 层起可粉碎障碍，光带愈发炫亮。',
      apply(player){
        if(!player) return;
        if(typeof player.enableImpactDash === 'function'){
          player.enableImpactDash();
        } else {
          if(!player.impactDash) player.impactDash = {};
          player.impactDash.unlocked = true;
        }
      }
    },
    {
      slug:'hot-chocolate',
      name:'热巧克力',
      weight: WEIGHT_PRESETS.item,
      description:'泪滴可蓄力。按住方向键蓄力，松开时按蓄力时长倍增伤害；超过 3 秒追踪敌人，5 秒穿透障碍，8 秒再穿透敌人。蓄力成长与弹速皆强化 1.5 倍，额外杯数进一步提升蓄力效率与伤害成长。',
      apply(player){
        if(!player) return;
        if(typeof player.enableHotChocolate === 'function'){
          player.enableHotChocolate();
        } else {
          if(!player.hotChocolate) player.hotChocolate = {enabled:true};
          else player.hotChocolate.enabled = true;
        }
      }
    },
    {
      slug:'soy-milk',
      name:'豆浆',
      weight: WEIGHT_PRESETS.item,
      description:'射速 x4，伤害 x0.25，射程 x2.5，移速 x1.25。',
      apply(player){
        if(!player) return;
        if(Number.isFinite(player.fireInterval)){
          const next = Math.max(15, player.fireInterval / 4);
          player.fireInterval = next;
          player.fireCd = Math.min(player.fireCd, player.fireInterval);
          if(typeof player.updateBrimstoneChargeMetrics === 'function'){
            player.updateBrimstoneChargeMetrics();
          }
        }
        player.damageMultiplier *= 0.25;
        player.tearLife *= 2.5;
        player.speed *= 1.25;
        if(typeof player.recalculateDamage === 'function'){
          player.recalculateDamage();
        }
      }
    },
    {
      slug:'seer-map',
      name:'透视雷达',
      weight: WEIGHT_PRESETS.item,
      description:'被动：当前与未来楼层地图全开，显示所有房间、商店和道具房。额外雷达提供小幅商店折扣并提高卡牌掉率。',
      apply(player){
        if(!player) return;
        if(typeof player.enableFullMapVision === 'function'){
          player.enableFullMapVision(dungeon);
        } else {
          player.fullMapVision = true;
          if(dungeon?.revealAllRooms){ dungeon.revealAllRooms(); }
        }
      }
    },
    {
      slug:'outdoor-pouch',
      name:'户外腰包',
      weight: WEIGHT_PRESETS.item,
      description:'主动道具 · 5 充能。翻找出 1 把钥匙、1 颗炸弹与 3 枚金币。',
      apply(player){
        const active = {
          slug:'outdoor-pouch',
          name:'户外腰包',
          description:'翻找出 1 把钥匙、1 颗炸弹与 3 枚金币。',
          maxCharge:5,
          startCharge:0,
          use(p){
            const keyGain = grantResource('key',1);
            const bombGain = grantResource('bomb',1);
            const coinGain = grantResource('coin',3);
            const detail = `钥匙 +${keyGain}，炸弹 +${bombGain}，金币 +${coinGain}`;
            return {message:'户外腰包翻找完毕', detail};
          }
        };
        player.setActiveItem(active);
      }
    },
    {
      slug:'pocket-watch',
      name:'怀表',
      weight: WEIGHT_PRESETS.item,
      description:'主动道具 · 4 充能。使用后 4 秒内除玩家外时间停滞，敌人、炸弹与弹幕全部冻结。',
      apply(player){
        const active = {
          slug:'pocket-watch',
          name:'怀表',
          description:'时间停止 4 秒，唯独你可移动与攻击。',
          maxCharge:4,
          startCharge:4,
          use(){
            if(runtime.timeStopTimer>0){
              return {consume:0, message:'时间仍在冻结', detail:'等待时间流动回归。'};
            }
            const duration = 4;
            runtime.timeStopTimer = duration;
            runtime.timeStopDuration = duration;
            runtime.timeStopSource = 'pocket-watch';
            runtime.timeStopFlash = Math.max(runtime.timeStopFlash || 0, 1);
            return {message:'怀表·止时', detail:'未来 4 秒内只有你能行动。'};
          }
        };
        player.setActiveItem(active);
      }
    },
    {
      slug:'adrenaline',
      name:'肾上腺素',
      weight: WEIGHT_PRESETS.item,
      description:'主动道具 · 3 充能。本房间内：伤害 +2，射速 +2，射程 x5，弹速 x2，生命 -1。',
      apply(player){
        const active = {
          slug:'adrenaline',
          name:'肾上腺素',
          description:'当前房间爆发强化，生命 -1。',
          maxCharge:3,
          startCharge:0,
          use(p, context){
            const room = context?.dungeon?.current;
            if(!room){
              return {consume:0, message:'肾上腺素无从发挥', detail:'需要在房间内使用。'};
            }
            if(p.hp<=0){
              return {consume:0, message:'肾上腺素无法启动', detail:'至少需要 1 点生命。'};
            }
            const roomKey = `${room.i},${room.j}`;
            p.applyRoomBuff({
              type:'adrenaline',
              roomKey,
              damageBonus:2,
              fireRateBonus:2,
              rangeMultiplier:5,
              speedMultiplier:2,
            });
            p.hp = Math.max(0, p.hp - 1);
            if(p.hp<=0){ gameOver(); }
            else {
              p.recalculateDamage();
              p.updateHolyHeartBlessing?.();
            }
            return {message:'肾上腺素·爆发', detail:'当前房间属性飙升，生命 -1。'};
          }
        };
        player.setActiveItem(active);
      }
    },
    {
      slug:'bomb-cousin',
      name:'炸弹表舅',
      weight: WEIGHT_PRESETS.item,
      description:'炸弹 +5，爆炸范围 x2，伤害 x2。',
      apply(player){ grantResource('bomb',5); player.bombRadiusMultiplier*=2; player.bombDamageMultiplier*=2; }
    },
    {
      slug:'bomb-uncle',
      name:'炸弹舅爷',
      weight: WEIGHT_PRESETS.item,
      description:'炸弹 +99，爆炸范围 x5，伤害 x5，爆炸伴随震动。',
      apply(player){ grantResource('bomb',99); player.bombRadiusMultiplier*=5; player.bombDamageMultiplier*=5; player.bombShakeStrength = Math.max(player.bombShakeStrength||0, 14); }
    },
    {
      slug:'bomb-grandpa',
      name:'炸弹爷爷',
      weight: WEIGHT_PRESETS.item,
      description:'免疫炸弹伤害，受到爆炸时反而恢复生命。',
      apply(player){ player.bombImmunity = true; player.explosionHealAmount = Math.max(player.explosionHealAmount||0, 1); }
    },
    {
      slug:'magic-bullet',
      name:'魔术子弹',
      weight: WEIGHT_PRESETS.item,
      description:'射程 x3，泪滴追踪最近的敌人。',
      apply(player){ player.tearLife*=3; player.homingTears = true; player.homingStrength = Math.max(player.homingStrength||0, 8); }
    },
    {
      slug:'younger-cousin',
      name:'表弟',
      weight: WEIGHT_PRESETS.item,
      description:'跟班：发射普通子弹，伤害 4，射速 3 次/秒，射程与弹速为自身的 1.5 倍。',
      setTag:'宝宝套装',
      apply(player){ grantYoungerCousinFollower(player); }
    },
    {
      slug:'aunt-brimstone',
      name:'大姨妈',
      weight: WEIGHT_PRESETS.item,
      description:'跟班：蓄力 2 秒释放持续 1.5 秒的细束硫磺火，每 8 帧造成 0.75 伤害。',
      setTag:'宝宝套装',
      apply(player){ grantAuntFollower(player); }
    },
    {
      slug:'black-buddy',
      name:'黑屁股',
      weight: WEIGHT_PRESETS.item,
      description:'跟班：寻找并拾取附近红心，拾取 3 枚后会奖励随机资源。',
      apply(player){ grantCollectorFollower(player); }
    }
  ];
  const ITEM_REF_OUTDOOR_POUCH = ITEM_POOL.find(item=>item.slug==='outdoor-pouch');
  const ITEM_REF_ADRENALINE = ITEM_POOL.find(item=>item.slug==='adrenaline');
  const ITEM_REF_BOMB_COUSIN = ITEM_POOL.find(item=>item.slug==='bomb-cousin');
  const ITEM_REF_BOMB_UNCLE = ITEM_POOL.find(item=>item.slug==='bomb-uncle');
  const ITEM_REF_BOMB_GRANDPA = ITEM_POOL.find(item=>item.slug==='bomb-grandpa');
  const ITEM_REF_MAGIC_BULLET = ITEM_POOL.find(item=>item.slug==='magic-bullet');
  const ITEM_REF_HOT_CHOCOLATE = ITEM_POOL.find(item=>item.slug==='hot-chocolate');
  const ITEM_REF_POCKET_WATCH = ITEM_POOL.find(item=>item.slug==='pocket-watch');
  const ITEM_REF_COMPRESSED_PEACH = ITEM_POOL.find(item=>item.slug==='compressed-peach');
  const ITEM_REF_WINGED_SOCKS = ITEM_POOL.find(item=>item.slug==='winged-socks');
  const ITEM_REF_WIND_SPRINT_MEDAL = ITEM_POOL.find(item=>item.slug==='wind-sprint-medal');
  const ITEM_REF_LIGHTSTEP_TONIC = ITEM_POOL.find(item=>item.slug==='lightstep-tonic');
  const HOLY_HEART_ITEM = {
    slug:'holy-heart',
    name:'神圣之心',
    weight:0.12,
    description:'受赐神圣之力：上限 +2，魂心 +3，射速 x0.95，伤害 x2.5 +2，移速 x1.2，弹速 x0.85，射程 x9，飞行、穿透与追踪；子弹环绕灼辉，并在满红心时额外将伤害再乘 2.5。受伤后本房间失效，下房间满血时再度生效。',
    apply(player){
      if(!player) return;
      const hasDouble = typeof player.hasItem === 'function' && player.hasItem('holy-heart');
      const state = typeof player.ensureHolyHeartState === 'function'
        ? player.ensureHolyHeartState()
        : (player.holyHeartState ||= {
            enabled:false,
            auraEnabled:false,
            aura:{},
            blessingMultiplier:2.5,
            blessingActive:false,
            roomSuppressed:false,
          });
      if(typeof player.adjustMaxHp === 'function'){
        player.adjustMaxHp(2);
      } else {
        const prev = player.maxHp;
        player.maxHp = Math.min(player.maxHpCap || 20, Math.max(1, (player.maxHp||0) + 2));
        if(player.hp > player.maxHp){ player.hp = player.maxHp; }
        else { player.hp = Math.min(player.maxHp, (player.hp||0) + (player.maxHp - prev)); }
        player.recalculateDamage?.();
      }
      if(typeof player.addSoulHearts === 'function'){
        const gained = player.addSoulHearts(3);
        if(!gained && player.soulHearts!=null){ player.soulHearts += 3; player.recalculateDamage?.(); }
      } else {
        player.soulHearts = Math.max(0, (player.soulHearts||0) + 3);
        player.recalculateDamage?.();
      }
      if(!hasDouble){
        player.fireInterval = Math.max(12, player.fireInterval / 0.95);
        player.fireCd = Math.min(player.fireCd, player.fireInterval);
        player.updateBrimstoneChargeMetrics?.();
        player.damageMultiplier *= 2.5;
        player.speed *= 1.2;
        player.tearSpeed *= 0.85;
        player.tearLife *= 9;
        player.ifrBoostMultiplier = Math.max(0.1, (player.ifrBoostMultiplier || 1) * 2);
      }
      player.addDamage?.(2);
      if(!player.addDamage){
        player.baseDamage = +(player.baseDamage + 2);
      }
      player.canPierceObstacles = true;
      player.canPierceEnemies = true;
      player.homingTears = true;
      player.homingStrength = Math.max(player.homingStrength || 6, 14);
      player.flying = true;
      if(state){
        state.enabled = true;
        state.auraEnabled = true;
        state.blessingMultiplier = Math.max(1, state.blessingMultiplier || 2.5);
        state.pickups = (state.pickups || 0) + 1;
        state.roomSuppressed = false;
        state.aura = {
          radiusMultiplier: 3,
          interval: 8/60,
          damageRatio: 0.4,
          fillColor: '#fef9c3',
          strokeColor: '#fde68a',
        };
      }
      if(typeof player.updateHolyHeartBlessing === 'function'){
        player.updateHolyHeartBlessing();
      }
      player.recalculateDamage?.();
    }
  };
  const SHOP_RARE_ITEM_POOL = [
    {...HOLY_HEART_ITEM, weight:0.1}
  ];
  const SHOP_ITEM_POOL = [
    {
      slug:'blood-power',
      name:'血之力',
      weight: WEIGHT_PRESETS.shop,
      description:'血越厚，伤害越高',
      apply(player){ player.effects.bloodPower = true; player.recalculateDamage(); }
    },
    {
      slug:'money-power',
      name:'钱之力',
      weight: WEIGHT_PRESETS.shop,
      description:'财源滚滚，伤害随金币提升',
      apply(player){ player.effects.moneyPower = true; player.recalculateDamage(); }
    },
    {
      slug:'despair-power',
      name:'绝望之力',
      weight: WEIGHT_PRESETS.shop,
      description:'血越少，越要反击',
      apply(player){ player.effects.despairPower = true; player.recalculateDamage(); }
    },
    {
      slug:'bomb-cousin',
      name: ITEM_REF_BOMB_COUSIN?.name || '炸弹表舅',
      weight: WEIGHT_PRESETS.shop,
      description: ITEM_REF_BOMB_COUSIN?.description || '炸弹 +5，爆炸范围 x2，伤害 x2。',
      apply(player){ ITEM_REF_BOMB_COUSIN?.apply?.(player); }
    },
    {
      slug:'bomb-uncle',
      name: ITEM_REF_BOMB_UNCLE?.name || '炸弹舅爷',
      weight: WEIGHT_PRESETS.shop,
      description: ITEM_REF_BOMB_UNCLE?.description || '炸弹 +99，爆炸范围 x5，伤害 x5，爆炸伴随震动。',
      apply(player){ ITEM_REF_BOMB_UNCLE?.apply?.(player); }
    },
    {
      slug:'bomb-grandpa',
      name: ITEM_REF_BOMB_GRANDPA?.name || '炸弹爷爷',
      weight: WEIGHT_PRESETS.shop,
      description: ITEM_REF_BOMB_GRANDPA?.description || '免疫炸弹伤害，受到爆炸时反而恢复生命。',
      apply(player){ ITEM_REF_BOMB_GRANDPA?.apply?.(player); }
    },
    {
      slug:'winged-socks',
      name: ITEM_REF_WINGED_SOCKS?.name || '凌云袜套',
      weight: WEIGHT_PRESETS.shop,
      description: ITEM_REF_WINGED_SOCKS?.description || '移动速度 +45，射速小幅提升。',
      apply(player){ ITEM_REF_WINGED_SOCKS?.apply?.(player); }
    },
    {
      slug:'wind-sprint-medal',
      name: ITEM_REF_WIND_SPRINT_MEDAL?.name || '疾风勋章',
      weight: WEIGHT_PRESETS.shop,
      description: ITEM_REF_WIND_SPRINT_MEDAL?.description || '移动速度 +40，加减速时间缩短。',
      apply(player){ ITEM_REF_WIND_SPRINT_MEDAL?.apply?.(player); }
    },
    {
      slug:'lightstep-tonic',
      name: ITEM_REF_LIGHTSTEP_TONIC?.name || '轻步药剂',
      weight: WEIGHT_PRESETS.shop,
      description: ITEM_REF_LIGHTSTEP_TONIC?.description || '移动速度提升并延长射程。',
      apply(player){ ITEM_REF_LIGHTSTEP_TONIC?.apply?.(player); }
    },
    {
      slug:'compressed-peach',
      name: ITEM_REF_COMPRESSED_PEACH?.name || '压缩桃子',
      weight: WEIGHT_PRESETS.shop * 0.6,
      description: ITEM_REF_COMPRESSED_PEACH?.description || '泪弹压缩，短程分裂为旋转穿透弹。',
      apply(player){ ITEM_REF_COMPRESSED_PEACH?.apply?.(player); }
    }
  ];
  const BOSS_RARE_ITEM_POOL = [
    {...HOLY_HEART_ITEM, weight:0.1}
  ];
  const BOSS_ITEM_POOL = [
    {
      slug:'dog-food',
      name:'狗粮',
      weight: WEIGHT_PRESETS.boss,
      description:'血量上限 +1',
      apply(player){ if(typeof player.adjustMaxHp==='function'){ player.adjustMaxHp(1); } else { player.maxHp+=1; player.hp=Math.min(player.maxHp, player.hp+1); } }
    },
    {
      slug:'vital-broth',
      name:'活力浓汤',
      weight: WEIGHT_PRESETS.boss,
      description:'被动：血量上限 +2，立即恢复 1 点红心，移速 +10。',
      apply(player){
        if(!player) return;
        if(typeof player.adjustMaxHp === 'function'){ player.adjustMaxHp(2); }
        else {
          const prevMax = player.maxHp || 0;
          player.maxHp = Math.min(player.maxHpCap || 20, Math.max(1, prevMax + 2));
          if(player.hp > player.maxHp){ player.hp = player.maxHp; }
        }
        if(player.hp!=null){ player.hp = Math.min(player.maxHp || player.hp, (player.hp||0) + 1); }
        player.speed += 10;
        player.recalculateDamage?.();
      }
    },
    {
      slug:'guardian-core',
      name:'守护核心',
      weight: WEIGHT_PRESETS.boss,
      description:'被动：血量上限 +1，移动速度 +20，无敌帧时长 x1.5，减速更快回到静止。',
      apply(player){
        if(!player) return;
        if(typeof player.adjustMaxHp === 'function'){ player.adjustMaxHp(1); }
        else {
          player.maxHp = Math.min(player.maxHpCap || 20, Math.max(1, (player.maxHp||0) + 1));
          player.hp = Math.min(player.maxHp, (player.hp||0) + 1);
        }
        player.speed += 20;
        player.ifrBoostMultiplier = Math.max(0.1, (player.ifrBoostMultiplier || 1) * 1.5);
        if(Number.isFinite(player.decelTime)){ player.decelTime = Math.max(0.32, player.decelTime * 0.85); }
        player.recalculateDamage?.();
      }
    },
    {
      slug:'ember-heart',
      name:'余烬心核',
      weight: WEIGHT_PRESETS.boss,
      description:'被动：血量上限 +1，伤害 x1.08 并额外 +0.6，子弹速度稍降。',
      apply(player){
        if(!player) return;
        if(typeof player.adjustMaxHp === 'function'){ player.adjustMaxHp(1); }
        else {
          player.maxHp = Math.min(player.maxHpCap || 20, Math.max(1, (player.maxHp||0) + 1));
          player.hp = Math.min(player.maxHp, (player.hp||0) + 1);
        }
        player.damageMultiplier *= 1.08;
        if(typeof player.addDamage === 'function'){ player.addDamage(0.6); }
        else { player.baseDamage = +(player.baseDamage + 0.6).toFixed(2); }
        player.tearSpeed *= 0.95;
        player.recalculateDamage?.();
      }
    },
    {
      slug:'ending-note',
      name:'结束纸条',
      weight: WEIGHT_PRESETS.boss,
      description:'射速 +0.75 次/秒，射程 x1.1',
      apply(player){ adjustFireRate(player,0.75); player.tearLife*=1.1; }
    },
    {
      slug:'kettle',
      name:'热水壶',
      weight: WEIGHT_PRESETS.boss,
      description:'伤害 +1',
      apply(player){ player.addDamage(1); }
    },
    {
      slug:'outdoor-pouch',
      name: ITEM_REF_OUTDOOR_POUCH?.name || '户外腰包',
      weight: WEIGHT_PRESETS.boss,
      description: ITEM_REF_OUTDOOR_POUCH?.description || '主动道具 · 5 充能。翻找出 1 把钥匙、1 颗炸弹与 3 枚金币。',
      apply(player){ ITEM_REF_OUTDOOR_POUCH?.apply?.(player); }
    },
    {
      slug:'adrenaline',
      name: ITEM_REF_ADRENALINE?.name || '肾上腺素',
      weight: WEIGHT_PRESETS.boss,
      description: ITEM_REF_ADRENALINE?.description || '主动道具 · 3 充能。本房间内强化并消耗 1 点生命。',
      apply(player){ ITEM_REF_ADRENALINE?.apply?.(player); }
    },
    {
      slug:'bomb-grandpa',
      name: ITEM_REF_BOMB_GRANDPA?.name || '炸弹爷爷',
      weight: WEIGHT_PRESETS.boss,
      description: ITEM_REF_BOMB_GRANDPA?.description || '免疫炸弹伤害，受到爆炸时反而恢复生命。',
      apply(player){ ITEM_REF_BOMB_GRANDPA?.apply?.(player); }
    },
    {
      slug:'magic-bullet',
      name: ITEM_REF_MAGIC_BULLET?.name || '魔术子弹',
      weight: WEIGHT_PRESETS.boss,
      description: ITEM_REF_MAGIC_BULLET?.description || '射程 x3，泪滴追踪最近的敌人。',
      apply(player){ ITEM_REF_MAGIC_BULLET?.apply?.(player); }
    },
    {
      slug:'hot-chocolate',
      name: ITEM_REF_HOT_CHOCOLATE?.name || '热巧克力',
      weight: WEIGHT_PRESETS.boss,
      description: ITEM_REF_HOT_CHOCOLATE?.description || '泪滴可蓄力并提供多段强化。',
      apply(player){ ITEM_REF_HOT_CHOCOLATE?.apply?.(player); }
    },
    {
      slug:'pocket-watch',
      name: ITEM_REF_POCKET_WATCH?.name || '怀表',
      weight: WEIGHT_PRESETS.boss,
      description: ITEM_REF_POCKET_WATCH?.description || '主动道具 · 4 充能。时间停止 4 秒。',
      apply(player){ ITEM_REF_POCKET_WATCH?.apply?.(player); }
    }
  ];
  const LIFE_TRADE_EXTRA_POOL = [
    {
      slug:'brimstone',
      name:'硫磺火',
      weight: WEIGHT_PRESETS.lifeTrade,
      description:'被动：蓄力释放贯穿障碍的血色激光。蓄力时间随射速缩短，束宽随拾取次数递增。每 8 帧造成相当于当前攻击力 70% 的伤害，持续 2 秒。拾取后仅保留 1 点生命上限。',
      lifeTradeCost:{type:'set-to-one'},
      apply(player){
        if(!player) return;
        if(typeof player.ensureBrimstoneMode === 'function'){
          player.ensureBrimstoneMode();
        } else {
          player.attackMode = 'brimstone';
          player.brimstoneStacks = Math.max(1, (player.brimstoneStacks||0) + 1);
        }
        if(typeof player.setMaxHpToSingle === 'function'){
          player.setMaxHpToSingle();
        } else {
          player.maxHp = 1;
          player.hp = Math.min(player.hp, 1);
          player.recalculateDamage?.();
        }
      }
    },
    {
      slug:'brother',
      name:'兄弟',
      weight: WEIGHT_PRESETS.lifeTrade,
      description:'跟班：复制玩家的所有射击效果与升级，总是紧贴玩家左右姐妹之后。',
      setTag:'宝宝套装',
      apply(player){ grantBrotherFollower(player); }
    },
    {
      slug:'sister',
      name:'姐妹',
      weight: WEIGHT_PRESETS.lifeTrade,
      description:'双生跟班：左右各有 1 名，以 0.75 倍伤害复制玩家的射击。',
      setTag:'宝宝套装',
      apply(player){ grantSisterFollowers(player); }
    },
    {
      slug:'cousin',
      name:'表哥',
      weight: WEIGHT_PRESETS.lifeTrade,
      description:'跟班：发射追踪弹，伤害 5，射速 2 次/秒，射程与弹速为玩家的 2 倍。',
      setTag:'宝宝套装',
      apply(player){ grantCousinFollower(player); }
    },
    {
      slug:'bomb-elder',
      name:'炸弹老祖',
      weight: 0.4,
      description:'被动：射击改为喷射定时炸弹。基础每 2 秒发射 1 枚，随射速略微提速，造成约 320% 攻击力的爆炸伤害，并小幅增强炸弹属性。',
      lifeTradeCost:{type:'flat', amount:2},
      apply(player){
        if(!player) return;
        if(typeof player.ensureBombElderState === 'function'){
          const state = player.ensureBombElderState();
          state.baseInterval = 2;
          state.minInterval = Math.min(state.minInterval || 0.55, 0.5);
          state.damageScale = Math.max(2.6, state.damageScale || 3.2);
          state.radiusScale = Math.max(0.8, state.radiusScale || 0.85);
          state.launchSpeed = Math.max(260, state.launchSpeed || 320);
          state.fuse = Math.max(0.9, state.fuse || 1.35);
          state.shakeStrength = Math.max(state.shakeStrength || 0, 8);
        }
        player.bombDamageMultiplier = Math.max(0.1, (player.bombDamageMultiplier || 1) * 1.1);
        player.bombRadiusMultiplier = Math.max(0.1, (player.bombRadiusMultiplier || 1) * 1.05);
        player.bombShakeStrength = Math.max(player.bombShakeStrength || 0, 6);
        if(typeof player.enableBombElderMode === 'function'){
          player.enableBombElderMode();
        } else {
          player.attackMode = 'bomb-elder';
        }
        player.recalculateDamage?.();
      }
    },
    {
      slug:'bomb-progenitor',
      name:'炸弹鼻祖',
      weight: 0.35,
      description:'被动：按下射击键在脚下生成可操控准星，2 秒后导引导弹瞬间爆炸，造成 2000% 攻击力。与瞳类或额外鼻祖叠加时会连续轰炸（最多 16 枚）。',
      lifeTradeCost:{type:'flat', amount:3},
      apply(player){
        if(!player) return;
        if(typeof player.ensureBombProgenitorState === 'function'){
          const state = player.ensureBombProgenitorState();
          state.chargeDuration = Math.max(1.6, state.chargeDuration || 2);
          state.chainSpacing = Math.max(0.2, state.chainSpacing || 0.3);
          state.damageScale = Math.max(14, state.damageScale || 20);
          state.baseRadius = Math.max(CONFIG.bomb.radius * 1.1, state.baseRadius || CONFIG.bomb.radius * 1.25);
          state.knockPower = Math.max(CONFIG.bomb.knock * 1.25, state.knockPower || CONFIG.bomb.knock * 1.35);
          state.shakeStrength = Math.max(state.shakeStrength || 0, 14);
        }
        player.bombDamageMultiplier = Math.max(0.1, (player.bombDamageMultiplier || 1) * 1.05);
        if(typeof player.enableBombProgenitorMode === 'function'){
          player.enableBombProgenitorMode();
        } else {
          player.attackMode = 'bomb-progenitor';
        }
        player.recalculateDamage?.();
      }
    },
    {
      slug:'abaddon',
      name:'亚巴顿',
      weight: WEIGHT_PRESETS.lifeTrade,
      description:'被动：获得 3 点蓝心，伤害 x2，射程 x3，使敌人移动速度降低。',
      apply(player){
        if(!player) return;
        if(typeof player.addSoulHearts === 'function'){ player.addSoulHearts(3); }
        player.damageMultiplier *= 2;
        player.tearLife *= 3;
        if(typeof player.setEnemySpeedMultiplier === 'function'){
          player.setEnemySpeedMultiplier(player.getEnemySpeedMultiplier()*0.7);
        } else {
          player.enemySpeedMultiplier = clamp((player.enemySpeedMultiplier || 1) * 0.7, 0.25, 1);
        }
        player.recalculateDamage();
      }
    },
    {
      slug:'escape-tool',
      name:'逃生工具',
      weight: WEIGHT_PRESETS.lifeTrade,
      description:'被动：移动速度 x5，子弹速度 x5，无敌帧时长 x3，敌人数量略有减少。',
      apply(player){
        if(!player) return;
        player.speed *= 5;
        player.tearSpeed *= 5;
        player.ifrBoostMultiplier *= 3;
        if(typeof player.setEnemySpawnFactor === 'function'){
          player.setEnemySpawnFactor(player.getEnemySpawnFactor()*0.75);
        } else {
          player.enemySpawnFactor = clamp((player.enemySpawnFactor || 1) * 0.75, 0.2, 1);
        }
        player.maxSpeedScale = Math.max(player.maxSpeedScale || 1.1, 2.5);
        player.recalculateDamage();
      }
    }
  ];
  function buildLifeTradePool(){
    const combined = [];
    const defaultCost = Math.max(1, Math.floor(CONFIG.lifeTrade?.defaultCost ?? 2));
    const addPool = (pool)=>{
      if(!Array.isArray(pool)) return;
      for(const item of pool){
        if(!item) continue;
        const clone = {...item};
        if(clone.lifeTradeCost){
          if(clone.lifeTradeCost.type==='flat' && !Number.isFinite(clone.lifeTradeCost.amount)){
            clone.lifeTradeCost = {...clone.lifeTradeCost, amount: defaultCost};
          } else {
            clone.lifeTradeCost = {...clone.lifeTradeCost};
          }
        } else {
          clone.lifeTradeCost = {type:'flat', amount: defaultCost};
        }
        combined.push(clone);
      }
    };
    addPool(ITEM_POOL);
    addPool(SHOP_ITEM_POOL);
    addPool(BOSS_ITEM_POOL);
    addPool(LIFE_TRADE_EXTRA_POOL);
    return combined;
  }
  const LIFE_TRADE_POOL = buildLifeTradePool();
  const CARD_POOL = [
    {
      slug:'seer-card',
      name:'通透牌',
      weight:16,
      description:'本层地图全显。',
      use(player, context){
        const dungeonInstance = context?.dungeon;
        if(!dungeonInstance){
          return {consume:false, message:'通透牌迷路', detail:'暂未锁定楼层。'};
        }
        if(typeof dungeonInstance.revealAllRooms === 'function'){
          dungeonInstance.revealAllRooms();
        }
        return {message:'通透牌·侦测', detail:'当前楼层地图完全显形。'};
      }
    },
    {
      slug:'rage-card',
      name:'伤害牌',
      weight:18,
      description:'本房间伤害 +2。',
      use(player, context){
        const room = context?.dungeon?.current;
        if(!room){
          return {consume:false, message:'伤害牌未生效', detail:'需要在房间内使用。'};
        }
        const roomKey = `${room.i},${room.j}`;
        player.applyRoomBuff({type:'card-damage', roomKey, damageBonus:2});
        return {message:'伤害牌·激怒', detail:'本房间伤害 +2，离开即失效。'};
      }
    },
    {
      slug:'homing-card',
      name:'追踪牌',
      weight:14,
      description:'本房间眼泪追踪敌人。',
      use(player, context){
        const room = context?.dungeon?.current;
        if(!room){
          return {consume:false, message:'追踪牌未锁定', detail:'进入房间后再使用。'};
        }
        const roomKey = `${room.i},${room.j}`;
        player.applyRoomBuff({type:'card-homing', roomKey, homing:true, homingStrength:10});
        return {message:'追踪牌·锁定', detail:'当前房间子弹追踪敌人。'};
      }
    },
    {
      slug:'juggle-card',
      name:'杂耍牌',
      weight:12,
      description:'获得 1 钥匙、1 炸弹与 1 滴血。',
      use(player){
        const keyGain = grantResource('key',1);
        const bombGain = grantResource('bomb',1);
        const prevHp = player.hp;
        player.hp = Math.min(player.maxHp, player.hp + 1);
        if(player.hp!==prevHp){ player.recalculateDamage(); }
        player.updateHolyHeartBlessing?.();
        const healGain = player.hp - prevHp;
        return {message:'杂耍牌·补给', detail:`钥匙 +${keyGain}，炸弹 +${bombGain}，生命 +${healGain}`};
      }
    },
    {
      slug:'invincible-card',
      name:'无敌牌',
      weight:10,
      description:'获得 3 秒无敌。',
      use(player){
        player.ifr = Math.max(player.ifr, 3);
        return {message:'无敌牌·护佑', detail:'未来 3 秒免疫伤害。'};
      }
    },
    {
      slug:'blood-card',
      name:'血牌',
      weight:10,
      description:'生命回复至满。',
      use(player){
        player.hp = player.maxHp;
        player.recalculateDamage();
        player.updateHolyHeartBlessing?.();
        return {message:'血牌·再生', detail:'生命回复至上限。'};
      }
    },
    {
      slug:'pierce-card',
      name:'穿透牌',
      weight:14,
      description:'本房间子弹穿透障碍。',
      use(player, context){
        const room = context?.dungeon?.current;
        if(!room){
          return {consume:false, message:'穿透牌无目标', detail:'需要在房间内使用。'};
        }
        const roomKey = `${room.i},${room.j}`;
        player.applyRoomBuff({type:'card-pierce', roomKey, pierceObstacles:true});
        return {message:'穿透牌·破障', detail:'当前房间子弹穿透障碍。'};
      }
    },
    {
      slug:'player-card',
      name:'玩家牌',
      weight:8,
      description:'随机获得一个被动道具。',
      use(player, context){
        const item = rollPassiveItem();
        if(!item){
          return {consume:false, message:'玩家牌失手', detail:'暂无法召唤被动道具。'};
        }
        const clone = {...item};
        if(typeof clone.apply === 'function'){ clone.apply(player); }
        recordItemAcquired(player, clone);
        return {message:`玩家牌·${clone.name}`, detail: clone.description || '神秘力量注入背包。'};
      }
    }
  ];
  const ITEM_ID_REGISTRY = (()=>{
    const pools = [ITEM_POOL, SHOP_ITEM_POOL, SHOP_RARE_ITEM_POOL, BOSS_ITEM_POOL, BOSS_RARE_ITEM_POOL, LIFE_TRADE_EXTRA_POOL];
    const byKey = new Map();
    const byId = new Map();
    let nextId = 1;
    for(const pool of pools){
      for(const item of pool){
        if(!item || !item.slug) continue;
        if(byKey.has(item.slug)){
          const stored = byKey.get(item.slug);
          item.id = stored.id;
          continue;
        }
        item.id = nextId++;
        byKey.set(item.slug, item);
        byId.set(item.id, item);
      }
    }
    return {byKey, byId, total: nextId-1};
  })();
  const ITEM_TOTAL_COUNT = ITEM_ID_REGISTRY.total;
  function getItemByNumericId(id){
    const numeric = Number(id);
    if(!Number.isFinite(numeric)) return null;
    return ITEM_ID_REGISTRY.byId.get(numeric) || null;
  }
  function cloneItemData(item){
    return item ? {...item} : null;
  }
  function cloneCardData(card){
    return card ? {...card} : null;
  }
  function ensureItemStackStorage(target){
    if(!target) return null;
    if(!target.itemStacks || typeof target.itemStacks !== 'object'){
      target.itemStacks = Object.create(null);
    }
    return target.itemStacks;
  }
  function getItemStack(target, slug){
    if(!target || !slug) return 0;
    const store = target.itemStacks;
    if(!store) return 0;
    const raw = store[slug];
    if(!Number.isFinite(raw)) return 0;
    return Math.max(0, Math.floor(raw));
  }
  function incrementItemStack(target, slug, amount=1){
    if(!target || !slug) return 0;
    const store = ensureItemStackStorage(target);
    if(!store) return 0;
    const delta = Math.floor(Number(amount) || 0);
    const prev = getItemStack(target, slug);
    const next = Math.max(0, prev + delta);
    store[slug] = next;
    return next;
  }
  const ITEM_STACK_EFFECTS = new Map();
  function registerItemStackEffect(slug, handler){
    if(!slug || typeof handler !== 'function') return;
    ITEM_STACK_EFFECTS.set(slug, handler);
  }
  function applyItemStackEffect(target, slug, count, item){
    if(!target || !slug) return;
    const handler = ITEM_STACK_EFFECTS.get(slug);
    if(typeof handler === 'function'){
      handler(target, count, item);
    }
  }
  const SET_EFFECTS = {
    '宝宝套装': {
      key:'baby-super',
      threshold:3,
      apply(player, context={}){
        if(player && typeof player.activateSetBonus === 'function'){
          player.activateSetBonus('baby-super', {
            damageScale:0.95,
            spread:0.2,
            completions: context.completions || 1,
          });
        }
      }
    }
  };

  function ensureSetProgressStorage(target){
    if(!target) return null;
    if(!target.itemSets || typeof target.itemSets !== 'object'){
      target.itemSets = Object.create(null);
    }
    return target.itemSets;
  }

  function recordSetAcquired(player, item){
    if(!player || !item || !item.setTag) return;
    const tag = item.setTag;
    if(!tag) return;
    const store = ensureSetProgressStorage(player);
    if(!store) return;
    const state = store[tag] || (store[tag] = {count:0, completions:0});
    state.count += 1;
    const effect = SET_EFFECTS[tag];
    if(!effect) return;
    const threshold = Math.max(1, Math.floor(effect.threshold || 3));
    const completions = Math.floor(state.count / threshold);
    if(completions > state.completions){
      state.completions = completions;
      if(typeof effect.apply === 'function'){
        effect.apply(player, {tag, key: effect.key, completions});
      }
    }
  }

  function recordItemAcquired(player, item){
    if(!player || !item) return 0;
    const slug = item.slug || null;
    let stackCount = 0;
    if(slug){
      stackCount = incrementItemStack(player, slug, 1);
      applyItemStackEffect(player, slug, stackCount, item);
    }
    recordSetAcquired(player, item);
    if(item.name){
      if(!player.itemNameStacks || typeof player.itemNameStacks !== 'object'){
        player.itemNameStacks = Object.create(null);
      }
      const prev = Number(player.itemNameStacks[item.name]) || 0;
      player.itemNameStacks[item.name] = prev + 1;
      if(!player.items.includes(item.name)){
        player.items.push(item.name);
      }
    }
    registerItemDiscovery(item);
    return stackCount;
  }
  const RESOURCE_LABELS = {bomb:'炸弹', key:'钥匙', coin:'金币'};
  const HUDL = document.getElementById('hud-left');
  const HUDR = document.getElementById('hud-right');
  const HUDS = document.getElementById('hud-stats');
  const cheatToggle = document.getElementById('cheat-toggle');
  const cheatPanelNode = document.getElementById('cheat-panel');
  const cheatInputs = {
    hp: document.getElementById('cheat-hp'),
    maxHp: document.getElementById('cheat-maxhp'),
    damage: document.getElementById('cheat-damage'),
    speed: document.getElementById('cheat-speed'),
    firerate: document.getElementById('cheat-firerate'),
    tearSpeed: document.getElementById('cheat-tearspeed'),
    bombs: document.getElementById('cheat-bombs'),
    keys: document.getElementById('cheat-keys'),
    coins: document.getElementById('cheat-coins')
  };
  const cheatStatsBtn = document.getElementById('cheat-apply-stats');
  const cheatResBtn = document.getElementById('cheat-apply-resources');
  const cheatGiveItemBtn = document.getElementById('cheat-give-item');
  const cheatItemIdInput = document.getElementById('cheat-item-id');
  const cheatItemResult = document.getElementById('cheat-item-result');
  const CODEX_NODE = document.getElementById('item-codex');
  const CODEX_GRID = document.getElementById('codex-grid');
  const CODEX_COUNT = document.getElementById('codex-count');
  const CODEX_TOTAL = document.getElementById('codex-total');

  if(CODEX_TOTAL) CODEX_TOTAL.textContent = ITEM_TOTAL_COUNT;
  if(cheatItemIdInput && ITEM_TOTAL_COUNT>0){
    cheatItemIdInput.setAttribute('max', String(ITEM_TOTAL_COUNT));
  }
  const discoveredItems = new Set();

  function formatItemNumber(id){
    const str = String(id);
    return str.length>=2 ? str : str.padStart(2,'0');
  }

  function drawCodexIcons(canvases){
    if(!Array.isArray(canvases) || !canvases.length) return;
    requestAnimationFrame(()=>{
      for(const canvas of canvases){
        if(!canvas) continue;
        const ctx2 = canvas.getContext('2d');
        if(!ctx2) continue;
        ctx2.clearRect(0,0,canvas.width,canvas.height);
        ctx2.save();
        ctx2.translate(canvas.width/2, canvas.height/2 + 2);
        drawItemIcon(canvas.dataset.itemSlug, 18, ctx2);
        ctx2.restore();
      }
    });
  }

  function updateCodex(){
    if(CODEX_TOTAL) CODEX_TOTAL.textContent = ITEM_TOTAL_COUNT;
    if(CODEX_COUNT) CODEX_COUNT.textContent = discoveredItems.size;
    if(!CODEX_GRID) return;
    CODEX_GRID.innerHTML='';
    const discoveredList = Array.from(discoveredItems)
      .sort((a,b)=>a-b)
      .map(id=>ITEM_ID_REGISTRY.byId.get(id))
      .filter(Boolean);
    if(!discoveredList.length){
      const empty=document.createElement('div');
      empty.className='codex-empty';
      empty.textContent='尚未获得任何道具。探索地下室，解锁第一件宝物吧！';
      CODEX_GRID.appendChild(empty);
      return;
    }
    const canvases=[];
    for(const item of discoveredList){
      const card=document.createElement('div');
      card.className='codex-entry';
      const iconWrap=document.createElement('div');
      iconWrap.className='codex-icon';
      const canvas=document.createElement('canvas');
      canvas.width=64;
      canvas.height=64;
      canvas.dataset.itemSlug=item.slug;
      iconWrap.appendChild(canvas);
      const info=document.createElement('div');
      info.className='codex-info';
      const title=document.createElement('div');
      title.className='codex-name';
      title.textContent=`#${formatItemNumber(item.id)} · ${item.name}`;
      const desc=document.createElement('div');
      desc.className='codex-desc';
      desc.textContent=item.description || '暂无描述';
      info.appendChild(title);
      info.appendChild(desc);
      if(item.setTag){
        const remark=document.createElement('div');
        remark.className='codex-remark';
        remark.textContent=`套装：${item.setTag}`;
        info.appendChild(remark);
      }
      card.appendChild(iconWrap);
      card.appendChild(info);
      CODEX_GRID.appendChild(card);
      canvases.push(canvas);
    }
    drawCodexIcons(canvases);
  }

  function registerItemDiscovery(item){
    if(!item) return;
    const slug = item.slug;
    let numeric = item.id;
    if(numeric==null && slug && ITEM_ID_REGISTRY.byKey.has(slug)){
      numeric = ITEM_ID_REGISTRY.byKey.get(slug).id;
    }
    if(numeric==null) return;
    if(!discoveredItems.has(numeric)){
      discoveredItems.add(numeric);
      updateCodex();
    } else {
      if(CODEX_COUNT) CODEX_COUNT.textContent = discoveredItems.size;
    }
  }

  updateCodex();

  const cheatDirtyFields = new Set();

  function setCheatDirty(key, dirty = true){
    if(!key) return;
    if(dirty){
      cheatDirtyFields.add(key);
    }else{
      cheatDirtyFields.delete(key);
    }
  }
  function clearCheatDirty(...keys){
    if(!keys.length){
      cheatDirtyFields.clear();
      return;
    }
    for(const key of keys){ cheatDirtyFields.delete(key); }
  }

  for(const [key, input] of Object.entries(cheatInputs)){
    if(!input) continue;
    input.addEventListener('input', ()=> setCheatDirty(key, true));
  }

  function syncCheatPanel(){
    if(!cheatPanelNode || !cheatPanelNode.classList.contains('show') || !player) return;
    const active = document.activeElement;
    const skip = (key, input)=> (input && input===active) || cheatDirtyFields.has(key);
    if(!skip('hp', cheatInputs.hp)) cheatInputs.hp.value = player ? Math.floor(player.hp) : 0;
    if(!skip('maxHp', cheatInputs.maxHp)) cheatInputs.maxHp.value = player ? Math.floor(player.maxHp) : 0;
    if(!skip('damage', cheatInputs.damage)) cheatInputs.damage.value = player ? player.baseDamage.toFixed(2) : '0';
    if(!skip('speed', cheatInputs.speed)) cheatInputs.speed.value = player ? Math.round(player.speed) : 0;
    const rate = player && player.fireInterval>0 ? (1000/player.fireInterval) : 0;
    if(!skip('firerate', cheatInputs.firerate)) cheatInputs.firerate.value = rate ? rate.toFixed(2) : '0';
    if(!skip('tearSpeed', cheatInputs.tearSpeed)) cheatInputs.tearSpeed.value = player ? Math.round(player.tearSpeed) : 0;
    if(!skip('bombs', cheatInputs.bombs)) cheatInputs.bombs.value = player ? Math.floor(player.bombs) : 0;
    if(!skip('keys', cheatInputs.keys)) cheatInputs.keys.value = player ? Math.floor(player.keys) : 0;
    if(!skip('coins', cheatInputs.coins)) cheatInputs.coins.value = player ? Math.floor(player.coins) : 0;
  }
  function applyCheatStats(){
    if(!player) return;
    const maxHpCap = player.maxHpCap || 20;
    const newMax = clamp(Math.floor(Number(cheatInputs.maxHp.value)||player.maxHp), 1, maxHpCap);
    const newHp = clamp(Math.floor(Number(cheatInputs.hp.value)||player.hp), 0, newMax);
    const baseDamage = Number(cheatInputs.damage.value);
    const moveSpeed = Number(cheatInputs.speed.value);
    const fireRate = Number(cheatInputs.firerate.value);
    const tearSpeed = Number(cheatInputs.tearSpeed.value);
    player.maxHp = newMax;
    player.hp = newHp;
    if(Number.isFinite(baseDamage) && baseDamage>=0){ player.baseDamage = baseDamage; }
    if(Number.isFinite(moveSpeed) && moveSpeed>=0){ player.speed = moveSpeed; }
    if(Number.isFinite(fireRate) && fireRate>0){
      player.fireInterval = 1000 / fireRate;
      player.fireCd = Math.min(player.fireCd, player.fireInterval);
      if(typeof player.updateBrimstoneChargeMetrics === 'function'){
        player.updateBrimstoneChargeMetrics();
      }
    }
    if(Number.isFinite(tearSpeed) && tearSpeed>0){ player.tearSpeed = tearSpeed; }
    if(player.hp>player.maxHp) player.hp = player.maxHp;
    player.recalculateDamage();
    player.updateHolyHeartBlessing?.();
    clearCheatDirty('hp','maxHp','damage','speed','firerate','tearSpeed');
    syncCheatPanel();
  }
  function applyCheatResources(){
    if(!player) return;
    const bombs = clamp(Math.floor(Number(cheatInputs.bombs.value)||player.bombs), 0, 99);
    const keys = clamp(Math.floor(Number(cheatInputs.keys.value)||player.keys), 0, 99);
    const coins = clamp(Math.floor(Number(cheatInputs.coins.value)||player.coins), 0, 99);
    player.bombs = bombs;
    player.keys = keys;
    player.coins = coins;
    player.recalculateDamage();
    clearCheatDirty('bombs','keys','coins');
    syncCheatPanel();
  }
  function giveItemByCheat(){
    if(!cheatItemResult) return;
    const resetColor = ()=>{ cheatItemResult.style.color = 'var(--muted)'; };
    resetColor();
    if(!player){
      cheatItemResult.textContent = '请先进入游戏后再使用道具召唤。';
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const raw = cheatItemIdInput ? String(cheatItemIdInput.value).trim() : '';
    if(!raw){
      cheatItemResult.textContent = '请输入道具编号。';
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const numeric = Math.floor(Number(raw));
    if(!Number.isFinite(numeric) || numeric<1){
      cheatItemResult.textContent = '编号无效，请输入正整数。';
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const base = getItemByNumericId(numeric);
    if(!base){
      cheatItemResult.textContent = `未找到编号为 ${numeric} 的道具。`;
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const item = cloneItemData(base);
    if(typeof item.apply === 'function'){ item.apply(player); }
    recordItemAcquired(player, item);
    player.recalculateDamage();
    runtime.itemPickupName = item.name;
    runtime.itemPickupDesc = item.description || '';
    runtime.itemPickupTimer = 2.4;
    cheatItemResult.textContent = `已获得「${item.name}」`;  
    cheatItemResult.style.color = 'var(--accent)';
    syncCheatPanel();
  }
  if(cheatToggle && cheatPanelNode){
    cheatToggle.addEventListener('click', ()=>{
      cheatPanelNode.classList.toggle('show');
      cheatToggle.classList.toggle('active', cheatPanelNode.classList.contains('show'));
      const isOpen = cheatPanelNode.classList.contains('show');
      cheatToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      if(isOpen){
        syncCheatPanel();
      }else{
        clearCheatDirty();
      }
    });
  }
  cheatStatsBtn?.addEventListener('click', applyCheatStats);
  cheatResBtn?.addEventListener('click', applyCheatResources);
  cheatGiveItemBtn?.addEventListener('click', giveItemByCheat);
  cheatItemIdInput?.addEventListener('keydown', (ev)=>{
    if(ev.key==='Enter'){ ev.preventDefault(); giveItemByCheat(); }
  });
  cheatItemIdInput?.addEventListener('input', ()=>{
    if(cheatItemResult){
      cheatItemResult.textContent = '';
      cheatItemResult.style.color = 'var(--muted)';
    }
  });

  function createOverlayManager(mapping){
    const entries = Object.entries(mapping).filter(([,node])=>node);
    return {
      setActive(target){
        for(const [key,node] of entries){ node.classList.toggle('show', key===target); }
      },
      clear(){ for(const [,node] of entries){ node.classList.remove('show'); } }
    };
  }

  function createVirtualKeyboard({panel, toggle, onKeyDown, onKeyUp}){
    if(!panel || !toggle || typeof onKeyDown !== 'function' || typeof onKeyUp !== 'function') return null;
    const layout = [
      {
        type:'cluster',
        columns:[
          {
            type:'movement',
            rows:[
              [null,{label:'W', code:'KeyW', hold:true},null],
              [
                {label:'A', code:'KeyA', hold:true},
                {label:'S', code:'KeyS', hold:true},
                {label:'D', code:'KeyD', hold:true},
              ],
            ],
          },
          {
            type:'arrows',
            rows:[
              [null,{label:'↑', code:'ArrowUp', hold:true},null],
              [
                {label:'←', code:'ArrowLeft', hold:true},
                {label:'↓', code:'ArrowDown', hold:true},
                {label:'→', code:'ArrowRight', hold:true},
              ],
            ],
          },
        ],
      },
      {
        type:'actions',
        rows:[[
          {label:'E', code:'KeyE', tap:true},
          {label:'F', code:'KeyF', tap:true},
          {label:'R', code:'KeyR', tap:true},
          {label:'P', code:'KeyP', tap:true},
        ]],
      },
      {
        type:'system',
        rows:[[
          {label:'Enter', code:'Enter', tap:true, span:3, className:'small'},
        ]],
      },
    ];

    panel.innerHTML = '';
    const activeHoldButtons = new Map();
    const pointerHold = new Map();

    function createRow(row, type){
      const rowEl = document.createElement('div');
      rowEl.className = 'virtual-kb-row';
      if(type) rowEl.dataset.type = type;
      for(const key of row){
        if(!key){
          const spacer = document.createElement('div');
          spacer.className = 'virtual-kb-spacer';
          rowEl.appendChild(spacer);
          continue;
        }
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = key.label;
        btn.dataset.code = key.code;
        if(key.className) btn.classList.add(key.className);
        if(key.span){ btn.style.gridColumn = `span ${key.span}`; }
        btn.addEventListener('selectstart', (e)=> e.preventDefault());
        btn.addEventListener('contextmenu', (e)=> e.preventDefault());
        btn.addEventListener('pointerdown', (e)=>{
          e.preventDefault();
          btn.setPointerCapture?.(e.pointerId);
          if(key.hold){
            if(!activeHoldButtons.has(key.code)){
              onKeyDown(key.code);
            }
            btn.classList.add('active');
            activeHoldButtons.set(key.code, btn);
            pointerHold.set(e.pointerId, key.code);
          } else {
            onKeyDown(key.code);
            btn.classList.add('active');
            setTimeout(()=>{
              btn.classList.remove('active');
            }, 120);
            setTimeout(()=>{
              onKeyUp(key.code);
            }, 50);
          }
        });
        const end = (e)=>{
          if(!pointerHold.has(e.pointerId)) return;
          const code = pointerHold.get(e.pointerId);
          pointerHold.delete(e.pointerId);
          releaseHold(code);
        };
        btn.addEventListener('pointerup', end);
        btn.addEventListener('pointercancel', end);
        btn.addEventListener('lostpointercapture', (e)=>{
          if(pointerHold.has(e.pointerId)){
            const code = pointerHold.get(e.pointerId);
            pointerHold.delete(e.pointerId);
            releaseHold(code);
          }
        });
        btn.addEventListener('pointerleave', (e)=>{
          if(pointerHold.has(e.pointerId)){
            const code = pointerHold.get(e.pointerId);
            pointerHold.delete(e.pointerId);
            releaseHold(code);
          }
        });
        rowEl.appendChild(btn);
      }
      return rowEl;
    }

    function releaseHold(code){
      if(!code) return;
      onKeyUp(code);
      const btn = activeHoldButtons.get(code);
      if(btn){
        btn.classList.remove('active');
        activeHoldButtons.delete(code);
      }
    }

    function releaseAll(){
      for(const code of Array.from(activeHoldButtons.keys())){
        releaseHold(code);
      }
      pointerHold.clear();
    }

    for(const section of layout){
      if(section.columns){
        const cluster = document.createElement('div');
        cluster.className = 'virtual-kb-cluster';
        for(const column of section.columns){
          const block = document.createElement('div');
          block.className = 'virtual-kb-block';
          if(column.type) block.dataset.type = column.type;
          for(const row of column.rows){
            block.appendChild(createRow(row, column.type));
          }
          cluster.appendChild(block);
        }
        panel.appendChild(cluster);
        continue;
      }
      const rows = section.rows || [];
      for(const row of rows){
        panel.appendChild(createRow(row, section.type));
      }
    }

    panel.setAttribute('aria-hidden', 'true');
    toggle.setAttribute('aria-expanded', 'false');
    panel.addEventListener('contextmenu', (e)=> e.preventDefault());

    function hide(){
      panel.classList.remove('show');
      panel.setAttribute('aria-hidden', 'true');
      toggle.classList.remove('active');
      toggle.setAttribute('aria-expanded', 'false');
      releaseAll();
    }
    function show(){
      panel.classList.add('show');
      panel.setAttribute('aria-hidden', 'false');
      toggle.classList.add('active');
      toggle.setAttribute('aria-expanded', 'true');
    }

    toggle.addEventListener('click', ()=>{
      if(panel.classList.contains('show')) hide();
      else show();
    });

    return {
      releaseAll,
      hide,
      show,
    };
  }

  // DPR 缩放（保持内部 800x600 逻辑坐标）
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fitCanvasToCss(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = CONFIG.roomW * dpr;
    canvas.height = CONFIG.roomH * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvasToCss();
  window.addEventListener('resize', fitCanvasToCss);

  // ======= 输入 =======
  function isTypingTarget(event){
    const target = event && event.target;
    if(!target) return false;
    const tag = target.tagName;
    if(tag==='INPUT' || tag==='TEXTAREA' || tag==='SELECT') return true;
    return !!target.isContentEditable;
  }

  const keys = new Set();
  const keyOrder = new Map();
  let keyOrderTick = 0;
  function markKeyOrder(code){
    keyOrderTick += 1;
    keyOrder.set(code, keyOrderTick);
  }
  function resolveAxis(negative, positive){
    const negDown = keys.has(negative);
    const posDown = keys.has(positive);
    if(negDown && posDown){
      const negOrder = keyOrder.get(negative) ?? -Infinity;
      const posOrder = keyOrder.get(positive) ?? -Infinity;
      if(negOrder === posOrder) return 0;
      return negOrder > posOrder ? -1 : 1;
    }
    if(negDown) return -1;
    if(posDown) return 1;
    return 0;
  }
  function processKeyDown(code){
    const firstPress = !keys.has(code);
    keys.add(code);
    if(firstPress){
      markKeyOrder(code);
    }
    if(!firstPress) return;
    if(state===STATE.PLAY && player && typeof player.handleDirectionalKeyTap === 'function'){
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      player.handleDirectionalKeyTap(code, now);
    }
    if(state===STATE.MENU && code==='Enter') startGame();
    if(state===STATE.PLAY && code==='KeyP') togglePause();
    if(state===STATE.PAUSE && code==='KeyP') togglePause();
    if(state===STATE.OVER && code==='Enter') showMenu();
    if((state===STATE.PLAY || state===STATE.PAUSE || state===STATE.OVER) && code==='KeyR') startGame();
    if(state===STATE.PLAY && code==='KeyE') placeBomb();
    if(state===STATE.PLAY && code==='KeyF') attemptPurchase();
    if(state===STATE.PLAY && code==='Space') attemptActiveUse();
    if(state===STATE.PLAY && code==='KeyQ') attemptSingleUse();
  }
  function processKeyUp(code){
    keys.delete(code);
    keyOrder.delete(code);
  }
  window.addEventListener('keydown', (e)=>{
    if(isTypingTarget(e)) return;
    const block = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'];
    if(block.includes(e.code)) e.preventDefault();
    processKeyDown(e.code);
  });
  window.addEventListener('keyup', (e)=> processKeyUp(e.code));

  const virtualKbToggle = document.getElementById('vk-toggle');
  const virtualKbPanel = document.getElementById('virtual-kb');
  const virtualKeyboard = createVirtualKeyboard({
    panel: virtualKbPanel,
    toggle: virtualKbToggle,
    onKeyDown: processKeyDown,
    onKeyUp: processKeyUp,
  });
  if(virtualKeyboard){
    window.addEventListener('blur', ()=> virtualKeyboard.releaseAll());
  }

  // ======= 游戏状态 =======
  const overlayMenu = document.getElementById('menu');
  const overlayPaused = document.getElementById('paused');
  const overlayOver = document.getElementById('gameover');
  const overlayEnding = document.getElementById('ending');
  const endingTitleNode = document.getElementById('ending-title');
  const endingSummaryNode = document.getElementById('ending-summary');
  const endingDetailNode = document.getElementById('ending-detail');
  const overlayManager = createOverlayManager({ menu: overlayMenu, paused: overlayPaused, over: overlayOver, ending: overlayEnding });
  document.getElementById('startBtn').addEventListener('click', (e)=>{e.preventDefault(); audio.unlock(); startGame();});

  const endingLoopBtn = document.getElementById('ending-loop-btn');
  if(endingLoopBtn){
    endingLoopBtn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      startLoopRun({fromEnding:true});
    });
  }

  const STATE = { MENU:0, PLAY:1, PAUSE:2, OVER:3 };
  let state = STATE.MENU;

  function showMenu(){ state=STATE.MENU; overlayManager.setActive('menu'); }
  function togglePause(){
    if(state===STATE.PLAY){
      state=STATE.PAUSE;
      overlayManager.setActive('paused');
      runtime.runTimer?.setPauseSource('pause', true);
    }
    else if(state===STATE.PAUSE){
      state=STATE.PLAY;
      overlayManager.clear();
      runtime.runTimer?.setPauseSource('pause', false);
      lastTime = performance.now();
    }
  }
  function gameOver(){
    state=STATE.OVER;
    runtime.runTimer?.setPauseSource('gameover', true);
    overlayManager.setActive('over');
  }

  // ======= 地图/房间生成 =======
  class Room{
    constructor(i,j){
      this.i=i; this.j=j;
      this.doors={up:false,down:false,left:false,right:false};
      this.cleared=false; this.visited=false; this.discovered=false;
      this.enemies=[]; this.pickups=[];
      this.obstacles=[]; this.obstaclesGenerated=false;
      this.bombs=[];
      this.isBoss=false; this.bossEntity=null; this.bossDefeated=false; this.bossName=''; this.introPlayed=false; this.bossId='idol';
      this.isItemRoom=false; this.itemData=null; this.itemClaimed=false; this.itemSpawned=false;
      this.isShop=false; this.shopInventory=[]; this.shopPrepared=false; this.locked=false;
      this.isSafeRoom=false;
      this.portal=null;
      this.extraPortals=[];
      this.combatRoom=false;
      this.chargeGranted=false;
    }
    center(){ return {x: CONFIG.roomW/2, y: CONFIG.roomH/2}; }
    spawnEnemies(depth){
      this.ensureObstacles();
      if(this.isSafeRoom){
        this.enemies = [];
        this.cleared = true;
        this.combatRoom = false;
        this.chargeGranted = true;
        return this.enemies;
      }
      if(this.isItemRoom){
        this.enemies = [];
        this.cleared = true;
        this.ensureItem();
        this.combatRoom = false;
        this.chargeGranted = true;
        return this.enemies;
      }
      if(this.isShop){
        this.prepareShop();
        this.enemies = [];
        this.cleared = true;
        this.combatRoom = false;
        this.chargeGranted = true;
        return this.enemies;
      }
      if(this.isBoss){
        if(this.bossDefeated){ this.enemies = []; return this.enemies; }
        this.portal = null;
        if(!this.bossEntity || this.bossEntity.dead){
          const c = this.center();
          this.bossEntity = makeBoss(c, this);
        } else {
          prepareEnemy(this.bossEntity);
        }
        this.enemies = [this.bossEntity];
        this.cleared = false;
        this.combatRoom = true;
        this.chargeGranted = false;
        return this.enemies;
      }
      // 按深度稍微增加数量
      const baseCount = Math.floor(randRange(CONFIG.enemy.spawnMin, CONFIG.enemy.spawnMax+1) + (depth*0.24));
      const limit = CONFIG.enemy.maxPerRoom || baseCount;
      const spawnFactor = player?.getEnemySpawnFactor ? player.getEnemySpawnFactor() : 1;
      const adjustedCount = Math.max(1, Math.round(baseCount * spawnFactor));
      const n = Math.max(1, Math.min(limit, adjustedCount));
      this.enemies = [];
      for(let k=0;k<n;k++){
        const t = rollEnemyType(depth);
        const radius = ENEMY_SPAWN_RADIUS[t] || CONFIG.player.radius;
        const pos = this.findSpawnPosition(radius);
        this.enemies.push(makeEnemy(t, pos, depth));
      }
      this.combatRoom = this.enemies.length>0;
      this.chargeGranted = !this.combatRoom;
      return this.enemies;
    }
    ensureItem(){
      if(!this.isItemRoom || this.itemClaimed) return;
      if(!this.itemData){ this.itemData = rollItem(); }
      if(this.itemSpawned) return;
      const c = this.center();
      this.pickups = this.pickups.filter(p=>p.type!=='item');
      this.pickups.push(makeItemPickup(c.x, c.y, this));
      this.itemSpawned = true;
    }
    ensureObstacles(){
      if(this.obstaclesGenerated) return;
      this.obstaclesGenerated = true;
      if(this.isBoss || this.isItemRoom || this.isShop) return;
      const targetClusters = Math.floor(randRange(CONFIG.obstacles.min, CONFIG.obstacles.max+1));
      const tileSize = CONFIG.player.radius * 2 * CONFIG.obstacles.tileSizePlayerRatio;
      const created=[];
      let clustersPlaced = 0;
      let tries=0;
      while(clustersPlaced < targetClusters && tries < 220){
        tries++;
        const maxTiles = Math.max(1, CONFIG.obstacles.maxTiles|0);
        const isHidden = rand() < CONFIG.obstacles.hiddenChance;
        let tilesX = 1;
        let tilesY = 1;
        if(isHidden){
          tilesX = 1;
          tilesY = 1;
        } else {
          const baseX = Math.max(1, Math.floor(randRange(1, maxTiles+1)));
          const baseY = Math.max(1, Math.floor(randRange(1, maxTiles+1)));
          const emphasizeLarge = rand() < 0.6;
          tilesX = emphasizeLarge ? Math.max(2, baseX) : baseX;
          tilesY = emphasizeLarge ? Math.max(2, baseY) : baseY;
          if(rand() < 0.4){
            const square = Math.max(2, Math.floor(randRange(2, Math.min(maxTiles, 4)+1)));
            tilesX = square;
            tilesY = Math.max(2, Math.floor(randRange(2, maxTiles+1)));
          }
          if(rand() < 0.5){ tilesX = Math.max(2, tilesX); }
          if(rand() < 0.5){ tilesY = Math.max(2, tilesY); }
          if(tilesX===1 && tilesY===1){
            if(rand()<0.5){ tilesX = Math.max(2, Math.floor(randRange(2, maxTiles+1))); }
            else { tilesY = Math.max(2, Math.floor(randRange(2, maxTiles+1))); }
          }
        }
        while(tilesX * tilesY > CONFIG.obstacles.maxClusterArea){
          if(tilesX>=tilesY && tilesX>1){ tilesX--; }
          else if(tilesY>1){ tilesY--; }
          else break;
        }
        if(tilesX * tilesY > CONFIG.obstacles.maxClusterArea){ continue; }
        const clusterW = tilesX * tileSize;
        const clusterH = tilesY * tileSize;
        if(clusterW >= CONFIG.roomW-120 || clusterH >= CONFIG.roomH-140) continue;
        const minX = 60;
        const maxX = CONFIG.roomW - 60 - clusterW;
        const minY = 70;
        const maxY = CONFIG.roomH - 70 - clusterH;
        if(maxX < minX || maxY < minY) continue;
        const x = maxX===minX ? minX : randRange(minX, maxX);
        const y = maxY===minY ? minY : randRange(minY, maxY);
        const clusterRect = {x, y, w:clusterW, h:clusterH};
        if(this.collidesDoorCorridor(clusterRect)) continue;
        const isThreeByThree = tilesX===3 && tilesY===3;
        const hollow = !isHidden && isThreeByThree && rand() < CONFIG.obstacles.hollowChance;
        const candidateTiles = [];
        let blocked=false;
        for(let ix=0; ix<tilesX && !blocked; ix++){
          for(let iy=0; iy<tilesY; iy++){
            if(hollow && ix===1 && iy===1) continue;
            const tile = {x: x + ix*tileSize, y: y + iy*tileSize, w: tileSize, h: tileSize};
            for(const existing of created){
              if(rectOverlap(existing, tile)){ blocked=true; break; }
            }
            if(blocked) break;
            candidateTiles.push(tile);
          }
        }
        if(blocked || !candidateTiles.length) continue;
        const parent = {
          hidden: isHidden,
          lootDropped: false,
          dropPos: {x: x + clusterW/2, y: y + clusterH/2},
          remaining: candidateTiles.length,
        };
        for(const tile of candidateTiles){
          tile.hp = 60;
          tile.destroyed = false;
          tile.parent = parent;
          tile.hidden = isHidden;
        }
        created.push(...candidateTiles);
        clustersPlaced++;
        if(hollow){
          const centerX = x + tileSize * 1.5;
          const centerY = y + tileSize * 1.5;
          spawnRandomDrop(this, centerX, centerY);
        }
      }
      this.obstacles = created;
    }
    collidesDoorCorridor(rect){
      const corridors = [];
      if(this.doors.up) corridors.push({x:CONFIG.roomW/2-60,y:0,w:120,h:180});
      if(this.doors.down) corridors.push({x:CONFIG.roomW/2-60,y:CONFIG.roomH-180,w:120,h:180});
      if(this.doors.left) corridors.push({x:0,y:CONFIG.roomH/2-70,w:180,h:140});
      if(this.doors.right) corridors.push({x:CONFIG.roomW-180,y:CONFIG.roomH/2-70,w:180,h:140});
      corridors.push({x:CONFIG.roomW/2-80,y:CONFIG.roomH/2-200,w:160,h:400});
      corridors.push({x:CONFIG.roomW/2-220,y:CONFIG.roomH/2-80,w:440,h:160});
      return corridors.some(c=>rectOverlap(c, rect));
    }
    findSpawnPosition(radius){
      const marginX = Math.max(60, radius + 36);
      const marginY = Math.max(64, radius + 40);
      const candidates = Math.max(20, (this.obstacles?.length||0) * 2 + 20);
      for(let attempt=0; attempt<candidates; attempt++){
        const x = randRange(marginX, CONFIG.roomW - marginX);
        const y = randRange(marginY, CONFIG.roomH - marginY);
        const circle = {x,y,r:radius};
        const rect = {x:x-radius, y:y-radius, w:radius*2, h:radius*2};
        if(this.collidesDoorCorridor(rect)) continue;
        let blocked = false;
        for(const obs of this.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(circle, obs)){ blocked=true; break; }
        }
        if(blocked) continue;
        for(const other of this.enemies){
          if(other?.dead) continue;
          if(dist(other, circle) < (other.r || radius) + radius + 6){ blocked=true; break; }
        }
        if(blocked) continue;
        return {x,y};
      }
      const center = this.center();
      const fallbackChecks = [
        {x:center.x, y:center.y},
        {x:center.x + radius*2.4, y:center.y},
        {x:center.x - radius*2.4, y:center.y},
        {x:center.x, y:center.y + radius*2.4},
        {x:center.x, y:center.y - radius*2.4},
      ];
      for(const pos of fallbackChecks){
        const x = clamp(pos.x, marginX, CONFIG.roomW - marginX);
        const y = clamp(pos.y, marginY, CONFIG.roomH - marginY);
        const circle = {x,y,r:radius};
        const rect = {x:x-radius, y:y-radius, w:radius*2, h:radius*2};
        if(this.collidesDoorCorridor(rect)) continue;
        let blocked = false;
        for(const obs of this.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(circle, obs)){ blocked = true; break; }
        }
        if(blocked) continue;
        for(const other of this.enemies){
          if(other?.dead) continue;
          if(dist(other, circle) < (other.r || radius) + radius + 6){ blocked = true; break; }
        }
        if(!blocked) return {x,y};
      }
      return {
        x: clamp(center.x, marginX, CONFIG.roomW - marginX),
        y: clamp(center.y, marginY, CONFIG.roomH - marginY)
      };
    }
    prepareShop(){
      if(!this.isShop || this.shopPrepared) return;
      this.shopPrepared = true;
      this.pickups = [];
      const slots = [
        {x:CONFIG.roomW*0.28, y:CONFIG.roomH*0.28},
        {x:CONFIG.roomW*0.5, y:CONFIG.roomH*0.26},
        {x:CONFIG.roomW*0.72, y:CONFIG.roomH*0.28},
        {x:CONFIG.roomW*0.32, y:CONFIG.roomH*0.64},
        {x:CONFIG.roomW*0.68, y:CONFIG.roomH*0.64},
      ];
      const shopItems = rollShopItems();
      let idx=0;
      for(const entry of shopItems){
        if(idx>=slots.length) break;
        const slot=slots[idx++];
        if(entry.type==='item'){
          this.pickups.push(makeShopPickup(slot.x, slot.y, entry, CONFIG.shop.itemPrice));
        } else if(entry.type==='card'){
          this.pickups.push(makeShopPickup(slot.x, slot.y, entry, CONFIG.cards?.price ?? 5));
        } else {
          this.pickups.push(makeShopPickup(slot.x, slot.y, entry, CONFIG.shop.dropPrice));
        }
      }
      this.shopInventory = shopItems.map(entry=>{
        if(entry.type==='item'){
          return {type:'item', item:{...entry.item}};
        }
        if(entry.type==='card'){
          return {type:'card', card:{...entry.card}};
        }
        return {...entry};
      });
    }
  }

  class Dungeon{
    constructor(){
      this.gridN = CONFIG.grid;
      // 创建空房
      this.rooms = Array.from({length:this.gridN}, ()=> Array.from({length:this.gridN},()=>null));
      const mid = Math.floor(this.gridN/2);
      const start = new Room(mid,mid);
      start.isSafeRoom = true;
      start.cleared = true;
      this.rooms[mid][mid] = start;
      this.start = start;
      const created = [start];
      const coords = [{i:mid,j:mid}];
      let attempts = 0;
      while(created.length < CONFIG.roomsToMake && attempts < CONFIG.roomsToMake*20){
        const baseIndex = Math.floor(rand()*coords.length);
        const base = coords[baseIndex];
        const baseRoom = this.rooms[base.i][base.j];
        const options = DIRS.map(dir=>({dir,ni:base.i+dir.di,nj:base.j+dir.dj}))
          .filter(opt=>opt.ni>=0 && opt.ni<this.gridN && opt.nj>=0 && opt.nj<this.gridN && !this.rooms[opt.ni][opt.nj]);
        if(!options.length){ attempts++; continue; }
        const choice = options[Math.floor(rand()*options.length)];
        const newRoom = new Room(choice.ni, choice.nj);
        this.rooms[choice.ni][choice.nj] = newRoom;
        created.push(newRoom);
        coords.push({i:choice.ni, j:choice.nj});
        baseRoom.doors[choice.dir.key] = true;
        newRoom.doors[choice.dir.opp] = true;
        attempts = 0;
      }
      this.allRooms = created;

      this.current = this.start;
      this.depth = 1;
      this.bounds = {minI:mid, maxI:mid, minJ:mid, maxJ:mid};

      // 指定 Boss 房 & 道具房
      this.bossRoom = this.setupBossRoom(mid);
      this.itemRooms = this.setupItemRooms(mid);
      this.shopRoom = this.setupShopRoom(mid);
      this.setupLifeTradePickup();
      if((typeof currentFloor === 'number' ? currentFloor : 1) <= 1){
        const alreadyHasSoul = start.pickups.some(p=>p && p.type==='heart' && p.kind==='soul');
        if(!alreadyHasSoul){
          const spawnX = Math.max(60, CONFIG.roomW - 80);
          const spawnY = Math.max(60, CONFIG.roomH - 80);
          const soul = makeSoulHeartPickup(spawnX, spawnY, 1);
          if(soul){
            soul.spawnGrace = 0;
            start.pickups.push(soul);
          }
        }
      }

      // 连接所有相邻房间的门，确保连通性
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r = this.rooms[i][j]; if(!r) continue;
          for(const dir of DIRS){
            const ni = i + dir.di, nj = j + dir.dj;
            if(ni<0 || nj<0 || ni>=this.gridN || nj>=this.gridN) continue;
            if(this.rooms[ni][nj]){
              r.doors[dir.key] = true;
              this.rooms[ni][nj].doors[dir.opp] = true;
            }
          }
        }
      }
    }

    setupLifeTradePickup(){
      if(!this.start || this.lifeTradePrepared) return;
      const cfg = CONFIG.lifeTrade || {};
      const chance = Math.max(0, Math.min(1, cfg.spawnChance ?? 0.25));
      if(rand() >= chance) return;
      const item = rollLifeTradeItem();
      if(!item) return;
      const pos = cfg.spawnPosition || {x: 120, y: 150};
      const pickup = makeLifeTradePickup(pos.x, pos.y, item, {room:this.start});
      if(!pickup) return;
      this.start.pickups.push(pickup);
      this.lifeTradePrepared = true;
    }

    setupBossRoom(mid){
      let farthest=null, maxDist=-1;
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j]; if(!r || (i===mid && j===mid)) continue;
          const d = Math.abs(i-mid)+Math.abs(j-mid);
          if(d>maxDist){ maxDist=d; farthest=r; }
        }
      }
      if(!farthest) return null;
      for(const dir of DIRS){
        const ni = farthest.i+dir.di;
        const nj = farthest.j+dir.dj;
        if(ni<0 || nj<0 || ni>=this.gridN || nj>=this.gridN) continue;
        if(this.rooms[ni][nj]) continue;
        const bossRoom = new Room(ni,nj);
        bossRoom.isBoss=true;
        const bossType = rollBossType();
        bossRoom.bossId = bossType.id;
        bossRoom.bossName = bossType.name;
        this.rooms[ni][nj]=bossRoom;
        farthest.doors[dir.key]=true;
        bossRoom.doors[dir.opp]=true;
        this.allRooms.push(bossRoom);
        return bossRoom;
      }
      // 如果周围无空位，则直接把最远房间作为 Boss 房
      farthest.isBoss=true;
      const fallbackType = rollBossType();
      farthest.bossId = fallbackType.id;
      farthest.bossName = fallbackType.name;
      return farthest;
    }

    setupItemRooms(mid){
      const items=[];
      const available=[];
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j];
          if(!r || r.isBoss || (i===mid && j===mid)) continue;
          const dist = Math.abs(i-mid)+Math.abs(j-mid);
          const options = DIRS.map(dir=>({dir,ni:i+dir.di,nj:j+dir.dj}))
            .filter(opt=>opt.ni>=0 && opt.nj>=0 && opt.ni<this.gridN && opt.nj<this.gridN && !this.rooms[opt.ni][opt.nj]);
          if(options.length){ available.push({room:r, options, dist}); }
        }
      }
      const need = Math.max(1, CONFIG.itemRooms|0);
      let placed = 0;
      while(placed<need && available.length){
        available.sort((a,b)=>b.dist-a.dist || rand()-0.5);
        const choice = available.shift();
        const target = choice.options[Math.floor(rand()*choice.options.length)];
        const itemRoom = new Room(target.ni, target.nj);
        itemRoom.isItemRoom = true;
        itemRoom.cleared = true;
        itemRoom.locked = true;
        this.rooms[target.ni][target.nj] = itemRoom;
        choice.room.doors[target.dir.key] = true;
        itemRoom.doors[target.dir.opp] = true;
        this.allRooms.push(itemRoom);
        items.push(itemRoom);
        placed++;
        for(let k=available.length-1;k>=0;k--){
          available[k].options = available[k].options.filter(opt=>!this.rooms[opt.ni][opt.nj]);
          if(!available[k].options.length) available.splice(k,1);
        }
      }
      if(placed===0){
        // 如果无法扩展，则挑选一个非 Boss 房间直接转为道具房
        for(let i=0;i<this.gridN;i++){
          for(let j=0;j<this.gridN;j++){
            const r=this.rooms[i][j];
            if(!r || r.isBoss || (i===mid && j===mid)) continue;
            r.isItemRoom = true;
            r.cleared = true;
            r.locked = true;
            items.push(r);
            placed=1;
            break;
          }
          if(placed) break;
        }
      }
      return items;
    }

    setupShopRoom(mid){
      const candidates=[];
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j];
          if(!r || r.isBoss || r.isItemRoom || (i===mid && j===mid)) continue;
          const dist = Math.abs(i-mid)+Math.abs(j-mid);
          const options = DIRS.map(dir=>({dir,ni:i+dir.di,nj:j+dir.dj}))
            .filter(opt=>opt.ni>=0 && opt.nj>=0 && opt.ni<this.gridN && opt.nj<this.gridN && !this.rooms[opt.ni][opt.nj]);
          if(options.length){ candidates.push({room:r, options, dist}); }
        }
      }
      candidates.sort((a,b)=>b.dist-a.dist || rand()-0.5);
      const choice = candidates[0];
      if(choice){
        const target = choice.options[Math.floor(rand()*choice.options.length)];
        const shop = new Room(target.ni, target.nj);
        shop.isShop = true;
        shop.cleared = true;
        shop.locked = true;
        this.rooms[target.ni][target.nj] = shop;
        choice.room.doors[target.dir.key] = true;
        shop.doors[target.dir.opp] = true;
        this.allRooms.push(shop);
        return shop;
      }
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j];
          if(!r || r.isBoss || r.isItemRoom || (i===mid && j===mid)) continue;
          r.isShop = true;
          r.cleared = true;
          r.locked = true;
          r.obstacles = [];
          r.obstaclesGenerated = true;
          return r;
        }
      }
      return null;
    }

    updateBounds(room){
      if(!room) return;
      this.bounds.minI = Math.min(this.bounds.minI, room.i);
      this.bounds.maxI = Math.max(this.bounds.maxI, room.i);
      this.bounds.minJ = Math.min(this.bounds.minJ, room.j);
      this.bounds.maxJ = Math.max(this.bounds.maxJ, room.j);
    }

    revealRoom(room){
      if(!room) return;
      room.discovered = true;
      this.updateBounds(room);
    }
    revealAllRooms(){
      const rooms = Array.isArray(this.allRooms) ? this.allRooms : [];
      if(!rooms.length) return;
      let minI = Infinity, maxI = -Infinity, minJ = Infinity, maxJ = -Infinity;
      for(const room of rooms){
        if(!room) continue;
        room.discovered = true;
        minI = Math.min(minI, room.i);
        maxI = Math.max(maxI, room.i);
        minJ = Math.min(minJ, room.j);
        maxJ = Math.max(maxJ, room.j);
      }
      if(minI === Infinity){
        return;
      }
      if(!this.bounds){
        this.bounds = {minI, maxI, minJ, maxJ};
        return;
      }
      this.bounds.minI = Math.min(this.bounds.minI, minI);
      this.bounds.maxI = Math.max(this.bounds.maxI, maxI);
      this.bounds.minJ = Math.min(this.bounds.minJ, minJ);
      this.bounds.maxJ = Math.max(this.bounds.maxJ, maxJ);
    }
  }
  function key(i,j){return `${i},${j}`}

  function weightedRoll(pool, options={}){
    const exclude = options.exclude;
    const excludeSet = Array.isArray(exclude) && exclude.length ? new Set(exclude) : null;
    let candidates = !excludeSet ? pool.slice() : pool.filter(item=>{
      if(!item || typeof item !== 'object') return false;
      if(item.slug==null) return true;
      return !excludeSet.has(item.slug);
    });
    if(!candidates.length){
      candidates = pool.slice();
    }
    candidates = candidates.filter(item=>item && typeof item === 'object');
    if(!candidates.length){
      const fallback = pool.find(item=>item && typeof item === 'object');
      if(fallback) return {...fallback};
      return {...(pool[0]||{})};
    }
    const minWeight = Number.isFinite(options.minWeight) ? Math.max(0, options.minWeight) : 0;
    const pityKey = options.poolKey || options.pityKey || null;
    const pityStep = Number.isFinite(options.pityStep) ? Math.max(0, options.pityStep) : 0.12;
    const pityCap = Number.isFinite(options.pityCap) ? Math.max(0, options.pityCap) : 1;
    const rareThresholdFactor = Number.isFinite(options.rareThreshold) ? Math.max(1, options.rareThreshold) : 1.5;
    let pityStore = null;
    let pityValue = 0;
    if(pityKey && typeof runtime !== 'undefined' && runtime){
      pityStore = runtime.weightedPity || (runtime.weightedPity = Object.create(null));
      pityValue = Math.max(0, Number(pityStore[pityKey]) || 0);
    }
    const weights = candidates.map(item=>{
      const w = Number(item?.weight);
      if(Number.isFinite(w) && w>0){
        return minWeight>0 ? Math.max(w, minWeight) : w;
      }
      if(minWeight>0){
        return minWeight;
      }
      return 0.0001;
    });
    const positives = weights.filter(w=>w>0);
    const minPositive = positives.length ? Math.min(...positives) : 0;
    let rareIndices = [];
    if(minPositive>0){
      const threshold = minPositive * rareThresholdFactor;
      for(let i=0;i<weights.length;i++){
        if(weights[i]>0 && weights[i] <= threshold){
          rareIndices.push(i);
        }
      }
    }
    if(!rareIndices.length){ rareIndices = null; }
    const total = weights.reduce((sum,w)=>sum+w,0);
    const extraSpan = pityValue>0 ? pityValue : 0;
    let pick = total>0 ? rand()*(total + extraSpan) : rand()*candidates.length;
    let chosenIndex = -1;
    let usedPity = false;
    if(total>0){
      if(extraSpan>0 && pick>total && rareIndices && rareIndices.length){
        chosenIndex = rareIndices[Math.floor(rand()*rareIndices.length)];
        usedPity = true;
      } else {
        if(pick>total){ pick = rand()*total; }
        for(let i=0;i<candidates.length;i++){
          const weight = weights[i]>0 ? weights[i] : (total>0 ? Math.max(0.0001, minWeight || 0.0001) : 1);
          pick -= weight;
          if(pick<=0){
            chosenIndex = i;
            break;
          }
        }
      }
    }
    if(chosenIndex<0){
      if(total<=0){
        chosenIndex = Math.floor(rand()*candidates.length);
      }
      if(chosenIndex<0 || chosenIndex>=candidates.length){
        chosenIndex = candidates.length-1;
      }
    }
    if(pityStore){
      const rareSet = rareIndices ? new Set(rareIndices) : null;
      if(usedPity || (rareSet && rareSet.has(chosenIndex))){
        pityStore[pityKey] = 0;
      } else if(pityStep>0){
        const current = Math.max(0, Number(pityStore[pityKey]) || 0);
        pityStore[pityKey] = Math.min(pityCap, current + pityStep);
      }
    }
    return {...candidates[chosenIndex]};
  }
  const recentItemHistory = [];
  const recentShopItemHistory = [];
  const recentCardHistory = [];
  const ACTIVE_ITEM_SLUGS = new Set(['outdoor-pouch','adrenaline','pocket-watch']);
  function rememberRecent(history, id, limit){
    if(!id) return;
    history.push(id);
    if(history.length>limit){ history.splice(0, history.length-limit); }
  }
  function rollItem(){
    const item = weightedRoll(ITEM_POOL, {exclude: recentItemHistory, poolKey:'item', minWeight:0.001});
    rememberRecent(recentItemHistory, item.slug, 3);
    return item;
  }
  function rollPassiveItem(){
    const pool = ITEM_POOL.filter(item=>item && !ACTIVE_ITEM_SLUGS.has(item.slug));
    if(!pool.length){
      return rollItem();
    }
    const item = weightedRoll(pool, {exclude: recentItemHistory, poolKey:'item', minWeight:0.001});
    rememberRecent(recentItemHistory, item.slug, 3);
    return item;
  }
  function rollCard(){
    const card = weightedRoll(CARD_POOL, {exclude: recentCardHistory});
    rememberRecent(recentCardHistory, card.slug, 2);
    return card;
  }
  function rollShopItems(){
    const entries=[];
    const indices=[0,1,2,3,4];
    for(let i=indices.length-1;i>0;i--){ const j=Math.floor(rand()*(i+1)); [indices[i],indices[j]]=[indices[j],indices[i]]; }
    const itemCount = rand()<CONFIG.shop.doubleItemChance ? 2 : 1;
    const itemSlots = new Set(indices.slice(0,itemCount));
    const cardChance = Math.max(0, CONFIG.cards?.shopCardChance ?? 0);
    for(let i=0;i<5;i++){
      if(itemSlots.has(i)){
        const rareChance = Math.max(0, CONFIG.shop?.rareItemChance ?? 0);
        let poolRef = SHOP_ITEM_POOL;
        let rollOptions = {exclude: recentShopItemHistory, poolKey:'shop', minWeight:0.001, pityStep:0.08, pityCap:0.8};
        if(SHOP_RARE_ITEM_POOL.length && rand() < rareChance){
          poolRef = SHOP_RARE_ITEM_POOL;
          rollOptions = {exclude: recentShopItemHistory, poolKey:'shop-rare', minWeight:0.0005, pityStep:0.08, pityCap:0.8};
        }
        const shopItem = weightedRoll(poolRef, rollOptions);
        rememberRecent(recentShopItemHistory, shopItem.slug, 2);
        entries.push({type:'item', item: shopItem});
      } else {
        if(rand() < cardChance){
          entries.push({type:'card', card: rollCard()});
        } else {
          const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
          const amount = resType==='coin'?8:2;
          entries.push({type:'resource', resource:resType, amount});
        }
      }
    }
    return entries;
  }
  function rollBossItem(){
    const rareChance = Math.max(0, CONFIG.loot?.bossRareChance ?? 0);
    if(BOSS_RARE_ITEM_POOL.length && rand() < rareChance){
      return weightedRoll(BOSS_RARE_ITEM_POOL, {poolKey:'boss-rare', minWeight:0.0005, pityStep:0.1, pityCap:1});
    }
    return weightedRoll(BOSS_ITEM_POOL, {poolKey:'boss', minWeight:0.0005, pityStep:0.1, pityCap:1});
  }
  function rollLifeTradeItem(){
    return weightedRoll(LIFE_TRADE_POOL, {poolKey:'life-trade', minWeight:0.0005, pityStep:0.1, pityCap:0.9});
  }

  function makeItemPickup(x,y,room){
    return {
      type:'item',
      x:clamp(x,80,CONFIG.roomW-80),
      y:clamp(y,90,CONFIG.roomH-90),
      r:18,
      item:room.itemData,
      room,
      vx:0,
      vy:0,
      solid:false
    };
  }
  function normalizeLifeTradeCost(cost){
    const fallback = Math.max(1, Math.floor(CONFIG.lifeTrade?.defaultCost ?? 2));
    if(!cost){
      return {type:'flat', amount: fallback};
    }
    if(cost.type === 'set-to-one'){
      return {type:'set-to-one'};
    }
    const amount = Math.max(1, Math.floor(Number.isFinite(cost.amount) ? cost.amount : fallback));
    return {type:'flat', amount};
  }
  function formatLifeTradeCost(cost){
    if(!cost) return '献祭未知代价';
    if(cost.type === 'set-to-one') return '献祭至 1 心';
    const amount = Math.max(1, cost.amount ?? Math.floor(CONFIG.lifeTrade?.defaultCost ?? 2));
    return `献祭 ${amount} 点上限`;
  }
  function makeLifeTradePickup(x,y,item, options={}){
    if(!item) return null;
    const baseCost = options.costConfig || item.lifeTradeCost;
    const cost = normalizeLifeTradeCost(baseCost);
    const px = clamp(options.x ?? x, 80, CONFIG.roomW-80);
    const py = clamp(options.y ?? y, 90, CONFIG.roomH-90);
    const clone = {...item};
    clone.lifeTradeCost = normalizeLifeTradeCost(clone.lifeTradeCost || cost);
    return {
      type:'life-trade',
      x:px,
      y:py,
      r: options.radius || 18,
      item: clone,
      room: options.room || null,
      costConfig: cost,
      costLabel: formatLifeTradeCost(cost),
      solid:false,
      spawnGrace:0,
      label: options.label || null,
    };
  }
  function canAffordLifeTrade(playerInstance, cost){
    if(!playerInstance || !cost) return false;
    if(cost.type === 'set-to-one'){
      return playerInstance.maxHp >= 1;
    }
    const amount = Math.max(1, cost.amount ?? Math.floor(CONFIG.lifeTrade?.defaultCost ?? 2));
    return playerInstance.maxHp - amount >= 1;
  }
  function applyLifeTradeCost(playerInstance, cost){
    if(!playerInstance || !cost) return false;
    if(cost.type === 'set-to-one'){
      if(typeof playerInstance.setMaxHpToSingle === 'function'){
        playerInstance.setMaxHpToSingle();
      } else {
        playerInstance.maxHp = Math.max(1, Math.floor(playerInstance.maxHp));
        playerInstance.hp = Math.min(playerInstance.hp, 1);
        playerInstance.maxHp = 1;
        playerInstance.recalculateDamage?.();
        playerInstance.updateHolyHeartBlessing?.();
      }
      return true;
    }
    const amount = Math.max(1, cost.amount ?? Math.floor(CONFIG.lifeTrade?.defaultCost ?? 2));
    if(!canAffordLifeTrade(playerInstance, {type:'flat', amount})) return false;
    if(typeof playerInstance.adjustMaxHp === 'function'){
      playerInstance.adjustMaxHp(-amount);
    } else {
      playerInstance.maxHp = Math.max(1, playerInstance.maxHp - amount);
      if(playerInstance.hp > playerInstance.maxHp){ playerInstance.hp = playerInstance.maxHp; }
      playerInstance.recalculateDamage?.();
      playerInstance.updateHolyHeartBlessing?.();
    }
    return true;
  }
  function describeLifeTradeRequirement(cost){
    if(!cost) return '需要更多生命上限。';
    if(cost.type === 'set-to-one') return '需要至少 1 点生命上限。';
    const amount = Math.max(1, cost.amount ?? Math.floor(CONFIG.lifeTrade?.defaultCost ?? 2));
    return `需要至少 ${amount + 1} 点生命上限。`;
  }
  function makeResourcePickup(type,x,y,amount){
    return {
      type,
      resource:type,
      amount:amount||1,
      x:clamp(x,70,CONFIG.roomW-70),
      y:clamp(y,80,CONFIG.roomH-80),
      r:12,
      vx:0,
      vy:0,
      solid:true,
      spawnGrace:CONFIG.pickupSpawnGrace,
    };
  }
  function makeCardPickup(x,y,card){
    return {
      type:'card',
      card: cloneCardData(card),
      x:clamp(x,70,CONFIG.roomW-70),
      y:clamp(y,80,CONFIG.roomH-80),
      r:16,
      vx:0,
      vy:0,
      solid:true,
      spawnGrace:CONFIG.pickupSpawnGrace,
      anglePhase: rand()*Math.PI*2,
    };
  }
  function makeShopPickup(x,y,entry,price){
    const normalizedPrice = Math.max(0, Math.round(Number(price) || 0));
    return {
      type:'shop',
      x:clamp(x,90,CONFIG.roomW-90),
      y:clamp(y,100,CONFIG.roomH-100),
      r:22,
      entry,
      price: normalizedPrice,
      basePrice: normalizedPrice,
      purchased:false,
      vx:0,
      vy:0,
      solid:false
    };
  }
  function resolveShopPrice(pickup, buyer=player){
    if(!pickup) return 0;
    const base = Math.max(0, Math.round(Number(pickup.basePrice ?? pickup.price) || 0));
    const owner = buyer || player;
    if(owner && typeof owner.getAdjustedPrice === 'function'){
      return owner.getAdjustedPrice(base);
    }
    return base;
  }
  function spawnRandomDrop(room,x,y){
    if(!room) return null;
    const roll = rand();
    let pickup = null;
    if(roll < 0.5){
      const heal = rand() < 0.25 ? 2 : 1;
      pickup = makeHeartPickup(x, y, heal);
    } else {
      const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
      let amount = 1;
      if(resType==='coin'){
        amount = rand() < 0.35 ? 5 : 3;
      } else if(rand() < 0.25){
        amount = 2;
      }
      pickup = makeResourcePickup(resType, x, y, amount);
    }
    room.pickups.push(pickup);
    return pickup;
  }

  function pickupItem(pickup){
    if(!pickup || !pickup.item) return;
    const item = pickup.item;
    const prevActiveSlug = player?.activeItem?.slug || null;
    if(typeof item.apply === 'function'){ item.apply(player); }
    const gainedActive = !!(player?.activeItem && player.activeItem.slug === item.slug && player.activeItem.slug !== prevActiveSlug);
    recordItemAcquired(player, item);
    if(pickup.room){ pickup.room.itemClaimed = true; pickup.room.itemSpawned = false; }
    runtime.itemPickupName = item.name;
    runtime.itemPickupDesc = item.description || '';
    runtime.itemPickupTimer = 3.2;
    triggerItemPickupAnimation({item, isActive: gainedActive, source: pickup});
    maybeSpawnCardDrop(pickup.room || dungeon?.current, {x: pickup.x, y: pickup.y});
  }
  function attemptLifeTradePickup(pickup){
    if(!pickup || !pickup.item) return false;
    const cost = normalizeLifeTradeCost(pickup.costConfig || pickup.item.lifeTradeCost);
    if(!canAffordLifeTrade(player, cost)){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = '血量不足';
        runtime.itemPickupDesc = describeLifeTradeRequirement(cost);
        runtime.itemPickupTimer = 1.6;
      }
      return false;
    }
    if(!applyLifeTradeCost(player, cost)) return false;
    const item = pickup.item;
    const prevActiveSlug = player?.activeItem?.slug || null;
    if(typeof item.apply === 'function'){ item.apply(player); }
    const gainedActive = !!(player?.activeItem && player.activeItem.slug === item.slug && player.activeItem.slug !== prevActiveSlug);
    recordItemAcquired(player, item);
    runtime.itemPickupName = item.name;
    runtime.itemPickupDesc = item.description || '';
    runtime.itemPickupTimer = 3.2;
    triggerItemPickupAnimation({item, isActive: gainedActive, source: pickup});
    maybeSpawnCardDrop(pickup.room || dungeon?.current, {x: pickup.x, y: pickup.y});
    return true;
  }
  function grantResource(type, amount){
    if(!player) return 0;
    const cap = 99;
    const amt = Math.max(0, Math.floor(amount||1));
    let prop = null;
    if(type==='bomb'){ prop='bombs'; }
    else if(type==='key'){ prop='keys'; }
    else if(type==='coin'){ prop='coins'; }
    if(!prop) return 0;
    const before = Math.max(0, player[prop]||0);
    const space = Math.max(0, cap - before);
    const gained = Math.min(space, amt);
    if(gained>0){
      player[prop] = clamp(before + gained, 0, cap);
      player.recalculateDamage();
    } else if(type==='coin'){ // 确保金币相关增益及时刷新
      player.recalculateDamage();
    }
    return gained;
  }

  function givePlayerCard(card, options={}){
    if(!player) return false;
    const data = cloneCardData(card);
    if(!data) return false;
    const previous = player.singleUseItem ? cloneCardData(player.singleUseItem) : null;
    player.setSingleUseItem(data);
    if(runtime){
      runtime.itemPickupName = `获得卡牌：${data.name}`;
      const detail = data.description ? `${data.description} · 按 Q 使用。` : '按 Q 使用后消耗。';
      runtime.itemPickupDesc = detail;
      runtime.itemPickupTimer = Math.max(runtime.itemPickupTimer, 2.2);
    }
    if(previous && options.dropPrevious !== false){
      const room = options.room || dungeon?.current;
      if(room){
        const baseX = options.x ?? player.x;
        const baseY = options.y ?? player.y;
        const px = clamp(baseX + randRange(-26,26), 70, CONFIG.roomW-70);
        const py = clamp(baseY + randRange(-24,24), 80, CONFIG.roomH-80);
        const drop = makeCardPickup(px, py, previous);
        if(drop){
          drop.spawnGrace = CONFIG.pickupSpawnGrace;
          room.pickups.push(drop);
        }
      }
    }
    return true;
  }

  function maybeSpawnCardDrop(room, options={}){
    if(!room) return null;
    let chance = Math.max(0, CONFIG.cards?.dropChanceOnItemPickup ?? 0);
    if(player){
      const bonus = typeof player.getCardDropBonus === 'function' ? player.getCardDropBonus() : Math.max(0, player.cardDropBonus || 0);
      chance = clamp(chance + bonus, 0, 0.95);
    }
    if(rand() >= chance) return null;
    const card = rollCard();
    if(!card) return null;
    const center = typeof room.center === 'function' ? room.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    const baseX = options.x ?? player?.x ?? center.x;
    const baseY = options.y ?? player?.y ?? center.y;
    const px = clamp(baseX + randRange(-24,24), 70, CONFIG.roomW-70);
    const py = clamp(baseY + randRange(-18,18), 80, CONFIG.roomH-80);
    const pickup = makeCardPickup(px, py, card);
    room.pickups.push(pickup);
    if(runtime){
      const extra = `额外掉落卡牌：${card.name}`;
      if(runtime.itemPickupTimer>0){
        const prevDesc = runtime.itemPickupDesc || '';
        runtime.itemPickupDesc = prevDesc && prevDesc.includes(extra) ? prevDesc : (prevDesc ? `${prevDesc} ${extra}` : extra);
        runtime.itemPickupTimer = Math.max(runtime.itemPickupTimer, 2.4);
      } else {
        runtime.itemPickupName = `掉落卡牌：${card.name}`;
        runtime.itemPickupDesc = card.description ? `${card.description} · 按 Q 使用。` : '按 Q 使用后消耗。';
        runtime.itemPickupTimer = 2.4;
      }
    }
    return pickup;
  }

  function isPhysicalPickup(p){
    return !!(p && p.solid);
  }
  function ensurePickupMotion(p){
    if(typeof p.vx !== 'number') p.vx = 0;
    if(typeof p.vy !== 'number') p.vy = 0;
  }
  function pushPickup(p, origin, strength, options={}){
    if(!isPhysicalPickup(p) || !origin) return;
    if(!options.force && (p.spawnGrace||0) > 0) return;
    ensurePickupMotion(p);
    const dx = p.x - origin.x;
    const dy = p.y - origin.y;
    const d = Math.hypot(dx,dy) || 0.0001;
    const impulse = strength ?? 180;
    const nx = dx / d;
    const ny = dy / d;
    p.vx += nx * impulse;
    p.vy += ny * impulse;
    const speed = Math.hypot(p.vx, p.vy);
    const maxSpeed = 360;
    if(speed > maxSpeed){
      const scale = maxSpeed / speed;
      p.vx *= scale;
      p.vy *= scale;
    }
    const overlap = (p.r + (origin.r||0)) - d;
    if(overlap>0){
      p.x += nx * overlap;
      p.y += ny * overlap;
    }
  }
  function keepPickupInBounds(p){
    const marginX = p.r + 24;
    const marginY = p.r + 28;
    if(p.x < marginX){
      p.x = marginX;
      if(p.vx<0) p.vx*=-0.55;
    }
    if(p.x > CONFIG.roomW - marginX){
      p.x = CONFIG.roomW - marginX;
      if(p.vx>0) p.vx*=-0.55;
    }
    if(p.y < marginY){
      p.y = marginY;
      if(p.vy<0) p.vy*=-0.55;
    }
    if(p.y > CONFIG.roomH - marginY){
      p.y = CONFIG.roomH - marginY;
      if(p.vy>0) p.vy*=-0.55;
    }
  }
  function resolvePickupObstacles(p, dt=0){
    if(!dungeon?.current) return false;
    if(p.spawnGrace>0) return false;
    const physical = isPhysicalPickup(p);
    let collided = false;
    for(const obs of dungeon.current.obstacles){
      if(obs.destroyed) continue;
      const push = circleRectResolve(p, obs);
      if(!push) continue;
      collided = true;
      p.x += push.x;
      p.y += push.y;
      const len = Math.hypot(push.x, push.y) || 0;
      const nx = len ? push.x/len : 0;
      const ny = len ? push.y/len : 0;
      if(len>0.0001){
        const extra = Math.min(6, len * 0.35);
        p.x += nx * extra;
        p.y += ny * extra;
      }
      if(physical){
        const dot = p.vx*nx + p.vy*ny;
        let boost = 0;
        if(dot<0){
          p.vx -= dot*nx;
          p.vy -= dot*ny;
          boost = -dot * 0.15;
        }
        const tx = -ny;
        const ty = nx;
        const tangentSpeed = p.vx*tx + p.vy*ty;
        if(boost!==0){
          p.vx += tx * boost;
          p.vy += ty * boost;
        }
        if(Math.abs(tangentSpeed)<8){
          p.vx += tx * 6 * dt;
          p.vy += ty * 6 * dt;
        }
      }
      if(dt>0 && (nx || ny)){
        const slideTimer = Math.min(1, (p._stuckSlide || 0) + dt);
        p._stuckSlide = slideTimer;
        const baseSpeed = physical ? 65 : 80;
        const slideSpeed = baseSpeed * (0.35 + slideTimer*0.65);
        const move = slideSpeed * dt;
        if(move>0){
          p.x += nx * move;
          p.y += ny * move;
          if(physical){
            const impulse = slideSpeed * 0.25 * dt;
            p.vx += nx * impulse;
            p.vy += ny * impulse;
          }
        }
      }
    }
    return collided;
  }
  function updatePickups(dt){
    const picks = dungeon?.current?.pickups;
    if(!picks) return;
    const decay = Math.exp(-dt*4.5);
    for(const p of picks){
      if(typeof p.spawnGrace === 'number' && p.spawnGrace>0){
        p.spawnGrace = Math.max(0, p.spawnGrace - dt);
      }
      const physical = isPhysicalPickup(p);
      ensurePickupMotion(p);
      if(physical){
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= decay;
        p.vy *= decay;
        if(Math.abs(p.vx) < 1e-2) p.vx = 0;
        if(Math.abs(p.vy) < 1e-2) p.vy = 0;
        keepPickupInBounds(p);
      } else {
        p.vx = 0;
        p.vy = 0;
      }
      const stuck = resolvePickupObstacles(p, dt);
      if(!physical){
        keepPickupInBounds(p);
      }
      if(!stuck && p._stuckSlide){
        if(dt>0){
          p._stuckSlide = Math.max(0, p._stuckSlide - dt*1.5);
          if(p._stuckSlide <= 1e-3) delete p._stuckSlide;
        } else {
          delete p._stuckSlide;
        }
      }
    }
  }
  function endBeam(beam){
    if(!beam) return;
    if(typeof beam.finish === 'function'){
      beam.finish();
    } else {
      beam.alive = false;
      if(beam.owner && beam.owner.brimstoneBeam === beam){
        beam.owner.brimstoneBeam = null;
        beam.owner.brimstoneFiring = false;
        beam.owner.brimstoneBeamTimer = 0;
      }
    }
  }
  function computeBeamGeometry(beam){
    const owner = beam?.owner;
    if(!owner) return null;
    const dir = beam.dir || {x:1,y:0};
    const len = Math.hypot(dir.x, dir.y) || 1;
    const nx = dir.x / len;
    const ny = dir.y / len;
    const startOffset = owner.r + (beam.startOffset ?? owner.r*0.2);
    const startX = owner.x + nx * startOffset;
    const startY = owner.y + ny * startOffset;
    const minX = 20, maxX = CONFIG.roomW - 20, minY = 20, maxY = CONFIG.roomH - 20;
    let maxT = Infinity;
    if(nx > 0){ maxT = Math.min(maxT, (maxX - startX) / nx); }
    else if(nx < 0){ maxT = Math.min(maxT, (minX - startX) / nx); }
    if(ny > 0){ maxT = Math.min(maxT, (maxY - startY) / ny); }
    else if(ny < 0){ maxT = Math.min(maxT, (minY - startY) / ny); }
    if(!Number.isFinite(maxT) || maxT < 0){ maxT = 0; }
    const endX = startX + nx * maxT;
    const endY = startY + ny * maxT;
    const length = Math.hypot(endX - startX, endY - startY);
    return {startX, startY, endX, endY, length, nx, ny};
  }

  function buildCurvedBeamSamples(geom, width, options={}){
    if(!geom) return [];
    const dx = geom.endX - geom.startX;
    const dy = geom.endY - geom.startY;
    const length = Math.hypot(dx, dy);
    if(!(length>1e-3)) return [];
    const tangentX = dx / length;
    const tangentY = dy / length;
    const normalX = -tangentY;
    const normalY = tangentX;
    const amplitudeFactor = Number.isFinite(options.amplitudeFactor) ? options.amplitudeFactor : 0.35;
    const amplitude = Math.max(4, width * amplitudeFactor);
    const sampleSpacing = Math.max(10, Number.isFinite(options.sampleSpacing) ? options.sampleSpacing : 22);
    const sampleCount = Math.max(12, Math.round(length / sampleSpacing));
    const wobble = Number.isFinite(options.phase) ? options.phase : 0;
    const seed = Number.isFinite(options.seed) ? options.seed : 0;
    const envelopePower = Number.isFinite(options.envelopePower) ? options.envelopePower : 1.15;
    const serpFreq = Number.isFinite(options.waveFrequency) ? options.waveFrequency : 6;
    const twistFreq = Number.isFinite(options.twistFrequency) ? options.twistFrequency : 9;
    const widthFreq = Number.isFinite(options.widthFrequency) ? options.widthFrequency : 5;
    const twistStrength = Number.isFinite(options.twistStrength) ? options.twistStrength : 0.28;
    const widthOscStrength = Number.isFinite(options.widthOscStrength) ? options.widthOscStrength : 0.22;
    const phaseMultiplier = Number.isFinite(options.phaseMultiplier) ? options.phaseMultiplier : 3;
    const twistPhaseMultiplier = Number.isFinite(options.twistPhaseMultiplier) ? options.twistPhaseMultiplier : 4.2;
    const widthPhaseMultiplier = Number.isFinite(options.widthPhaseMultiplier) ? options.widthPhaseMultiplier : 2.4;
    const samples = [];
    for(let i=0;i<=sampleCount;i++){
      const t = i / sampleCount;
      const baseX = geom.startX + dx * t;
      const baseY = geom.startY + dy * t;
      const clampedT = clamp(t, 0, 1);
      const envelope = Math.pow(Math.sin(Math.PI * clampedT) || 0, envelopePower);
      const serp = Math.sin(t * serpFreq + wobble * phaseMultiplier + seed * Math.PI * 2);
      const offset = serp * amplitude * envelope;
      const twist = Math.sin(t * twistFreq + wobble * twistPhaseMultiplier) * twistStrength;
      const cosTwist = Math.cos(twist);
      const sinTwist = Math.sin(twist);
      const localNx = normalX * cosTwist - tangentX * sinTwist;
      const localNy = normalY * cosTwist - tangentY * sinTwist;
      const widthOsc = 0.78 + widthOscStrength * Math.sin(t * widthFreq + wobble * widthPhaseMultiplier);
      const half = Math.max(4, (width * 0.5) * widthOsc);
      const centerX = baseX + localNx * offset;
      const centerY = baseY + localNy * offset;
      samples.push({x:centerX, y:centerY, nx:localNx, ny:localNy, half, t});
    }
    return samples;
  }

  function drawCurvedBeam(samples, geom, width, palette={}, options={}){
    if(!samples || samples.length<2 || !geom) return;
    const gradientInner = palette.gradientInner || '#fecaca';
    const gradientMid = palette.gradientMid || '#fca5a5';
    const gradientOuter = palette.gradientOuter || '#ef4444';
    const outlineColor = palette.stroke || '#b91c1c';
    const innerColor = palette.inner || '#fee2e2';
    const outerColor = palette.outer || '#f97316';
    const glowStart = palette.glowStart || gradientInner;
    const glowEnd = palette.glowEnd || gradientMid;
    const glowOuter = palette.glowOuter || gradientOuter;
    const highlightColor = palette.sparkle || '#fde68a';
    const coreScale = Number.isFinite(options.coreScale) ? options.coreScale : 0.55;
    const flickerSeed = Number.isFinite(options.seed) ? options.seed : 0;

    const drawRibbon = (scale, fillStyle, alpha=1)=>{
      ctx.save();
      ctx.beginPath();
      const first = samples[0];
      ctx.moveTo(first.x + first.nx * first.half * scale, first.y + first.ny * first.half * scale);
      for(let i=1;i<samples.length;i++){
        const s = samples[i];
        ctx.lineTo(s.x + s.nx * s.half * scale, s.y + s.ny * s.half * scale);
      }
      for(let i=samples.length-1;i>=0;i--){
        const s = samples[i];
        ctx.lineTo(s.x - s.nx * s.half * scale, s.y - s.ny * s.half * scale);
      }
      ctx.closePath();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = fillStyle;
      ctx.fill();
      ctx.restore();
    };

    ctx.save();
    const bodyGradient = ctx.createLinearGradient(geom.startX, geom.startY, geom.endX, geom.endY);
    bodyGradient.addColorStop(0, colorWithAlpha(gradientOuter, 0.65));
    bodyGradient.addColorStop(0.3, colorWithAlpha(gradientMid, 0.78));
    bodyGradient.addColorStop(0.65, colorWithAlpha(gradientInner, 0.82));
    bodyGradient.addColorStop(1, colorWithAlpha(gradientMid, 0.7));
    drawRibbon(1, bodyGradient, 0.92);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = colorWithAlpha(outlineColor, 0.45);
    ctx.lineWidth = Math.max(2, width * 0.18);
    ctx.beginPath();
    ctx.moveTo(samples[0].x + samples[0].nx * samples[0].half, samples[0].y + samples[0].ny * samples[0].half);
    for(let i=1;i<samples.length;i++){
      const s = samples[i];
      ctx.lineTo(s.x + s.nx * s.half, s.y + s.ny * s.half);
    }
    for(let i=samples.length-1;i>=0;i--){
      const s = samples[i];
      ctx.lineTo(s.x - s.nx * s.half, s.y - s.ny * s.half);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const coreGradient = ctx.createLinearGradient(geom.startX, geom.startY, geom.endX, geom.endY);
    coreGradient.addColorStop(0, colorWithAlpha(innerColor, 0.9));
    coreGradient.addColorStop(1, colorWithAlpha(highlightColor, 0.85));
    drawRibbon(coreScale, coreGradient, 0.75);
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = colorWithAlpha(highlightColor, 0.5);
    ctx.lineWidth = Math.max(1.2, width * 0.08);
    ctx.beginPath();
    ctx.moveTo(samples[0].x, samples[0].y);
    for(let i=1;i<samples.length;i++){
      const s = samples[i];
      ctx.lineTo(s.x, s.y);
    }
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.strokeStyle = colorWithAlpha(outerColor, 0.18);
    ctx.lineWidth = Math.max(width * 0.85, 12);
    ctx.beginPath();
    ctx.moveTo(samples[0].x, samples[0].y);
    for(let i=1;i<samples.length;i++){
      const s = samples[i];
      ctx.lineTo(s.x, s.y);
    }
    ctx.stroke();
    ctx.restore();

    const flicker = 0.7 + Math.sin(performance.now()/90 + flickerSeed * 6.18) * 0.2;
    const startRadius = Math.max(14, width * 0.75);
    const endRadius = Math.max(16, width * 0.85);
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const startGlow = ctx.createRadialGradient(geom.startX, geom.startY, 0, geom.startX, geom.startY, startRadius);
    startGlow.addColorStop(0, colorWithAlpha(glowStart, 0.6 * flicker));
    startGlow.addColorStop(1, colorWithAlpha(glowOuter, 0));
    ctx.fillStyle = startGlow;
    ctx.beginPath();
    ctx.arc(geom.startX, geom.startY, startRadius, 0, Math.PI*2);
    ctx.fill();
    const endGlow = ctx.createRadialGradient(geom.endX, geom.endY, 0, geom.endX, geom.endY, endRadius);
    endGlow.addColorStop(0, colorWithAlpha(glowEnd, 0.55 * flicker));
    endGlow.addColorStop(1, colorWithAlpha(glowOuter, 0));
    ctx.fillStyle = endGlow;
    ctx.beginPath();
    ctx.arc(geom.endX, geom.endY, endRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  function updateBeams(dt){
    const beams = runtime.beams;
    if(!Array.isArray(beams) || !beams.length) return;
    for(let i=beams.length-1;i>=0;i--){
      const beam = beams[i];
      if(!beam){ beams.splice(i,1); continue; }
      if(beam.alive === false){
        if(beam.owner && beam.owner.brimstoneBeam === beam){
          beam.owner.brimstoneBeam = null;
          beam.owner.brimstoneFiring = false;
          beam.owner.brimstoneBeamTimer = 0;
        }
        beams.splice(i,1);
        continue;
      }
      let stepDt = dt;
      if(runtime.timeStopTimer>0 && beam.owner && beam.owner !== player){
        stepDt = 0;
      }
      if(typeof beam.update === 'function'){
        beam.update(stepDt);
      } else {
        const wobbleRate = Number.isFinite(beam.wobbleSpeed) ? beam.wobbleSpeed : 2.8;
        beam.wobblePhase = (beam.wobblePhase || 0) + stepDt * wobbleRate;
        if(beam.wobblePhase > Math.PI * 200){ beam.wobblePhase -= Math.PI * 200; }
        if(Number.isFinite(beam.duration)){
          beam.duration -= stepDt;
          if(beam.duration <= 0){ beam.alive = false; }
        }
      }
      if(!beam.alive){
        if(beam.owner && beam.owner.brimstoneBeam === beam){
          beam.owner.brimstoneBeam = null;
          beam.owner.brimstoneFiring = false;
          beam.owner.brimstoneBeamTimer = 0;
        }
        beams.splice(i,1);
      }
    }
  }
  function keepBombInBounds(bomb){
    const margin = bomb.r + 24;
    const marginY = bomb.r + 24;
    if(bomb.x < margin){
      bomb.x = margin;
      if(bomb.vx<0) bomb.vx*=-0.55;
    }
    if(bomb.x > CONFIG.roomW - margin){
      bomb.x = CONFIG.roomW - margin;
      if(bomb.vx>0) bomb.vx*=-0.55;
    }
    if(bomb.y < marginY){
      bomb.y = marginY;
      if(bomb.vy<0) bomb.vy*=-0.55;
    }
    if(bomb.y > CONFIG.roomH - marginY){
      bomb.y = CONFIG.roomH - marginY;
      if(bomb.vy>0) bomb.vy*=-0.55;
    }
  }
  function resolveBombObstacles(bomb){
    if(!dungeon?.current || bomb.exploded) return;
    for(const obs of dungeon.current.obstacles){
      if(obs.destroyed) continue;
      const push = circleRectResolve(bomb, obs);
      if(push){
        bomb.x += push.x;
        bomb.y += push.y;
        const len = Math.hypot(push.x, push.y) || 1;
        const nx = push.x/len;
        const ny = push.y/len;
        const dot = bomb.vx*nx + bomb.vy*ny;
        if(dot<0){
          bomb.vx -= dot*nx;
          bomb.vy -= dot*ny;
        }
        bomb.x += nx * Math.min(6, len*0.35);
        bomb.y += ny * Math.min(6, len*0.35);
      }
    }
  }

  // ======= 实体 =======
  class Player{
    constructor(x,y){
      this.x=x; this.y=y; this.r=CONFIG.player.radius; this.speed=CONFIG.player.speed;
      this.maxHpCap = 20;
      this.maxHp = Math.min(CONFIG.player.hp, this.maxHpCap);
      this.hp = this.maxHp; this.ifr=0; // 无敌帧
      this.soulHearts = 0;
      this.soulHeartCapMultiplier = 1;
      this.unlimitedSoulHearts = true;
      this.ifrBoostMultiplier = 1;
      this.enemySpeedMultiplier = 1;
      this.enemySpawnFactor = 1;
      this.fireCd = 0; this.fireInterval = CONFIG.player.fireCd;
      this.tearSpeed=CONFIG.player.tearSpeed; this.tearLife=CONFIG.player.tearLife;
      this.baseDamage = 1;
      this.damageMultiplier = 1;
      this.damage = 1;
      this.items=[];
      this.itemStacks = Object.create(null);
      this.itemNameStacks = Object.create(null);
      this.bombs = CONFIG.resources.bombStart;
      this.keys = CONFIG.resources.keyStart;
      this.coins = CONFIG.resources.coinStart;
      this.bombCooldown = 0;
      this.knockVel = {x:0,y:0};
      this.knockTimer = 0;
      this.flying = false;
      this.canPierceObstacles = false;
      this.canPierceEnemies = false;
      this.effects = {bloodPower:false, moneyPower:false, despairPower:false};
      this.baseActiveMaxCharge = Math.max(0, CONFIG.player.activeMaxCharge ?? 0);
      this.activeItem = null;
      this.activeCharge = 0;
      this.activeMaxCharge = this.baseActiveMaxCharge;
      this.singleUseItem = null;
      this.timeScaleModifiers = new Map();
      this.bombRadiusMultiplier = 1;
      this.bombDamageMultiplier = 1;
      this.bombShakeStrength = 0;
      this.bombImmunity = false;
      this.explosionHealAmount = 0;
      this.bombElder = null;
      this.bombProgenitor = null;
      this.homingTears = false;
      this.homingStrength = 6;
      this.roomBuff = null;
      this.fullMapVision = false;
      this.ropeSpeedBonus = 0;
      this.ropeTearSpeedBonus = 0;
      this.shopPriceMultiplier = 1;
      this.shopPriceOffset = 0;
      this.cardDropBonus = 0;
      this.moveDir = {x:0,y:0};
      this.lastDisplacement = {x:0,y:0};
      this.lastVelocity = {x:0,y:0};
      this.vel = {x:0,y:0};
      this.accelTime = CONFIG.player.accelTime ?? 0.6;
      this.decelTime = CONFIG.player.decelTime ?? 0.6;
      this.maxSpeedScale = CONFIG.player.maxSpeedScale ?? 1.1;
      this.attackMode = 'tears';
      this.brimstoneStacks = 0;
      this.brimstoneCharging = false;
      this.brimstoneCharged = false;
      this.brimstoneCharge = 0;
      const brimstoneChargeScale = CONFIG?.brimstone?.chargeScale ?? 11.25;
      this.brimstoneChargeTime = Math.max(0.2, ((this.fireInterval || CONFIG.player.fireCd)/1000) * brimstoneChargeScale);
      this.brimstoneAim = {x:0, y:-1};
      this.brimstoneBeam = null;
      this.brimstoneFiring = false;
      this.brimstoneBeamTimer = 0;
      this.updateBrimstoneChargeMetrics();
      this.shotInput = {
        x: 0,
        y: 0,
        dirX: 0,
        dirY: -1,
        lastDirX: 0,
        lastDirY: -1,
        pressed: false,
        justPressed: false,
        justReleased: false,
      };
      this.setBonuses = {};
      this.followers = [];
      this.followerOrderCounter = 0;
      this.impactDash = this.createImpactDashState();
      this.hotChocolate = null;
      this.followerTrail = [];
      this.followerTrailMax = 220;
      this.entryLockActive = false;
      this.entryLockTimer = 0;
      this.eyePattern = null;
      this.holyHeartState = null;
      this.compressedPeachStacks = 0;
      this.compressedPeachState = null;
      if(typeof this.resetFollowerTrail === 'function'){
        this.resetFollowerTrail();
      }
    }
    update(dt, options={}){
      const entryLocked = !!options.entryLocked;
      const lockTime = Number.isFinite(options.entryLockTime) ? Math.max(0, options.entryLockTime) : 0;
      if(entryLocked){
        this.entryLockActive = true;
        this.entryLockTimer = Math.max(this.entryLockTimer || 0, lockTime);
      } else {
        this.entryLockTimer = Math.max(0, (this.entryLockTimer || 0) - dt);
        this.entryLockActive = this.entryLockTimer>0;
      }
      this.bombCooldown = Math.max(0, this.bombCooldown - dt);
      const dash = this.ensureImpactDashState();
      if(dash){
        if(dash.cooldown>0){
          const prevCooldown = dash.cooldown;
          dash.cooldown = Math.max(0, dash.cooldown - dt);
          const cooldownSynergy = this.collectSynergyOptions('impact-dash-cooldown', {cooldown: dash.cooldown});
          if(cooldownSynergy && Number.isFinite(cooldownSynergy.cooldown)){
            dash.cooldown = Math.max(0, cooldownSynergy.cooldown);
          }
          if(prevCooldown>0 && dash.cooldown===0){
            dash.readyPulse = Math.max(dash.readyPulse, 1.1);
            if(dash.unlocked && !dash.active){
              audio.play('dashReady', {volume: 0.55});
            }
          }
        } else {
          const cooldownSynergy = this.collectSynergyOptions('impact-dash-cooldown', {cooldown: dash.cooldown});
          if(cooldownSynergy && Number.isFinite(cooldownSynergy.cooldown)){
            const prevCooldown = dash.cooldown;
            dash.cooldown = Math.max(0, cooldownSynergy.cooldown);
            if(prevCooldown>0 && dash.cooldown===0){
              dash.readyPulse = Math.max(dash.readyPulse, 1.1);
              if(dash.unlocked && !dash.active){
                audio.play('dashReady', {volume: 0.55});
              }
            }
          }
          if(dash.readyPulse>0){
            dash.readyPulse = Math.max(0, dash.readyPulse - dt);
          }
        }
        if(dash.trail && dash.trail.alive === false){
          dash.trail = null;
        }
        if(dash.invulnTimer>0){
          dash.invulnTimer = Math.max(0, dash.invulnTimer - dt);
          if(dash.invulnTimer<=0){
            dash.invulnTimer = 0;
            if(!dash.active){
              dash.invulnTotal = 0;
            }
          }
        } else if(!dash.active && dash.invulnTotal>0){
          dash.invulnTotal = 0;
        }
      }
      const startX = this.x;
      const startY = this.y;
      let dashing = !!(dash && dash.active);
      if(entryLocked && dashing){
        this.endImpactDash({blocked:true});
        dashing = false;
      }
      let rawMoveX = dashing ? dash.dashDir.x : resolveAxis('KeyA','KeyD');
      let rawMoveY = dashing ? dash.dashDir.y : resolveAxis('KeyW','KeyS');
      if(entryLocked && !dashing){
        rawMoveX = 0;
        rawMoveY = 0;
      }
      let mv = {x:0,y:0};
      if(dashing){
        const len = Math.hypot(rawMoveX, rawMoveY) || 1;
        mv.x = rawMoveX / len;
        mv.y = rawMoveY / len;
      } else if(rawMoveX !== 0 || rawMoveY !== 0){
        const len = Math.hypot(rawMoveX, rawMoveY) || 1;
        mv.x = rawMoveX / len;
        mv.y = rawMoveY / len;
      }
      const accelTime = Math.max(0, this.accelTime ?? CONFIG.player.accelTime ?? 0.6);
      const decelTime = Math.max(0, this.decelTime ?? CONFIG.player.decelTime ?? 0.6);
      const maxSpeedScale = (this.maxSpeedScale ?? CONFIG.player.maxSpeedScale ?? 1.1);
      const accelRate = accelTime > 0 ? (this.speed / accelTime) : Infinity;
      const moveDt = entryLocked ? 0 : dt;
      let maxSpeed = this.speed * maxSpeedScale;
      const approachAxis = (current, target, rate)=>{
        if(!Number.isFinite(rate) || rate <= 0) return target;
        const maxStep = rate * moveDt;
        if(!Number.isFinite(maxStep) || maxStep <= 0) return target;
        const delta = target - current;
        if(Math.abs(delta) <= maxStep) return target;
        return current + Math.sign(delta) * maxStep;
      };
      if(dashing){
        this.moveDir.x = mv.x;
        this.moveDir.y = mv.y;
        const dashSpeed = Number.isFinite(dash.dashSpeed) && dash.dashSpeed>0 ? dash.dashSpeed : ((this.r || CONFIG.player.radius || 12) * 16) / Math.max(0.08, dash.dashDuration || 0.18);
        dash.dashSpeed = dashSpeed;
        this.vel.x = mv.x * dashSpeed;
        this.vel.y = mv.y * dashSpeed;
      } else {
        if(mv.x !== 0 || mv.y !== 0){
          this.moveDir.x = mv.x;
          this.moveDir.y = mv.y;
          const targetSpeed = this.speed;
          const targetX = mv.x * targetSpeed;
          const targetY = mv.y * targetSpeed;
          this.vel.x = approachAxis(this.vel.x, targetX, accelRate);
          this.vel.y = approachAxis(this.vel.y, targetY, accelRate);
        } else {
          const vmag = Math.hypot(this.vel.x, this.vel.y);
          if(vmag>1e-3){
            this.moveDir.x = this.vel.x / vmag;
            this.moveDir.y = this.vel.y / vmag;
          } else {
            this.moveDir.x = 0;
            this.moveDir.y = 0;
          }
          if(vmag>0){
            const basePlayerSpeed = CONFIG && CONFIG.player ? CONFIG.player.speed : 0;
            const decelRef = Math.max(this.speed, basePlayerSpeed || 0, vmag);
            const decelRate = decelTime > 0 ? (decelRef / decelTime) : Infinity;
            this.vel.x = approachAxis(this.vel.x, 0, decelRate);
            this.vel.y = approachAxis(this.vel.y, 0, decelRate);
          }
        }
        const curSpeed = Math.hypot(this.vel.x, this.vel.y);
        if(curSpeed > maxSpeed){
          const scale = maxSpeed / curSpeed;
          this.vel.x *= scale;
          this.vel.y *= scale;
        }
      }
      this.x += this.vel.x * moveDt;
      this.y += this.vel.y * moveDt;
      if(this.knockTimer>0 && !dashing){
        this.x += this.knockVel.x * moveDt;
        this.y += this.knockVel.y * moveDt;
        this.knockVel.x *= 0.86;
        this.knockVel.y *= 0.86;
        this.knockTimer = Math.max(0, this.knockTimer - moveDt);
      } else if(dashing){
        this.knockTimer = 0;
        this.knockVel.x = 0;
        this.knockVel.y = 0;
      }
      // 边界
      const minX = 30;
      const maxX = CONFIG.roomW - 30;
      const minY = 30;
      const maxY = CONFIG.roomH - 30;
      if(this.x < minX){ if(this.vel.x < 0) this.vel.x = 0; this.x = minX; }
      if(this.x > maxX){ if(this.vel.x > 0) this.vel.x = 0; this.x = maxX; }
      if(this.y < minY){ if(this.vel.y < 0) this.vel.y = 0; this.y = minY; }
      if(this.y > maxY){ if(this.vel.y > 0) this.vel.y = 0; this.y = maxY; }
      this.ifr = Math.max(0, this.ifr - dt);
      this.fireCd = Math.max(0, this.fireCd - dt*1000);

      // 射击（方向键）
      let shotX=0, shotY=0;
      if(keys.has('ArrowUp')) shotY -= 1;
      if(keys.has('ArrowDown')) shotY += 1;
      if(keys.has('ArrowLeft')) shotX -= 1;
      if(keys.has('ArrowRight')) shotX += 1;
      if(entryLocked){ shotX = 0; shotY = 0; }
      this.updateShotInputState(shotX, shotY);
      if(entryLocked && this.shotInput){
        this.shotInput.pressed = false;
        this.shotInput.justPressed = false;
        this.shotInput.justReleased = false;
      }
      const preResolveX = this.x;
      const preResolveY = this.y;
      resolveEntityObstacles(this);
      if(dashing){
        if(dash && dash.trail && typeof dash.trail.addPoint === 'function'){
          dash.trail.addPoint(this.x, this.y);
        }
        dash.dashTimer = Math.max(0, dash.dashTimer - moveDt);
        const forwardMove = (this.x - startX) * mv.x + (this.y - startY) * mv.y;
        const expectedStep = Math.abs(dash.dashSpeed || 0) * moveDt * 0.35;
        const blocked = forwardMove <= expectedStep && dash.dashTimer > 0;
        if(blocked || dash.dashTimer <= 0){
          this.endImpactDash({blocked});
          if(!dash.active){
            dashing = false;
          }
        }
      } else if(this.x!==preResolveX || this.y!==preResolveY){
        const corrX = this.x - preResolveX;
        const corrY = this.y - preResolveY;
        const corrLen = Math.hypot(corrX, corrY);
        if(corrLen>1e-6){
          const nx = corrX / corrLen;
          const ny = corrY / corrLen;
          const dot = this.vel.x * nx + this.vel.y * ny;
          if(dot<0){
            this.vel.x -= dot * nx;
            this.vel.y -= dot * ny;
          }
        }
      }
      const dx = this.x - startX;
      const dy = this.y - startY;
      const sampleDt = moveDt>0 ? moveDt : dt;
      const lvx = sampleDt>0 ? dx/sampleDt : 0;
      const lvy = sampleDt>0 ? dy/sampleDt : 0;
      this.lastDisplacement.x = dx;
      this.lastDisplacement.y = dy;
      this.lastVelocity.x = lvx;
      this.lastVelocity.y = lvy;
      const shotState = this.getShotInput();
      const shotPressed = !entryLocked && !!(shotState && shotState.pressed);
      if(!entryLocked){
        if(this.attackMode === 'bomb-progenitor'){
          this.handleBombProgenitorAttack(dt, shotState);
        } else if(this.attackMode === 'bomb-elder'){
          this.handleBombElderAttack(dt, shotState, lvx, lvy, maxSpeed);
        } else if(this.attackMode === 'brimstone'){
          this.handleBrimstoneAttack(dt, shotState?.x || shotX, shotState?.y || shotY, lvx, lvy, maxSpeed);
        } else if(this.hasHotChocolate && this.hasHotChocolate()){
          this.handleHotChocolateAttack(dt, shotState?.x || shotX, shotState?.y || shotY, lvx, lvy, maxSpeed);
        } else {
          if(shotPressed && this.fireCd<=0){
            const dirX = shotState.dirX;
            const dirY = shotState.dirY;
            const len = Math.hypot(dirX, dirY) || 1;
            const nDirX = dirX/len;
            const nDirY = dirY/len;
            this.fireCd = this.fireInterval;
            this.fireTearProjectile(nDirX, nDirY, lvx, lvy, maxSpeed);
          }
        }
      } else {
        if(this.attackMode === 'brimstone'){
          this.brimstoneCharging = false;
          this.brimstoneCharge = 0;
          this.brimstoneCharged = false;
        }
        if(this.hasHotChocolate && this.hasHotChocolate()){
          const state = this.ensureHotChocolateState();
          state.charging = false;
          state.chargeTime = 0;
        }
      }
      this.recordFollowerTrailPoint();
      this.updateFollowers(dt);
      this.recalculateDamage();
    }
    fireTearProjectile(dirX, dirY, lvx, lvy, maxSpeed, options={}){
      if(!Number.isFinite(dirX) || !Number.isFinite(dirY)) return;
      let dlen = Math.hypot(dirX, dirY);
      if(!(dlen>1e-5)) return;
      let dirNormX = dirX / dlen;
      let dirNormY = dirY / dlen;
      const originX = Number.isFinite(options.originX)
        ? options.originX
        : (options.origin && Number.isFinite(options.origin.x) ? options.origin.x : this.x);
      const originY = Number.isFinite(options.originY)
        ? options.originY
        : (options.origin && Number.isFinite(options.origin.y) ? options.origin.y : this.y);
      const combatCfg = CONFIG.combat || {};
      const carry = combatCfg.shotCarry ?? combatCfg.shotInertia ?? 0;
      const forwardScale = combatCfg.shotForwardBoost ?? 0;
      const reverseScale = combatCfg.shotReverseBoost ?? 0;
      const lateralScale = combatCfg.shotLateralInfluence ?? 0;
      const forwardSpeed = lvx * dirNormX + lvy * dirNormY;
      if(lateralScale>0){
        const totalSpeed = Math.hypot(lvx, lvy);
        const speedRef = maxSpeed>0 ? maxSpeed : Math.max(totalSpeed, 1);
        if(speedRef>1e-5 && totalSpeed>1e-4){
          const lateral = lvx * (-dirNormY) + lvy * dirNormX;
          if(Math.abs(lateral)>1e-4){
            const lateralNormRaw = clamp(Math.abs(lateral) / speedRef, 0, 1);
            const curvePower = clamp(combatCfg.shotLateralCurve ?? 1, 0.1, 6);
            const curved = Math.pow(lateralNormRaw, curvePower);
            const smooth = curved * curved * (3 - 2 * curved);
            const speedNorm = clamp(totalSpeed / speedRef, 0, 1);
            const blend = smooth * (0.6 + 0.4 * Math.pow(speedNorm, 1.35));
            const angleBaseDeg = combatCfg.shotLateralAngle ?? 28;
            const angle = Math.sign(lateral) * (angleBaseDeg * Math.PI / 180) * lateralScale * blend;
            if(Math.abs(angle)>1e-4){
              const cos = Math.cos(angle);
              const sin = Math.sin(angle);
              const ndx = dirNormX * cos - dirNormY * sin;
              const ndy = dirNormX * sin + dirNormY * cos;
              dirNormX = ndx;
              dirNormY = ndy;
              dlen = Math.hypot(dirNormX, dirNormY) || 1;
              dirNormX /= dlen;
              dirNormY /= dlen;
            }
          }
        }
      }
      let baseSpeed = Number.isFinite(options.baseSpeed) ? options.baseSpeed : this.tearSpeed;
      if(forwardScale!==0 && forwardSpeed>1e-4){
        const boost = forwardSpeed * forwardScale;
        baseSpeed = Math.max(40, baseSpeed + boost);
      } else if(forwardSpeed < -1e-4 && reverseScale>0){
        const oppose = -forwardSpeed;
        const speedRef = maxSpeed>0 ? maxSpeed : Math.max(Math.hypot(lvx, lvy), 1);
        const norm = speedRef>0 ? clamp(oppose / speedRef, 0, 1.4) : 0;
        const eased = norm * (0.55 + 0.45 * norm);
        const boost = oppose * reverseScale * (0.5 + 0.5 * eased);
        baseSpeed = Math.max(40, baseSpeed + boost);
      }
      let vx = dirNormX * baseSpeed;
      let vy = dirNormY * baseSpeed;
      if(carry!==0){
        vx += lvx * carry;
        vy += lvy * carry;
      }
      let damageScale = Number.isFinite(options.damageScale) ? options.damageScale : 1;
      damageScale = Math.max(0.01, damageScale);
      const life = Number.isFinite(options.life) ? options.life : this.tearLife;
      const baseDamageValue = Number.isFinite(options.damage) ? options.damage : (this.damage * damageScale);
      const bulletOptions = {
        pierce: this.canPierceObstacles,
        pierceEnemies: this.canPierceEnemies,
        homing: this.homingTears,
        homingStrength: this.homingStrength
      };
      if(typeof options.color === 'string') bulletOptions.color = options.color;
      if(typeof options.trailColor === 'string') bulletOptions.trailColor = options.trailColor;
      if(typeof options.pierce === 'boolean') bulletOptions.pierce = options.pierce;
      if(typeof options.pierceEnemies === 'boolean') bulletOptions.pierceEnemies = options.pierceEnemies;
      if(typeof options.homing === 'boolean') bulletOptions.homing = options.homing;
      if(Number.isFinite(options.homingStrength)) bulletOptions.homingStrength = Math.max(0, options.homingStrength);
      const shots=[];
      const baseSpeedMag = Math.hypot(vx, vy) || 0;
      const tripleBonus = this.getSetBonus ? this.getSetBonus('baby-super') : (this.setBonuses?.['baby-super'] || null);
      const tripleActive = !!(tripleBonus && (tripleBonus.active ?? true));
      const damageMultiplier = tripleActive ? Math.max(0.05, tripleBonus.damageScale ?? 0.95) : 1;
      const tripleSpread = tripleActive ? clamp(tripleBonus.spread ?? 0.2, 0, Math.PI/2) : 0;
      const baseAngle = Math.atan2(vy, vx);
      const multiOffsets = typeof this.getEyePatternOffsets === 'function' ? this.getEyePatternOffsets() : [0];
      const tripleOffsets = tripleActive ? [-tripleSpread, 0, tripleSpread] : [0];
      const offsets = [];
      for(const baseOffset of multiOffsets){
        if(tripleActive){
          for(const extra of tripleOffsets){
            offsets.push(baseOffset + extra);
          }
        } else {
          offsets.push(baseOffset);
        }
      }
      const hasHolyAura = typeof this.hasHolyHeartAura === 'function' ? this.hasHolyHeartAura() : false;
      const holyAuraConfig = hasHolyAura && typeof this.getHolyHeartAuraConfig === 'function'
        ? this.getHolyHeartAuraConfig()
        : null;
      for(const offset of offsets){
        let outVx = vx;
        let outVy = vy;
        if(baseSpeedMag>0 && Math.abs(offset)>1e-6){
          const angle = baseAngle + offset;
          outVx = Math.cos(angle) * baseSpeedMag;
          outVy = Math.sin(angle) * baseSpeedMag;
        }
        const shotDamage = Math.max(0.01, baseDamageValue * damageMultiplier);
        const shotOptions = {...bulletOptions};
        if(holyAuraConfig){
          shotOptions.holyAura = {...holyAuraConfig};
        }
        const speedLen = Math.hypot(outVx, outVy) || 1;
        shots.push({
          originX,
          originY,
          vx: outVx,
          vy: outVy,
          dirX: outVx / speedLen,
          dirY: outVy / speedLen,
          life,
          damage: shotDamage,
          options: shotOptions,
        });
      }
      let firedCount = 0;
      if(this.hasCompressedPeach && this.hasCompressedPeach()){
        firedCount = this.spawnCompressedPeachProjectiles?.(shots) || 0;
      } else {
        for(const shot of shots){
          runtime.bullets.push(new Bullet(shot.originX, shot.originY, shot.vx, shot.vy, shot.life, shot.damage, shot.options));
          this.dispatchFollowerShot?.('tear', shot);
        }
        firedCount = shots.length;
      }
      if(firedCount>0){
        const volume = Math.min(0.75, 0.42 + firedCount*0.04);
        audio.play('playerShoot', {volume});
      }
    }
    hasCompressedPeach(){
      return Number.isFinite(this.compressedPeachStacks) && this.compressedPeachStacks>0;
    }
    ensureCompressedPeachState(){
      if(!this.compressedPeachState){
        this.compressedPeachState = {
          color:'#f9a8d4',
          trailColor:'#f472b6',
          seedDamageScale:0.82,
          fragmentDamageScale:0.68,
          fragmentSpeedScale:0.88,
          spreadAngles:[-0.28, 0, 0.28],
          orbitSpeed:Math.PI*0.8,
          orbitOscSpeed:Math.PI*1.2,
          orbitAmplitude:16,
        };
      }
      const stacks = Math.max(1, Number(this.compressedPeachStacks) || 0);
      const bodyRadius = this.r || CONFIG.player.radius || 18;
      const unit = bodyRadius * 2;
      this.compressedPeachState.stack = stacks;
      this.compressedPeachState.travelDistance = unit * (4 + (stacks-1)*0.25);
      this.compressedPeachState.fragmentTravelDistance = unit * (2 + (stacks-1)*0.2);
      this.compressedPeachState.orbitRadius = unit * (0.95 + (stacks-1)*0.15);
      this.compressedPeachState.orbitAmplitude = 12 + (stacks-1)*3.2;
      this.compressedPeachState.orbitSpeed = Math.PI * (0.75 + (stacks-1)*0.08);
      this.compressedPeachState.orbitOscSpeed = Math.PI * (1.1 + (stacks-1)*0.12);
      return this.compressedPeachState;
    }
    enableCompressedPeach(){
      this.compressedPeachStacks = (Number(this.compressedPeachStacks) || 0) + 1;
      return this.ensureCompressedPeachState();
    }
    spawnCompressedPeachProjectiles(shots){
      if(!Array.isArray(shots) || !shots.length) return 0;
      const state = this.ensureCompressedPeachState();
      const resultShots = [];
      for(const shot of shots){
        if(!shot) continue;
        const speed = Math.max(40, Math.hypot(shot.vx, shot.vy) || 0);
        const totalLife = Math.max(0.2, Number(shot.life) || this.tearLife || 0.8);
        const travelDistance = Math.max(40, Number(state.travelDistance) || 40);
        const seedDamage = Math.max(0.05, Number(shot.damage) * state.seedDamageScale);
        const fragmentDamage = Math.max(0.05, Number(shot.damage) * state.fragmentDamageScale);
        const seedLife = totalLife;
        const seedOptions = {
          color: shot.options?.color || state.color,
          trailColor: shot.options?.trailColor || state.trailColor,
          holyAura: shot.options?.holyAura || null,
        };
        const fragmentSpeed = Math.max(40, speed * state.fragmentSpeedScale);
        const fragmentTravel = Math.max(30, Number(state.fragmentTravelDistance) || 30);
        const travelTime = travelDistance / speed;
        const remainingLife = Math.max(0.2, seedLife - travelTime);
        const fragmentLife = Math.max(fragmentTravel / fragmentSpeed + 0.15, remainingLife);
        const fragmentConfig = {
          player: this,
          fragmentSpeed,
          damage: fragmentDamage,
          travelBeforeOrbit: fragmentTravel,
          orbitRadius: Math.max(24, state.orbitRadius || 24),
          orbitAmplitude: Math.max(6, state.orbitAmplitude || 6),
          orbitSpeed: Math.max(0.2, state.orbitSpeed || Math.PI*0.75),
          oscillationSpeed: Math.max(0.2, state.orbitOscSpeed || Math.PI),
          spreadAngles: Array.isArray(state.spreadAngles) && state.spreadAngles.length ? state.spreadAngles : [0],
          life: fragmentLife,
          color: seedOptions.color,
          trailColor: seedOptions.trailColor,
          holyAura: seedOptions.holyAura,
        };
        const seed = new CompressedPeachSeed({
          player: this,
          x: shot.originX,
          y: shot.originY,
          vx: shot.vx,
          vy: shot.vy,
          damage: seedDamage,
          life: seedLife,
          travelDistance,
          fragmentConfig,
          color: seedOptions.color,
          trailColor: seedOptions.trailColor,
          holyAura: seedOptions.holyAura,
        });
        runtime.bullets.push(seed);
        this.dispatchFollowerShot?.('tear', shot);
        resultShots.push(seed);
      }
      return resultShots.length;
    }
    ensureBombElderState(){
      if(!this.bombElder || typeof this.bombElder !== 'object'){
        const defaultInterval = Number.isFinite(CONFIG.player?.fireCd) ? CONFIG.player.fireCd : 360;
        const referenceRate = defaultInterval>0 ? 1000/defaultInterval : 2.5;
        this.bombElder = {
          enabled:false,
          cooldown:0,
          baseInterval:2,
          minInterval:0.55,
          referenceRate,
          launchSpeed:320,
          speedCarry:0.35,
          fuse:1.35,
          damageScale:3.2,
          radiusScale:0.85,
          knockPower:null,
          shakeStrength:6,
          baseRadius:null,
        };
      }
      return this.bombElder;
    }
    enableBombElderMode(){
      const state = this.ensureBombElderState();
      state.enabled = true;
      state.cooldown = 0;
      this.attackMode = 'bomb-elder';
      this.bombProgenitor = null;
    }
    getBombElderInterval(){
      const state = this.ensureBombElderState();
      const baseInterval = Math.max(0.4, Number(state.baseInterval) || 2);
      const defaultInterval = Number.isFinite(CONFIG.player?.fireCd) ? CONFIG.player.fireCd : 360;
      const defaultRate = defaultInterval>0 ? 1000/defaultInterval : 2.5;
      const referenceRate = Math.max(0.2, Number(state.referenceRate) || defaultRate);
      const currentRate = this.fireInterval>0 ? Math.max(0.05, 1000/this.fireInterval) : referenceRate;
      const ratio = Math.max(0.35, currentRate / referenceRate);
      const minInterval = Math.max(0.35, Number(state.minInterval) || 0.55);
      return Math.max(minInterval, baseInterval / ratio);
    }
    handleBombElderAttack(dt, shotState, lvx, lvy, maxSpeed){
      const state = this.ensureBombElderState();
      state.enabled = true;
      state.cooldown = Math.max(0, (state.cooldown || 0) - dt);
      if(!shotState || !shotState.pressed) return;
      if(state.cooldown>0) return;
      const dirX = Number(shotState.dirX);
      const dirY = Number(shotState.dirY);
      const len = Math.hypot(dirX, dirY);
      if(!(len>1e-4)) return;
      this.fireBombElderShot(state, dirX/len, dirY/len, lvx, lvy);
      state.cooldown = this.getBombElderInterval();
    }
    fireBombElderShot(state, dirX, dirY, lvx, lvy){
      const room = dungeon?.current;
      if(!room) return;
      const baseRadiusValue = Number.isFinite(state.baseRadius)
        ? state.baseRadius
        : (CONFIG.bomb.radius * (Number(state.radiusScale) || 0.85));
      const radiusMultiplier = Math.max(0.1, this.bombRadiusMultiplier || 1);
      const playerDamageMultiplier = Math.max(0.05, this.bombDamageMultiplier || 1);
      const damageScale = Math.max(0.25, Number(state.damageScale) || 3.2);
      const launchSpeed = Math.max(120, Number(state.launchSpeed) || 320);
      const carryFactor = clamp(Number(state.speedCarry) || 0.35, 0, 1);
      const fuse = Math.max(0.4, Number(state.fuse) || 1.35);
      const knockPower = Number.isFinite(state.knockPower) ? state.knockPower : null;
      const shakeStrength = Math.max(this.bombShakeStrength || 0, Number(state.shakeStrength) || 6);
      const offsets = typeof this.getEyePatternOffsets === 'function' ? this.getEyePatternOffsets() : [0];
      const spawnOffset = this.r + 10;
      const baseAngle = Math.atan2(dirY, dirX);
      const firedShots = [];
      for(const offset of offsets){
        const angle = baseAngle + offset;
        const nx = Math.cos(angle);
        const ny = Math.sin(angle);
        const spawnX = this.x + nx * spawnOffset;
        const spawnY = this.y + ny * spawnOffset;
        const bombDamage = Math.max(0.5, this.damage * damageScale * playerDamageMultiplier);
        const bomb = new Bomb(spawnX, spawnY, {
          owner:'player',
          fuse,
          baseRadius: baseRadiusValue,
          radiusMultiplier,
          damageMultiplier: 1,
          customDamage: bombDamage,
          customKnock: knockPower,
          shakeStrength,
          spawnGrace: 0.08,
        });
        bomb.vx = nx * launchSpeed + lvx * carryFactor;
        bomb.vy = ny * launchSpeed + lvy * carryFactor;
        room.bombs.push(bomb);
        firedShots.push({dirX:nx, dirY:ny, damage:bombDamage});
      }
      if(firedShots.length){
        this.dispatchFollowerShot?.('bomb', firedShots);
      }
    }
    ensureBombProgenitorState(){
      if(!this.bombProgenitor || typeof this.bombProgenitor !== 'object'){
        this.bombProgenitor = {
          enabled:false,
          reticle:null,
          reticleEffect:null,
          chargeDuration:2,
          reticleSpeed:240,
          reticleRadius:28,
          chainCount:0,
          chainTimer:0,
          chainPosition:null,
          chainSpacing:0.3,
          maxChain:16,
          damageScale:20,
          baseRadius: CONFIG.bomb.radius * 1.25,
          knockPower: CONFIG.bomb.knock * 1.35,
          shakeStrength:14,
        };
      }
      return this.bombProgenitor;
    }
    enableBombProgenitorMode(){
      const state = this.ensureBombProgenitorState();
      state.enabled = true;
      state.chainCount = 0;
      state.chainTimer = 0;
      state.chainPosition = null;
      if(state.reticleEffect){ state.reticleEffect.life = Math.min(state.reticleEffect.life, 0.02); }
      state.reticleEffect = null;
      state.reticle = null;
      this.attackMode = 'bomb-progenitor';
      this.bombElder = null;
    }
    getBombProgenitorChainCount(){
      const state = this.ensureBombProgenitorState();
      const stacks = this.getItemStack ? Math.max(1, this.getItemStack('bomb-progenitor') || 1) : 1;
      const pattern = typeof this.getEyePatternOffsets === 'function' ? Math.max(1, this.getEyePatternOffsets().length) : 1;
      const maxChain = Math.max(1, Number(state.maxChain) || 16);
      return Math.min(maxChain, Math.max(1, Math.floor(stacks * pattern)));
    }
    getBombProgenitorCycleTime(){
      const state = this.ensureBombProgenitorState();
      const count = this.getBombProgenitorChainCount();
      const charge = Math.max(0.2, Number(state.chargeDuration) || 2);
      const spacing = Math.max(0, Number(state.chainSpacing) || 0.3);
      return charge + Math.max(0, count - 1) * spacing;
    }
    handleBombProgenitorAttack(dt, shotState){
      const state = this.ensureBombProgenitorState();
      state.enabled = true;
      if(state.reticle){
        this.updateBombProgenitorReticle(state, dt, shotState);
        return;
      }
      if(state.chainCount>0){
        state.chainTimer = Math.max(0, (state.chainTimer || 0) - dt);
        if(state.chainTimer<=0){
          this.fireBombProgenitorMissile(state);
        }
        return;
      }
      if(shotState && shotState.justPressed){
        this.startBombProgenitorReticle(state, shotState);
      }
    }
    startBombProgenitorReticle(state, shotState){
      const dirLen = shotState ? Math.hypot(shotState.dirX, shotState.dirY) : 0;
      const offset = dirLen>1e-4 ? {x: (shotState.dirX/dirLen) * (this.r + 14), y: (shotState.dirY/dirLen) * (this.r + 14)} : {x:0,y:0};
      const reticle = {
        x: clamp(this.x + offset.x, 36, CONFIG.roomW - 36),
        y: clamp(this.y + offset.y, 42, CONFIG.roomH - 42),
        timer: 0,
      };
      state.reticle = reticle;
      state.chainCount = 0;
      state.chainTimer = 0;
      state.chainPosition = null;
      if(state.reticleEffect){
        state.reticleEffect.life = Math.min(state.reticleEffect.life, 0.02);
        state.reticleEffect = null;
      }
      if(runtime?.effects){
        const effect = {
          type:'bomb-progenitor-reticle',
          life:9999,
          ttl:9999,
          state,
          x: reticle.x,
          y: reticle.y,
          radius: state.reticleRadius || 28,
          progress:0,
          phase:0,
          update(self, dt){
            if(!state.reticle){
              self.life = Math.min(self.life, 0.02);
              return;
            }
            const duration = Math.max(0.2, Number(state.chargeDuration) || 2);
            self.x = state.reticle.x;
            self.y = state.reticle.y;
            self.radius = state.reticleRadius || 28;
            self.progress = clamp(state.reticle.timer / duration, 0, 1);
            self.phase = (self.phase || 0) + dt * 4.2;
            self.life = 9999;
          }
        };
        runtime.effects.push(effect);
        state.reticleEffect = effect;
      }
    }
    updateBombProgenitorReticle(state, dt, shotState){
      const reticle = state.reticle;
      if(!reticle) return;
      reticle.timer += dt;
      const speed = Math.max(80, Number(state.reticleSpeed) || 240);
      const rawX = shotState ? shotState.x : 0;
      const rawY = shotState ? shotState.y : 0;
      if(rawX || rawY){
        const len = Math.hypot(rawX, rawY) || 1;
        reticle.x += (rawX/len) * speed * dt;
        reticle.y += (rawY/len) * speed * dt;
      }
      const margin = Math.max(32, (state.reticleRadius || 28) + 8);
      reticle.x = clamp(reticle.x, margin, CONFIG.roomW - margin);
      reticle.y = clamp(reticle.y, margin, CONFIG.roomH - margin);
      const duration = Math.max(0.2, Number(state.chargeDuration) || 2);
      if(reticle.timer >= duration){
        this.triggerBombProgenitorStrike(state);
      }
    }
    triggerBombProgenitorStrike(state){
      const reticle = state.reticle;
      if(!reticle) return;
      const position = {x: reticle.x, y: reticle.y};
      state.reticle = null;
      if(state.reticleEffect){
        state.reticleEffect.life = Math.min(state.reticleEffect.life, 0.12);
        state.reticleEffect = null;
      }
      const count = this.getBombProgenitorChainCount();
      state.chainCount = count;
      state.chainTimer = 0;
      state.chainPosition = position;
      if(runtime?.effects){
        spawnCircularEffect(position.x, position.y, (state.reticleRadius || 28) * 1.05, {
          duration:0.4,
          innerColor:'#fff8',
          midColor:'#fdba74',
          outerColor:'#fb923c',
        });
      }
    }
    fireBombProgenitorMissile(state){
      if(!state.chainCount || !state.chainPosition){
        state.chainCount = 0;
        state.chainPosition = null;
        state.chainTimer = 0;
        return;
      }
      const room = dungeon?.current;
      if(!room){
        state.chainCount = 0;
        state.chainPosition = null;
        return;
      }
      const pos = state.chainPosition;
      const baseRadius = Number.isFinite(state.baseRadius)
        ? state.baseRadius
        : (CONFIG.bomb.radius * 1.25);
      const radiusMultiplier = Math.max(0.1, this.bombRadiusMultiplier || 1);
      const radius = baseRadius * radiusMultiplier;
      const damageScale = Math.max(0.5, Number(state.damageScale) || 20);
      const playerDamageMultiplier = Math.max(0.05, this.bombDamageMultiplier || 1);
      const damage = Math.max(0.5, this.damage * damageScale * playerDamageMultiplier);
      const knockPower = Number.isFinite(state.knockPower) ? state.knockPower : CONFIG.bomb.knock * 1.35;
      const shake = Math.max(this.bombShakeStrength || 0, Number(state.shakeStrength) || 14);
      if(runtime?.effects){
        runtime.effects.push({
          type:'shockwave',
          x: pos.x,
          y: pos.y,
          maxRadius: radius * 1.25,
          lineWidth: 7,
          life: 0.5,
          ttl: 0.5,
          color: colorWithAlpha('#fb923c', 0.88),
        });
        spawnCircularEffect(pos.x, pos.y, radius * 0.9, {
          duration:0.35,
          innerColor:'#fff7',
          midColor:'#fdba74',
          outerColor:'#fb923c',
        });
      }
      addScreenShake(shake, 0.35);
      handleBombExplosion(room, {
        x: pos.x,
        y: pos.y,
        explosionRadius: radius,
        damageMultiplier: 1,
        customDamage: damage,
        customKnock: knockPower,
        shakeStrength: shake,
        owner: 'player',
      });
      state.chainCount = Math.max(0, state.chainCount - 1);
      if(state.chainCount>0){
        state.chainTimer = Math.max(0.12, Number(state.chainSpacing) || 0.3);
      } else {
        state.chainPosition = null;
        state.chainTimer = 0;
      }
    }
    getShotInput(){
      if(!this.shotInput || typeof this.shotInput !== 'object'){
        this.shotInput = {
          x: 0,
          y: 0,
          dirX: 0,
          dirY: -1,
          lastDirX: 0,
          lastDirY: -1,
          pressed: false,
          justPressed: false,
          justReleased: false,
        };
      }
      if(!Number.isFinite(this.shotInput.dirX) || !Number.isFinite(this.shotInput.dirY)){
        this.shotInput.dirX = 0;
        this.shotInput.dirY = -1;
      }
      if(!Number.isFinite(this.shotInput.lastDirX) || !Number.isFinite(this.shotInput.lastDirY)){
        this.shotInput.lastDirX = this.shotInput.dirX;
        this.shotInput.lastDirY = this.shotInput.dirY;
      }
      return this.shotInput;
    }
    updateShotInputState(rawX, rawY){
      const state = this.getShotInput();
      const prevPressed = !!state.pressed;
      const pressed = !!(rawX || rawY);
      state.justPressed = pressed && !prevPressed;
      state.justReleased = !pressed && prevPressed;
      state.x = rawX;
      state.y = rawY;
      if(pressed){
        const len = Math.hypot(rawX, rawY) || 1;
        const nx = rawX / len;
        const ny = rawY / len;
        state.dirX = nx;
        state.dirY = ny;
        state.lastDirX = nx;
        state.lastDirY = ny;
      } else {
        const lastX = Number.isFinite(state.lastDirX) ? state.lastDirX : 0;
        const lastY = Number.isFinite(state.lastDirY) ? state.lastDirY : -1;
        const len = Math.hypot(lastX, lastY) || 1;
        state.dirX = lastX / len;
        state.dirY = lastY / len;
      }
      state.pressed = pressed;
      return state;
    }
    getSetBonus(key){
      if(!key) return null;
      if(!this.setBonuses || typeof this.setBonuses !== 'object') return null;
      return this.setBonuses[key] || null;
    }
    activateSetBonus(key, options={}){
      if(!key) return;
      if(!this.setBonuses || typeof this.setBonuses !== 'object'){
        this.setBonuses = Object.create(null);
      }
      const existing = this.setBonuses[key] || {};
      const next = {...existing, ...options, active:true};
      if(key==='baby-super'){
        next.damageScale = Math.max(0.01, Number.isFinite(next.damageScale) ? next.damageScale : (existing.damageScale ?? 0.95));
        next.spread = Number.isFinite(next.spread) ? next.spread : (existing.spread ?? 0.2);
      }
      this.setBonuses[key] = next;
    }
    ensureFollowerList(){
      if(!Array.isArray(this.followers)){
        this.followers = [];
      }
      return this.followers;
    }
    dispatchFollowerShot(type, payload){
      const list = this.followers;
      if(!Array.isArray(list) || !list.length) return;
      const shots = Array.isArray(payload) ? payload : [payload];
      for(const follower of list){
        if(!follower || typeof follower.onPlayerShot !== 'function') continue;
        for(const shot of shots){
          follower.onPlayerShot(type, shot, this);
        }
      }
    }
    addFollower(config){
      const list = this.ensureFollowerList();
      const follower = createFollowerEntity(this, config);
      if(!follower) return null;
      follower.order = this.followerOrderCounter++;
      list.push(follower);
      this.rebuildFollowerOrder();
      return follower;
    }
    rebuildFollowerOrder(){
      const list = this.followers;
      if(!Array.isArray(list) || !list.length) return;
      list.sort((a,b)=>{
        const pa = Number.isFinite(a?.priority) ? a.priority : 10;
        const pb = Number.isFinite(b?.priority) ? b.priority : 10;
        if(pa!==pb) return pa-pb;
        const oa = Number.isFinite(a?.order) ? a.order : 0;
        const ob = Number.isFinite(b?.order) ? b.order : 0;
        return oa - ob;
      });
      const baseSpacing = this.getFollowerBaseSpacing();
      let totalOffset = 0;
      for(const follower of list){
        if(!follower) continue;
        const multiplier = Number.isFinite(follower.spacingMultiplier) ? follower.spacingMultiplier : 1;
        const spacing = Math.max(6, baseSpacing * multiplier);
        follower.baseSpacing = spacing;
        follower.leader = this;
        if(follower.anchorToPlayer){
          follower.trailOffset = spacing;
        } else {
          totalOffset += spacing;
          follower.trailOffset = totalOffset;
        }
      }
    }
    updateFollowers(dt){
      const list = this.followers;
      if(!Array.isArray(list) || !list.length) return;
      for(const follower of list){
        if(!follower || typeof follower.update !== 'function') continue;
        follower.update(dt, this);
      }
    }
    getFollowerBaseSpacing(){
      const body = this.r || CONFIG.player.radius || 12;
      return Math.max(8, body);
    }
    ensureFollowerTrail(){
      if(!Array.isArray(this.followerTrail)){
        this.followerTrail = [];
      }
      return this.followerTrail;
    }
    resetFollowerTrail(direction){
      const trail = this.ensureFollowerTrail();
      trail.length = 0;
      trail.push({x:this.x, y:this.y});
      const maxLen = Math.max(12, this.followerTrailMax || 0);
      if(direction && (direction.x || direction.y)){
        const len = Math.hypot(direction.x, direction.y) || 1;
        const nx = direction.x / len;
        const ny = direction.y / len;
        const spacing = this.getFollowerBaseSpacing();
        const steps = Math.min(maxLen-1, 18);
        for(let i=1;i<=steps;i++){
          trail.push({
            x: this.x - nx * spacing * i,
            y: this.y - ny * spacing * i,
          });
        }
      }
    }
    recordFollowerTrailPoint(){
      const trail = this.ensureFollowerTrail();
      const head = trail[0];
      if(head){
        const dx = this.x - head.x;
        const dy = this.y - head.y;
        const distSq = dx*dx + dy*dy;
        if(distSq > 0.25){
          trail.unshift({x:this.x, y:this.y});
        } else {
          head.x = this.x;
          head.y = this.y;
        }
      } else {
        trail.unshift({x:this.x, y:this.y});
      }
      const maxLen = Math.max(12, this.followerTrailMax || 0);
      if(trail.length > maxLen){
        trail.length = maxLen;
      }
    }
    getFollowerTrailPoint(distance){
      const trail = this.ensureFollowerTrail();
      if(!trail.length){
        return {x:this.x, y:this.y};
      }
      let remaining = Math.max(0, distance);
      for(let i=0;i<trail.length-1;i++){
        const from = trail[i];
        const to = trail[i+1];
        const seg = Math.hypot(from.x - to.x, from.y - to.y);
        if(seg >= remaining && seg > 1e-4){
          const t = remaining / seg;
          return {
            x: from.x + (to.x - from.x) * t,
            y: from.y + (to.y - from.y) * t,
          };
        }
        remaining -= seg;
      }
      const last = trail[trail.length-1];
      return last ? {x:last.x, y:last.y} : {x:this.x, y:this.y};
    }
    snapFollowersToPlayer(entryDir){
      const list = this.followers;
      if(!Array.isArray(list) || !list.length) return;
      this.rebuildFollowerOrder();
      const doorVec = (()=>{
        switch(entryDir){
          case 'up': return {x:0, y:1};
          case 'down': return {x:0, y:-1};
          case 'left': return {x:1, y:0};
          case 'right': return {x:-1, y:0};
          default: return null;
        }
      })();
      let baseVec = doorVec;
      if(!baseVec || (!baseVec.x && !baseVec.y)){
        const dir = this.moveDir || {x:0, y:0};
        const len = Math.hypot(dir.x, dir.y);
        if(len>1e-4){
          baseVec = {x: -dir.x/len, y: -dir.y/len};
        } else {
          baseVec = {x:0, y:1};
        }
      }
      this.resetFollowerTrail(baseVec);
      const spacingBase = this.getFollowerBaseSpacing();
      const trail = this.ensureFollowerTrail();
      const len = Math.hypot(baseVec.x, baseVec.y) || 1;
      const nx = baseVec.x / len;
      const ny = baseVec.y / len;
      let queueIndex = 0;
      for(const follower of list){
        if(!follower) continue;
        const spacing = follower.anchorToPlayer
          ? Math.max(6, follower.baseSpacing || spacingBase)
          : Math.max(spacingBase, follower.baseSpacing || spacingBase);
        let target;
        if(follower.anchorToPlayer && follower.behavior && typeof follower.behavior.getAnchorPosition === 'function'){
          target = follower.behavior.getAnchorPosition(follower, this, 0);
        }
        if(!follower.anchorToPlayer){
          queueIndex += 1;
        }
        if(!target){
          const distance = follower.anchorToPlayer
            ? spacing
            : Math.max(spacing, follower.trailOffset || (spacing * queueIndex));
          const neededSteps = Math.ceil(distance / Math.max(1, spacing)) + 2;
          if(trail.length < neededSteps){
            const maxLen = Math.max(12, this.followerTrailMax || 0);
            const stepSpacing = this.getFollowerBaseSpacing();
            for(let i=trail.length;i<=neededSteps && trail.length<maxLen;i++){
              trail.push({
                x: this.x - nx * stepSpacing * i,
                y: this.y - ny * stepSpacing * i,
              });
            }
          }
          target = this.getFollowerTrailPoint(distance);
        }
        const tx = clamp(target?.x ?? this.x, 40, CONFIG.roomW - 40);
        const ty = clamp(target?.y ?? this.y, 40, CONFIG.roomH - 40);
        follower.x = tx;
        follower.y = ty;
        if(follower.knockVel){ follower.knockVel.x = 0; follower.knockVel.y = 0; }
        if(follower.brimstoneBeam){
          endBeam(follower.brimstoneBeam);
          follower.brimstoneBeam = null;
        }
        if(follower.pendingBeam){ follower.pendingBeam = null; }
        if(follower.collectTarget){ follower.collectTarget = null; }
        if(follower.flashOn){ follower.flashOn = false; }
        if(follower.charging){ follower.charging = false; }
        if(follower.chargeProgress){ follower.chargeProgress = 0; }
        if(follower.behavior && typeof follower.behavior.onRoomEntered === 'function'){
          follower.behavior.onRoomEntered(follower, this, entryDir);
        }
      }
    }
    ensureHotChocolateState(){
      if(!this.hotChocolate){
        this.hotChocolate = {
          enabled: false,
          charging: false,
          chargeTime: 0,
          dir: {x:0, y:-1},
          chargeSpeedBonus: 1.5,
          damageBonus: 1.5,
          stacks: 0,
        };
      }
      if(!this.hotChocolate.dir){
        this.hotChocolate.dir = {x:0, y:-1};
      }
      return this.hotChocolate;
    }
    enableHotChocolate(){
      const state = this.ensureHotChocolateState();
      state.enabled = true;
      if(!Number.isFinite(state.stacks) || state.stacks<=0){
        state.stacks = Math.max(1, this.getItemStack ? this.getItemStack('hot-chocolate') : 1);
      }
      this.updateHotChocolateStackBonuses(state.stacks);
      this.updateBrimstoneChargeMetrics();
    }
    updateHotChocolateStackBonuses(countOverride){
      const state = this.ensureHotChocolateState();
      const stacks = Math.max(1, Number.isFinite(countOverride) ? Math.floor(countOverride) : (this.getItemStack ? this.getItemStack('hot-chocolate') : 1));
      state.stacks = stacks;
      const extra = Math.max(0, stacks - 1);
      const baseCharge = 1.5;
      const baseDamage = 1.5;
      state.chargeSpeedBonus = baseCharge + extra * 0.18;
      state.damageBonus = baseDamage + extra * 0.12;
      this.updateBrimstoneChargeMetrics();
    }
    hasHotChocolate(){
      return !!(this.hotChocolate && this.hotChocolate.enabled);
    }
    getHotChocolateBaselineSeconds(){
      const interval = Number.isFinite(this.fireInterval) && this.fireInterval>0 ? this.fireInterval : (CONFIG.player.fireCd || 360);
      return Math.max(1/240, interval / 1000);
    }
    handleHotChocolateAttack(dt, shotX, shotY, lvx, lvy, maxSpeed){
      const state = this.ensureHotChocolateState();
      const shotPressed = !!(shotX || shotY);
      if(shotPressed){
        const len = Math.hypot(shotX, shotY) || 1;
        const dirX = shotX / len;
        const dirY = shotY / len;
        const prevDir = state.dir || {x:0,y:-1};
        const changed = state.charging && (Math.abs(dirX - prevDir.x) > 1e-4 || Math.abs(dirY - prevDir.y) > 1e-4);
        if(changed && state.chargeTime>0){
          this.fireHotChocolateShot(state, lvx, lvy, maxSpeed);
        }
        state.dir.x = dirX;
        state.dir.y = dirY;
        state.charging = true;
        const bonus = Number.isFinite(state.chargeSpeedBonus) ? Math.max(0.05, state.chargeSpeedBonus) : 1;
        state.chargeTime += dt * bonus;
      } else if(state.charging && state.chargeTime>0){
        this.fireHotChocolateShot(state, lvx, lvy, maxSpeed);
      } else if(!shotPressed){
        state.charging = false;
        state.chargeTime = 0;
      }
    }
    fireHotChocolateShot(state, lvx, lvy, maxSpeed){
      if(!state || !state.dir) return;
      const dirX = state.dir.x;
      const dirY = state.dir.y;
      const len = Math.hypot(dirX, dirY);
      if(!(len>1e-5)){
        state.chargeTime = 0;
        state.charging = false;
        return;
      }
      const chargeSeconds = Math.max(0, state.chargeTime);
      const baseline = this.getHotChocolateBaselineSeconds();
      const stacks = Math.max(1, state.stacks || (this.getItemStack ? this.getItemStack('hot-chocolate') : 1) || 1);
      const damageBonus = Number.isFinite(state.damageBonus) ? Math.max(0.05, state.damageBonus) : 1;
      const rawRatio = baseline>0 ? state.chargeTime / baseline : state.chargeTime;
      const ratio = Math.max(0.05, rawRatio);
      const damage = Math.max(0.05, this.damage * ratio * damageBonus);
      const pierceObstacles = this.canPierceObstacles || chargeSeconds >= 5;
      const pierceEnemies = this.canPierceEnemies || chargeSeconds >= 8;
      const enableHoming = chargeSeconds >= 3;
      let color = '#fcd34d';
      let trailColor = '#fde68a';
      if(chargeSeconds >= 8){
        color = '#fb923c';
        trailColor = '#fde68a';
      } else if(chargeSeconds >= 5){
        color = '#f97316';
        trailColor = '#facc15';
      } else if(chargeSeconds >= 3){
        color = '#fbbf24';
        trailColor = '#fee2b3';
      }
      if(stacks>=3){
        color = shadeColor(color, -0.08);
        trailColor = shadeColor(trailColor, -0.05);
      } else if(stacks>=2){
        color = shadeColor(color, 0.08);
      }
      const speedMultiplier = Math.max(1, damageBonus);
      const homingStrength = enableHoming ? Math.max(this.homingStrength || 6, 14) : this.homingStrength;
      this.fireTearProjectile(dirX, dirY, lvx, lvy, maxSpeed, {
        damage,
        color,
        trailColor,
        baseSpeed: this.tearSpeed * speedMultiplier,
        pierce: pierceObstacles,
        pierceEnemies,
        homing: enableHoming || this.homingTears,
        homingStrength,
      });
      audio.play('playerShoot', {volume: 0.55});
      state.chargeTime = 0;
      state.charging = false;
      this.fireCd = 0;
    }
    ensureEyePatternState(){
      if(!this.eyePattern || typeof this.eyePattern !== 'object'){
        this.eyePattern = {
          entries: new Map(),
          totalExtraShots: 0,
          baseStep: 0.18,
          step: 0.18,
        };
      } else {
        if(!(this.eyePattern.entries instanceof Map)){
          this.eyePattern.entries = new Map();
        }
        if(!Number.isFinite(this.eyePattern.baseStep)){
          this.eyePattern.baseStep = 0.18;
        }
        if(!Number.isFinite(this.eyePattern.step)){
          this.eyePattern.step = this.eyePattern.baseStep;
        }
      }
      return this.eyePattern;
    }
    recalculateEyePattern(){
      const state = this.ensureEyePatternState();
      let extra = 0;
      let step = 0;
      for(const entry of state.entries.values()){
        extra += Math.max(0, entry?.totalExtraShots || 0);
        step = Math.max(step, Math.max(0, entry?.step || 0));
      }
      state.totalExtraShots = Math.max(0, extra);
      const baseStep = Number.isFinite(state.baseStep) ? Math.max(0.05, state.baseStep) : 0.18;
      state.step = Math.max(baseStep, step);
      return state;
    }
    registerEyePattern(slug, config={}){
      if(!slug) return this.ensureEyePatternState();
      const state = this.ensureEyePatternState();
      const entries = state.entries;
      let entry = entries.get(slug);
      if(!entry){
        entry = {count:0, totalExtraShots:0, step:0, penaltyApplied:false};
        entries.set(slug, entry);
      }
      entry.count += 1;
      const extraShots = Math.max(0, Math.floor(Number(config?.extraShots) || 0));
      if(extraShots>0){
        entry.totalExtraShots = (entry.totalExtraShots || 0) + extraShots;
      }
      if(Number.isFinite(config?.step)){
        entry.step = Math.max(entry.step || 0, config.step);
      }
      const penalty = config?.penalty;
      if(penalty && !entry.penaltyApplied){
        entry.penaltyApplied = true;
        if(Number.isFinite(penalty.damage) && penalty.damage !== 1){
          this.damageMultiplier *= Math.max(0.01, penalty.damage);
        }
        if(Number.isFinite(penalty.fireInterval) && penalty.fireInterval !== 1){
          const scale = Math.max(0.01, penalty.fireInterval);
          this.fireInterval = Math.max(12, this.fireInterval * scale);
          this.fireCd = Math.min(this.fireCd, this.fireInterval);
          this.updateBrimstoneChargeMetrics?.();
        } else if(Number.isFinite(penalty.fireRateMultiplier) && penalty.fireRateMultiplier !== 1){
          const rate = Math.max(0.05, penalty.fireRateMultiplier);
          const currentRate = this.fireInterval>0 ? 1000/this.fireInterval : 0;
          const nextRate = currentRate * rate;
          if(nextRate>0){
            this.fireInterval = Math.max(12, 1000/nextRate);
            this.fireCd = Math.min(this.fireCd, this.fireInterval);
            this.updateBrimstoneChargeMetrics?.();
          }
        }
      }
      this.recalculateEyePattern();
      this.recalculateDamage();
      return state;
    }
    getEyePatternOffsets(){
      const state = this.ensureEyePatternState();
      const extra = Math.max(0, Math.floor(state.totalExtraShots || 0));
      const count = 1 + extra;
      if(count<=1){
        return [0];
      }
      const step = Math.max(0.08, Number(state.step) || Number(state.baseStep) || 0.18);
      const totalSpan = step * (count - 1);
      const start = -totalSpan / 2;
      const offsets = [];
      for(let i=0;i<count;i++){
        offsets.push(start + step * i);
      }
      return offsets;
    }
    ensureHolyHeartState(){
      if(!this.holyHeartState || typeof this.holyHeartState !== 'object'){
        this.holyHeartState = {
          enabled: false,
          auraEnabled: false,
          aura: {},
          blessingMultiplier: 2.5,
          blessingActive: false,
          roomSuppressed: false,
        };
      } else {
        if(typeof this.holyHeartState.aura !== 'object' || !this.holyHeartState.aura){
          this.holyHeartState.aura = {};
        }
        if(!Number.isFinite(this.holyHeartState.blessingMultiplier)){
          this.holyHeartState.blessingMultiplier = 2.5;
        }
      }
      return this.holyHeartState;
    }
    hasHolyHeartAura(){
      return !!(this.holyHeartState && this.holyHeartState.enabled && this.holyHeartState.auraEnabled);
    }
    getHolyHeartAuraConfig(){
      if(!this.hasHolyHeartAura()) return null;
      const aura = this.holyHeartState?.aura || {};
      return {
        radiusMultiplier: Math.max(0.5, Number(aura.radiusMultiplier) || 3),
        interval: Math.max(1/120, Number(aura.interval) || (8/60)),
        damageRatio: Math.max(0, Number(aura.damageRatio) || 0.4),
        fillColor: aura.fillColor || '#fef9c3',
        strokeColor: aura.strokeColor || '#fde68a',
        player: this,
      };
    }
    updateHolyHeartBlessing(){
      const state = this.holyHeartState;
      if(!state || !state.enabled){
        return;
      }
      if(state.roomSuppressed){
        if(state.blessingActive){
          state.blessingActive = false;
          this.recalculateDamage();
        }
        return;
      }
      const shouldActivate = this.hp >= this.maxHp && this.maxHp>0;
      if(state.blessingActive !== shouldActivate){
        state.blessingActive = shouldActivate;
        this.recalculateDamage();
      }
    }
    suppressHolyHeartBlessingForRoom(){
      const state = this.holyHeartState;
      if(!state || !state.enabled){
        return;
      }
      state.roomSuppressed = true;
      if(state.blessingActive){
        state.blessingActive = false;
        this.recalculateDamage();
      }
    }
    onHolyHeartRoomChange(){
      const state = this.holyHeartState;
      if(!state || !state.enabled){
        return;
      }
      state.roomSuppressed = false;
      this.updateHolyHeartBlessing();
    }
    createImpactDashState(){
      const baseRadius = this.r || CONFIG.player.radius || 12;
      const baseDistanceUnits = 8;
      const baseDuration = 0.18;
      const baseDistance = baseRadius * 2 * baseDistanceUnits;
      const baseCooldown = 5;
      const basePostInvuln = 1;
      const baseSpeed = baseDuration>0 ? baseDistance / baseDuration : baseDistance / 0.18;
      return {
        unlocked: false,
        cooldown: 0,
        cooldownDuration: baseCooldown,
        tapThreshold: 0.25,
        dashDuration: baseDuration,
        dashTimer: 0,
        dashDir: {x:0,y:0},
        dashSpeed: 0,
        keyTimes: {KeyW:-Infinity, KeyA:-Infinity, KeyS:-Infinity, KeyD:-Infinity},
        readyPulse: 0,
        trail: null,
        minStep: Math.max(6, baseRadius * 0.6),
        baseDistanceUnits,
        distanceUnitsPerExtra: 3,
        distanceUnits: baseDistanceUnits,
        baseDashDuration: baseDuration,
        baseCooldownDuration: baseCooldown,
        basePostInvulnDuration: basePostInvuln,
        baseDashSpeed: baseSpeed,
        trailBaseRadiusMultiplier: 2,
        trailBaseDamageScale: 4,
        trailRadiusMultiplier: 1,
        trailDamageMultiplier: 1,
        trailLifetime: 1,
        trailTickInterval: 20/60,
        trailVisualIntensity: 1,
        trailSparkleRate: 0,
        trailSparkleLife: 0.35,
        trailSparkleColor: '#e0f2fe',
        maxStackMultiplier: 4.5,
        stackGrowth: 1.5,
        invulnTimer: 0,
        invulnTotal: 0,
        postInvulnDuration: basePostInvuln,
        flashThreshold: 0.25,
        canBreakObstacles: false,
      };
    }
    ensureImpactDashState(){
      if(!this.impactDash){
        this.impactDash = this.createImpactDashState();
        const stacks = this.getItemStack('impact-chocolate');
        if(stacks>0){
          this.updateImpactDashStackBonuses(stacks);
        }
      }
      return this.impactDash;
    }
    enableImpactDash(){
      const dash = this.ensureImpactDashState();
      dash.unlocked = true;
      const stacks = this.getItemStack('impact-chocolate');
      if(stacks>0){
        this.updateImpactDashStackBonuses(stacks);
      }
      return dash;
    }
    handleDirectionalKeyTap(code, timestampMs){
      const dash = this.ensureImpactDashState();
      if(!dash.unlocked) return;
      if(this.isEntryLocked && this.isEntryLocked()) return;
      if(code!=='KeyW' && code!=='KeyA' && code!=='KeyS' && code!=='KeyD') return;
      if(dash.active) return;
      const nowMs = Number.isFinite(timestampMs) ? timestampMs : (typeof performance!=='undefined' && performance.now ? performance.now() : Date.now());
      const now = nowMs / 1000;
      const prev = dash.keyTimes?.[code] ?? -Infinity;
      if(dash.keyTimes){ dash.keyTimes[code] = now; }
      const threshold = Math.max(0.05, dash.tapThreshold ?? 0.25);
      if(now - prev <= threshold){
        const dirs = {KeyW:{x:0,y:-1}, KeyS:{x:0,y:1}, KeyA:{x:-1,y:0}, KeyD:{x:1,y:0}};
        const dir = dirs[code];
        if(dir && this.tryStartImpactDash(dir, code)){
          if(dash.keyTimes){ dash.keyTimes[code] = -Infinity; }
        }
      }
    }
    tryStartImpactDash(dir, code){
      const dash = this.ensureImpactDashState();
      if(!dash.unlocked) return false;
      if(this.isEntryLocked && this.isEntryLocked()) return false;
      if(dash.active) return false;
      if(dash.cooldown>0){
        const cooldownCheck = this.collectSynergyOptions('impact-dash-cooldown', {cooldown: dash.cooldown});
        if(!cooldownCheck || !Number.isFinite(cooldownCheck.cooldown) || cooldownCheck.cooldown>0){
          return false;
        }
        dash.cooldown = Math.max(0, cooldownCheck.cooldown);
      }
      const len = Math.hypot(dir?.x ?? 0, dir?.y ?? 0);
      if(!(len>1e-5)) return false;
      const nx = (dir.x ?? 0) / len;
      const ny = (dir.y ?? 0) / len;
      const radius = this.r || CONFIG.player.radius || 12;
      const distanceUnits = Math.max(1, Number(dash.distanceUnits) || Number(dash.baseDistanceUnits) || 8);
      const dashDistance = Math.max(radius * 2, radius * 2 * distanceUnits);
      const duration = Math.max(0.12, Number(dash.dashDuration) || 0.18);
      dash.dashDir.x = nx;
      dash.dashDir.y = ny;
      dash.dashDuration = duration;
      dash.dashTimer = duration;
      dash.dashSpeed = dashDistance / duration;
      dash.active = true;
      dash.cooldown = Math.max(0, dash.cooldownDuration ?? 5);
      const cooldownSynergy = this.collectSynergyOptions('impact-dash-cooldown', {cooldown: dash.cooldown});
      if(cooldownSynergy && Number.isFinite(cooldownSynergy.cooldown)){
        dash.cooldown = Math.max(0, cooldownSynergy.cooldown);
      }
      dash.readyPulse = 0;
      const postInvuln = Math.max(0, dash.postInvulnDuration ?? 0);
      const totalInvuln = duration + postInvuln;
      dash.invulnTimer = totalInvuln;
      dash.invulnTotal = totalInvuln;
      if(dash.keyTimes && code && code in dash.keyTimes){
        dash.keyTimes[code] = -Infinity;
      }
      if(dash.trail && typeof dash.trail.finish === 'function'){
        dash.trail.finish();
      }
      const baseRadiusMultiplier = Number(dash.trailBaseRadiusMultiplier) || 2;
      const stackRadiusMultiplier = Math.max(0.6, Number(dash.trailRadiusMultiplier) || 1);
      const finalRadius = Math.max(radius * 1.2, radius * baseRadiusMultiplier * stackRadiusMultiplier);
      const baseMinStep = Math.max(2, dash.minStep || Math.max(6, radius * 0.6));
      const scaledMinStep = Math.max(2, baseMinStep * Math.min(stackRadiusMultiplier, 2.5));
      const tickInterval = Number(dash.trailTickInterval) || (20/60);
      const lifetime = Number(dash.trailLifetime) || 1;
      const baseDamageScale = Number(dash.trailBaseDamageScale) || 4;
      const stackDamageMultiplier = Math.max(0.2, Number(dash.trailDamageMultiplier) || 1);
      const damageScale = Math.max(0.2, baseDamageScale * stackDamageMultiplier);
      const visualIntensity = Number.isFinite(dash.trailVisualIntensity) ? dash.trailVisualIntensity : 1;
      const sparkleRate = Math.max(0, Number(dash.trailSparkleRate) || 0);
      const sparkleLife = Number.isFinite(dash.trailSparkleLife) ? dash.trailSparkleLife : 0.35;
      const sparkleColor = typeof dash.trailSparkleColor === 'string' ? dash.trailSparkleColor : '#e0f2fe';
      let trailOptions = {
        radius: finalRadius,
        minStep: scaledMinStep,
        tickInterval,
        lifetime,
        damageScale,
        visualIntensity,
        sparkleRate,
        sparkleLife,
        sparkleColor,
      };
      trailOptions = this.collectSynergyOptions('impact-dash-trail', trailOptions, {dash});
      const trail = createImpactDashTrail(this, trailOptions);
      dash.trail = trail;
      if(trail && typeof trail.addPoint === 'function'){
        trail.addPoint(this.x, this.y);
      }
      if(Array.isArray(runtime.beams)){ runtime.beams.push(trail); }
      else { runtime.beams = [trail]; }
      return true;
    }
    endImpactDash(options={}){
      const dash = this.ensureImpactDashState();
      if(!dash.active) return;
      dash.active = false;
      dash.dashTimer = 0;
      dash.dashSpeed = 0;
      dash.dashDir.x = 0;
      dash.dashDir.y = 0;
      const postInvuln = Math.max(0, dash.postInvulnDuration ?? 0);
      if(postInvuln>0){
        dash.invulnTimer = postInvuln;
        dash.invulnTotal = postInvuln;
      } else if(dash.invulnTimer>0){
        dash.invulnTotal = Math.max(dash.invulnTotal, dash.invulnTimer);
      }
      if(dash.trail && typeof dash.trail.finalize === 'function'){
        dash.trail.finalize();
      }
      const cooldownSynergy = this.collectSynergyOptions('impact-dash-cooldown', {cooldown: dash.cooldown});
      if(cooldownSynergy && Number.isFinite(cooldownSynergy.cooldown)){
        dash.cooldown = Math.max(0, cooldownSynergy.cooldown);
      }
    }
    isImpactDashing(){
      return !!(this.impactDash && this.impactDash.active);
    }
    isEntryLocked(){
      return !!this.entryLockActive;
    }
    hasImpactDashInvulnerability(){
      const dash = this.impactDash;
      if(!dash) return false;
      if(dash.active) return true;
      return dash.invulnTimer>0;
    }
    getImpactDashInvulnRatio(){
      const dash = this.impactDash;
      if(!dash) return 0;
      if(dash.active) return 1;
      if(dash.invulnTimer>0 && dash.invulnTotal>0){
        return clamp(dash.invulnTimer / dash.invulnTotal, 0, 1);
      }
      return 0;
    }
    getImpactDashInvulnTime(){
      const dash = this.impactDash;
      return Math.max(0, dash?.invulnTimer ?? 0);
    }
    getImpactDashFlashThreshold(){
      const dash = this.impactDash;
      if(!dash) return 0;
      const threshold = dash.flashThreshold ?? 0;
      return Math.max(0, threshold);
    }
    hurt(dmg, options={}){
      if(this.hasImpactDashInvulnerability && this.hasImpactDashInvulnerability()) return;
      const amount = Math.max(0, Number(dmg)||0);
      if(amount<=0) return;
      const cause = options.cause || null;
      if(cause==='explosion' && this.bombImmunity){
        if(this.explosionHealAmount>0){
          const prev = this.hp;
          this.hp = Math.min(this.maxHp, this.hp + this.explosionHealAmount);
          if(this.hp!==prev){ this.recalculateDamage(); }
        }
        return;
      }
      if(this.ifr>0 && !options.bypassIFrames) return;
      if(typeof this.suppressHolyHeartBlessingForRoom === 'function'){
        this.suppressHolyHeartBlessingForRoom();
      }
      let remaining = amount;
      let tookDamage = false;
      const hadSoulBefore = this.soulHearts > 0;
      if(remaining>0 && this.soulHearts>0){
        const consumed = Math.min(this.soulHearts, remaining);
        this.soulHearts -= consumed;
        remaining -= consumed;
        if(consumed>0){ tookDamage = true; }
      }
      const tookRedDamage = remaining>0;
      if(tookRedDamage){
        this.hp = Math.max(0, this.hp - remaining);
        if(remaining>0){ tookDamage = true; }
      }
      if(tookDamage){
        audio.play('playerHurt', {volume: 0.65});
      }
      const ifrBase = Number.isFinite(options.ifr) ? Math.max(0, options.ifr) : 0.75;
      const ifrDuration = ifrBase * this.getIFrameMultiplier();
      this.ifr = Math.max(this.ifr, ifrDuration);
      if(this.hp<=0){ gameOver(); return; }
      if(!hadSoulBefore && tookRedDamage){
        adjustExchangePortalChance(0.65);
      }
      if(cause==='explosion' && this.explosionHealAmount>0){
        const prevHp = this.hp;
        this.hp = Math.min(this.maxHp, this.hp + this.explosionHealAmount);
        if(this.hp!==prevHp){
          this.recalculateDamage();
          this.updateHolyHeartBlessing?.();
          return;
        }
      }
      if(this.soulHearts<0){ this.soulHearts = 0; }
      this.recalculateDamage();
      this.updateHolyHeartBlessing?.();
    }
    addDamage(amount){
      this.baseDamage = +(this.baseDamage + amount).toFixed(2);
      this.recalculateDamage();
    }
    getItemStack(slug){
      return getItemStack(this, slug);
    }
    incrementItemStack(slug, amount=1){
      return incrementItemStack(this, slug, amount);
    }
    hasItem(slug){
      if(!slug) return false;
      const stack = this.getItemStack ? this.getItemStack(slug) : 0;
      return Number.isFinite(stack) && stack>0;
    }
    collectSynergyOptions(aspect, base={}, context={}){
      const result = {...base};
      switch(aspect){
        case 'impact-dash-trail': {
          const hasBrimstone = this.attackMode === 'brimstone';
          const hasHoming = !!this.homingTears;
          if(hasHoming){
            result.homing = true;
            const strength = Math.max(Number(result.homingStrength) || 0, Number(this.homingStrength) || 8);
            result.homingStrength = strength;
            const tearSpeed = Number(this.tearSpeed) || Number(CONFIG.player?.tearSpeed) || 220;
            const homingSpeed = Math.max(Number(result.homingSpeed) || 0, tearSpeed * 0.85);
            result.homingSpeed = homingSpeed;
            const range = Math.max(Number(result.homingRange) || 0, 520);
            result.homingRange = range;
            result.homingWhileInactive = true;
            const bodyRadius = this.r || CONFIG.player.radius || 12;
            const stretch = Math.max(Number(result.homingMaxStretch) || 0, bodyRadius * 7);
            result.homingMaxStretch = stretch;
          }
          if(hasHoming || hasBrimstone){
            const palette = {...(result.colors||{})};
            if(hasBrimstone && hasHoming){
              result.damageScale = Math.max(Number(result.damageScale) || 0, (Number(base?.damageScale) || 1) * 1.2);
              palette.outer = palette.outer || '#a855f7';
              palette.mid = palette.mid || '#d946ef';
              palette.inner = palette.inner || '#fbcfe8';
              palette.sparkle = palette.sparkle || '#f5d0fe';
              palette.glowStart = palette.glowStart || '#f0abfc';
              palette.glowEnd = palette.glowEnd || '#c084fc';
              palette.glowOuter = palette.glowOuter || '#9333ea';
              palette.gradientInner = palette.gradientInner || '#f5d0fe';
              palette.gradientMid = palette.gradientMid || '#d8b4fe';
              palette.gradientOuter = palette.gradientOuter || '#a855f7';
              palette.burstStart = palette.burstStart || '#c084fc';
              palette.burstStartAccent = palette.burstStartAccent || '#f5d0fe';
              palette.burstEnd = palette.burstEnd || '#a855f7';
              palette.burstEndAccent = palette.burstEndAccent || '#ddd6fe';
              palette.stroke = palette.stroke || '#7c3aed';
            } else if(hasHoming){
              palette.outer = palette.outer || '#0ea5e9';
              palette.mid = palette.mid || '#38bdf8';
              palette.inner = palette.inner || '#e0f2fe';
              palette.sparkle = palette.sparkle || '#bae6fd';
              palette.glowStart = palette.glowStart || '#bae6fd';
              palette.glowEnd = palette.glowEnd || '#7dd3fc';
              palette.glowOuter = palette.glowOuter || '#0ea5e9';
              palette.gradientInner = palette.gradientInner || '#bfdbfe';
              palette.gradientMid = palette.gradientMid || '#60a5fa';
              palette.gradientOuter = palette.gradientOuter || '#0284c7';
              palette.burstStart = palette.burstStart || '#38bdf8';
              palette.burstStartAccent = palette.burstStartAccent || '#bae6fd';
              palette.burstEnd = palette.burstEnd || '#60a5fa';
              palette.burstEndAccent = palette.burstEndAccent || '#bfdbfe';
              palette.stroke = palette.stroke || '#0ea5e9';
            } else if(hasBrimstone){
              result.damageScale = Math.max(Number(result.damageScale) || 0, (Number(base?.damageScale) || 1) * 1.1);
              palette.outer = palette.outer || '#b91c1c';
              palette.mid = palette.mid || '#ef4444';
              palette.inner = palette.inner || '#fee2e2';
              palette.sparkle = palette.sparkle || '#fecaca';
              palette.glowStart = palette.glowStart || '#fecaca';
              palette.glowEnd = palette.glowEnd || '#f87171';
              palette.glowOuter = palette.glowOuter || '#dc2626';
              palette.gradientInner = palette.gradientInner || '#fecaca';
              palette.gradientMid = palette.gradientMid || '#fda4af';
              palette.gradientOuter = palette.gradientOuter || '#ef4444';
              palette.burstStart = palette.burstStart || '#f87171';
              palette.burstStartAccent = palette.burstStartAccent || '#fee2e2';
              palette.burstEnd = palette.burstEnd || '#dc2626';
              palette.burstEndAccent = palette.burstEndAccent || '#fecaca';
              palette.stroke = palette.stroke || '#991b1b';
            }
            result.colors = palette;
          }
          break;
        }
        case 'brimstone-beam': {
          const ratioRaw = Number(context?.chargeRatio);
          const chargeRatio = Number.isFinite(ratioRaw) ? clamp(ratioRaw, 0, 1) : 1;
          const hasHotChoco = this.hasHotChocolate && this.hasHotChocolate();
          if(hasHotChoco){
            result.allowPartialCharge = true;
            if(chargeRatio < 1){
              const effective = Math.max(chargeRatio, 0.12);
              result.partialChargeRatio = effective;
              result.damageScaleMultiplier = Math.max(Number(result.damageScaleMultiplier) || 0, 0.45 + 0.55 * effective);
              result.durationMultiplier = Math.max(Number(result.durationMultiplier) || 0, 0.55 + 0.45 * effective);
              result.widthMultiplier = Math.max(Number(result.widthMultiplier) || 0, 0.7 + 0.3 * effective);
              result.tickIntervalMultiplier = Math.max(Number(result.tickIntervalMultiplier) || 0, 0.7 + 0.3 * effective);
            }
          }
          break;
        }
        case 'brimstone-charge-rate': {
          if(this.hasHotChocolate && this.hasHotChocolate()){
            const prev = Number(result.chargeTimeMultiplier) || 1;
            result.chargeTimeMultiplier = prev * 0.82;
          }
          break;
        }
        case 'impact-dash-cooldown': {
          if(isTimeStopActive()){
            result.cooldown = 0;
          }
          break;
        }
        default:
          break;
      }
      return result;
    }
    getShopPriceMultiplier(){
      const value = Number(this.shopPriceMultiplier);
      if(!Number.isFinite(value)) return 1;
      return clamp(value, 0.4, 2);
    }
    getShopPriceOffset(){
      const value = Number(this.shopPriceOffset);
      if(!Number.isFinite(value)) return 0;
      return Math.max(0, Math.floor(value));
    }
    getAdjustedPrice(basePrice){
      const base = Math.max(0, Math.round(Number(basePrice) || 0));
      const scaled = base * this.getShopPriceMultiplier();
      const offset = this.getShopPriceOffset();
      const finalPrice = Math.round(scaled - offset);
      return Math.max(0, finalPrice);
    }
    getCardDropBonus(){
      const bonus = Number(this.cardDropBonus) || 0;
      return clamp(bonus, 0, 0.9);
    }
    updateImpactDashStackBonuses(stacksOverride){
      if(!this.impactDash){
        if(Number.isFinite(stacksOverride) && stacksOverride>0){
          this.impactDash = this.createImpactDashState();
        } else {
          return;
        }
      }
      const dash = this.impactDash;
      if(!dash) return;
      const stacks = Number.isFinite(stacksOverride) ? stacksOverride : this.getItemStack('impact-chocolate');
      const extra = Math.max(0, stacks - 1);
      dash.stackCount = stacks;
      dash.extraStacks = extra;

      const baseDistanceUnits = Number.isFinite(dash.baseDistanceUnits) ? dash.baseDistanceUnits : 8;
      const perExtra = Number.isFinite(dash.distanceUnitsPerExtra) ? dash.distanceUnitsPerExtra : 3;
      const radius = this.r || CONFIG.player.radius || 12;
      const distanceUnits = baseDistanceUnits + extra * perExtra;
      dash.distanceUnits = Math.max(baseDistanceUnits, distanceUnits);
      const dashDistance = Math.max(radius * 2, radius * 2 * dash.distanceUnits);
      dash.currentDashDistance = dashDistance;

      const baseDuration = Number.isFinite(dash.baseDashDuration) ? dash.baseDashDuration : 0.18;
      let baseSpeed = Number(dash.baseDashSpeed);
      if(!Number.isFinite(baseSpeed) || baseSpeed<=0){
        const baseDistance = radius * 2 * baseDistanceUnits;
        baseSpeed = baseDuration>0 ? baseDistance / baseDuration : dashDistance / Math.max(baseDuration, 0.12);
        dash.baseDashSpeed = baseSpeed;
      }
      const duration = baseSpeed>0 ? dashDistance / baseSpeed : (baseDuration + extra * 0.05);
      dash.dashDuration = Math.max(0.12, duration);

      const baseCooldown = Number.isFinite(dash.baseCooldownDuration) ? dash.baseCooldownDuration : (Number(dash.cooldownDuration) || 5);
      const cooldownReduction = extra * 0.5;
      const cooldownDuration = Math.max(0.5, baseCooldown - cooldownReduction);
      dash.cooldownDuration = cooldownDuration;
      if(dash.cooldown > cooldownDuration){
        dash.cooldown = cooldownDuration;
      }

      const basePost = Number.isFinite(dash.basePostInvulnDuration) ? dash.basePostInvulnDuration : (Number(dash.postInvulnDuration) || 1);
      dash.basePostInvulnDuration = basePost;
      const durationGain = Math.max(0, dash.dashDuration - baseDuration);
      dash.postInvulnDuration = Math.max(0, basePost + durationGain * 0.5);

      const growth = Number(dash.stackGrowth) || 1.5;
      let multiplier = extra>0 ? Math.pow(growth, extra) : 1;
      const maxMultiplier = Number(dash.maxStackMultiplier);
      if(Number.isFinite(maxMultiplier) && maxMultiplier>0){
        multiplier = Math.min(multiplier, maxMultiplier);
      }
      dash.trailRadiusMultiplier = multiplier;
      dash.trailDamageMultiplier = multiplier;

      const intensity = clamp(0.9 + extra * 0.22, 0.9, 1.8);
      dash.trailVisualIntensity = intensity;
      dash.trailSparkleRate = extra>0 ? Math.min(22, 6 + extra * 4) : 0;
      dash.trailSparkleLife = clamp(0.3 + extra * 0.04, 0.3, 0.6);
      dash.trailSparkleColor = stacks>=4 ? '#f0fdf4' : '#e0f2fe';

      dash.canBreakObstacles = stacks>3;
    }
    adjustMaxHp(delta){
      if(!Number.isFinite(delta)) return;
      const prev = this.maxHp;
      this.maxHp = clamp(prev + delta, 1, this.maxHpCap);
      if(this.hp > this.maxHp){
        this.hp = this.maxHp;
      } else if(delta>0){
        const diff = this.maxHp - prev;
        if(diff>0) this.hp = Math.min(this.maxHp, this.hp + diff);
      }
      const cap = this.getSoulHeartCap();
      if(this.soulHearts > cap){ this.soulHearts = cap; }
      this.recalculateDamage();
      if(typeof this.updateHolyHeartBlessing === 'function'){
        this.updateHolyHeartBlessing();
      }
    }
    getSoulHeartCap(){
      if(this.unlimitedSoulHearts){
        return Number.POSITIVE_INFINITY;
      }
      const mult = Number.isFinite(this.soulHeartCapMultiplier) ? Math.max(0, this.soulHeartCapMultiplier) : 1;
      return Math.max(0, Math.floor(this.maxHp * mult));
    }
    addSoulHearts(amount){
      const value = Math.floor(Number(amount) || 0);
      if(!value) return 0;
      const cap = this.getSoulHeartCap();
      const prev = this.soulHearts;
      this.soulHearts = clamp(prev + value, 0, cap);
      const gained = this.soulHearts - prev;
      if(gained!==0){ this.recalculateDamage(); }
      return gained;
    }
    getEnemySpeedMultiplier(){
      return clamp(this.enemySpeedMultiplier || 1, 0.25, 1);
    }
    setEnemySpeedMultiplier(multiplier){
      if(!Number.isFinite(multiplier)) return;
      this.enemySpeedMultiplier = clamp(multiplier, 0.25, 1);
    }
    getEnemySpawnFactor(){
      return clamp(this.enemySpawnFactor || 1, 0.35, 1);
    }
    setEnemySpawnFactor(factor){
      if(!Number.isFinite(factor)) return;
      this.enemySpawnFactor = clamp(factor, 0.2, 1);
    }
    getWorldTimeScale(){
      if(!this.timeScaleModifiers || this.timeScaleModifiers.size===0) return 1;
      let scale = 1;
      for(const value of this.timeScaleModifiers.values()){
        if(!Number.isFinite(value)) continue;
        scale *= value;
      }
      return clamp(scale, 0, 4);
    }
    setTimeScaleModifier(tag, factor){
      if(!tag) return;
      if(!this.timeScaleModifiers || !(this.timeScaleModifiers instanceof Map)){
        this.timeScaleModifiers = new Map();
      }
      if(!Number.isFinite(factor) || factor===1){
        this.timeScaleModifiers.delete(tag);
      } else {
        this.timeScaleModifiers.set(tag, clamp(factor, 0, 4));
      }
    }
    clearTimeScaleModifier(tag){
      if(!tag || !this.timeScaleModifiers) return;
      this.timeScaleModifiers.delete(tag);
    }
    rewindRunTimer(seconds){
      if(runtime?.runTimer && Number.isFinite(seconds) && seconds>0){
        runtime.runTimer.rewind(seconds);
      }
    }
    adjustRunTimer(delta){
      if(runtime?.runTimer && Number.isFinite(delta) && delta!==0){
        runtime.runTimer.addTime(delta);
      }
    }
    getIFrameMultiplier(){
      return Math.max(0.1, this.ifrBoostMultiplier || 1);
    }
    getAttackRatePerSecond(){
      if(this.attackMode === 'bomb-elder'){
        const interval = this.getBombElderInterval();
        return interval>0 ? 1/interval : 0;
      }
      if(this.attackMode === 'bomb-progenitor'){
        const cycle = this.getBombProgenitorCycleTime();
        return cycle>0 ? 1/cycle : 0;
      }
      if(this.attackMode === 'brimstone'){
        const charge = Math.max(0.0001, this.brimstoneChargeTime || ((CONFIG.player?.fireCd || 360) / 1000));
        return charge>0 ? 1/charge : 0;
      }
      return this.fireInterval>0 ? 1000/this.fireInterval : 0;
    }
    updateBrimstoneChargeMetrics(){
      const interval = Number.isFinite(this.fireInterval) ? this.fireInterval : (CONFIG.player.fireCd || 360);
      const brimstoneChargeScale = CONFIG?.brimstone?.chargeScale ?? 11.25;
      let chargeTime = Math.max(0.15, (interval / 1000) * brimstoneChargeScale);
      const synergy = this.collectSynergyOptions('brimstone-charge-rate', {chargeTimeMultiplier:1}, {interval});
      if(synergy){
        if(Number.isFinite(synergy.chargeTime)){
          chargeTime = Math.max(0.12, synergy.chargeTime);
        } else if(Number.isFinite(synergy.chargeTimeMultiplier)){
          chargeTime = Math.max(0.12, chargeTime * synergy.chargeTimeMultiplier);
        }
      }
      this.brimstoneChargeTime = chargeTime;
    }
    ensureBrimstoneMode(){
      if(this.attackMode !== 'brimstone'){
        this.attackMode = 'brimstone';
        this.brimstoneStacks = 0;
      }
      this.brimstoneStacks = Math.max(0, (this.brimstoneStacks || 0)) + 1;
      this.brimstoneCharging = false;
      this.brimstoneCharged = false;
      this.brimstoneCharge = 0;
      this.brimstoneAim = this.brimstoneAim || {x:0, y:-1};
      this.interruptBrimstoneBeam();
      this.updateBrimstoneChargeMetrics();
    }
    setMaxHpToSingle(){
      this.maxHp = 1;
      if(this.hp > this.maxHp){ this.hp = this.maxHp; }
      this.recalculateDamage();
      if(typeof this.updateHolyHeartBlessing === 'function'){
        this.updateHolyHeartBlessing();
      }
    }
    getBrimstoneWidth(){
      const base = this.r * 2 * 1.5;
      const growth = CONFIG.brimstone?.widthGrowth ?? 1.5;
      const stacks = Math.max(1, this.brimstoneStacks || 1);
      return base * Math.pow(growth, stacks - 1);
    }
    getBrimstoneChargeRatio(){
      if(this.brimstoneBeam){
        return 1;
      }
      const denom = Math.max(0.0001, this.brimstoneChargeTime || 0.2);
      const ratio = clamp(this.brimstoneCharge / denom, 0, 1);
      return this.brimstoneCharged ? 1 : ratio;
    }
    interruptBrimstoneBeam(){
      if(this.brimstoneBeam){
        endBeam(this.brimstoneBeam);
        this.dispatchFollowerShot?.('brimstone-stop', {reason:'interrupt'});
      }
    }
    handleBrimstoneAttack(dt, sx, sy, lvx, lvy, maxSpeed){
      const pressed = !!(sx || sy);
      if(this.brimstoneBeam){
        this.brimstoneBeamTimer = Math.max(0, (this.brimstoneBeamTimer || 0) - dt);
        if(pressed){
          this.interruptBrimstoneBeam();
        }
      }
      if(this.brimstoneBeam){
        return;
      }
      if(pressed){
        const len = Math.hypot(sx, sy) || 1;
        this.brimstoneAim.x = sx / len;
        this.brimstoneAim.y = sy / len;
        if(!this.brimstoneCharging){
          this.brimstoneCharging = true;
          this.brimstoneCharge = 0;
          this.brimstoneCharged = false;
        }
        this.brimstoneCharge += dt;
        if(this.brimstoneCharge >= this.brimstoneChargeTime){
          this.brimstoneCharge = this.brimstoneChargeTime;
          if(!this.brimstoneCharged){
            audio.play('brimstoneReady', {volume: 0.58});
          }
          this.brimstoneCharged = true;
        }
      } else {
        if(this.brimstoneCharging){
          const ratioRaw = this.brimstoneChargeTime>0 ? this.brimstoneCharge / this.brimstoneChargeTime : 0;
          const chargeRatio = clamp(ratioRaw, 0, 1);
          if(this.brimstoneCharged){
            this.fireBrimstoneBeam({chargeRatio:1});
          } else {
            this.fireBrimstoneBeam({chargeRatio});
          }
          this.brimstoneCharging = false;
          this.brimstoneCharge = 0;
          this.brimstoneCharged = false;
        }
      }
    }
    fireBrimstoneBeam(options={}){
      const aim = this.brimstoneAim || {x:0, y:-1};
      const len = Math.hypot(aim.x, aim.y) || 1;
      const dir = {x: aim.x/len, y: aim.y/len};
      const baseDuration = CONFIG.brimstone?.beamDuration ?? 2;
      let duration = baseDuration;
      const baseTickFrames = Math.max(1, CONFIG.brimstone?.tickFrames ?? 15);
      let tickFrames = baseTickFrames;
      const baseDamageScale = CONFIG.brimstone?.damageScale ?? 0.7;
      let damageScale = baseDamageScale;
      let widthOverride = options.width;
      const ratioRaw = Number(options?.chargeRatio);
      const chargeRatio = Number.isFinite(ratioRaw) ? clamp(ratioRaw, 0, 1) : (this.brimstoneCharged ? 1 : 0);
      const synergy = this.collectSynergyOptions('brimstone-beam', {damageScale, duration, tickFrames, widthMultiplier:1}, {chargeRatio});
      if(chargeRatio < 1 && !(synergy && synergy.allowPartialCharge)){
        return false;
      }
      const ratioForScaling = synergy && Number.isFinite(synergy.partialChargeRatio)
        ? clamp(synergy.partialChargeRatio, 0, 1)
        : chargeRatio;
      if(synergy){
        if(Number.isFinite(synergy.damageScale)){
          damageScale = synergy.damageScale;
        }
        if(Number.isFinite(synergy.damageScaleMultiplier)){
          damageScale *= synergy.damageScaleMultiplier;
        }
        if(Number.isFinite(synergy.duration)){
          duration = synergy.duration;
        } else if(Number.isFinite(synergy.durationMultiplier)){
          duration = baseDuration * synergy.durationMultiplier;
        }
        if(Number.isFinite(synergy.tickFrames)){
          tickFrames = Math.max(1, Math.round(synergy.tickFrames));
        } else if(Number.isFinite(synergy.tickIntervalMultiplier)){
          tickFrames = Math.max(1, Math.round(baseTickFrames * synergy.tickIntervalMultiplier));
        }
        if(Number.isFinite(synergy.width)){
          widthOverride = synergy.width;
        } else if(Number.isFinite(synergy.widthMultiplier) && !Number.isFinite(options.width)){
          const widthBase = this.getBrimstoneWidth();
          widthOverride = widthBase * synergy.widthMultiplier;
        }
        if(Number.isFinite(synergy.damageScaleMultiplier) && !Number.isFinite(synergy.damageScale)){
          damageScale = baseDamageScale * synergy.damageScaleMultiplier;
        }
      }
      if(ratioForScaling < 1 && duration === baseDuration){
        duration = baseDuration * (0.55 + 0.45 * ratioForScaling);
      }
      if(ratioForScaling < 1 && damageScale === baseDamageScale){
        damageScale = baseDamageScale * (0.5 + 0.5 * ratioForScaling);
      }
      if(!Array.isArray(runtime.beams)){ runtime.beams = []; }
      if(this.brimstoneBeam){
        endBeam(this.brimstoneBeam);
        this.dispatchFollowerShot?.('brimstone-stop', {reason:'restart'});
      }
      const beam = new BrimstoneProjectile(this, dir, {
        duration,
        tickFrames,
        damageScale,
        homing: !!this.homingTears,
        homingStrength: this.homingStrength,
        width: widthOverride,
      });
      runtime.beams.push(beam);
      this.brimstoneBeam = beam;
      this.brimstoneFiring = true;
      this.brimstoneBeamTimer = duration;
      this.brimstoneCharge = 0;
      this.brimstoneCharged = false;
      this.brimstoneCharging = false;
      this.dispatchFollowerShot?.('brimstone-start', {dir, duration, tickFrames, damageScale, width: widthOverride});
      return true;
    }
    applyImpulse(dx,dy,strength){
      if(this.isImpactDashing && this.isImpactDashing()) return;
      const len = Math.hypot(dx,dy) || 1;
      const power = strength || CONFIG.bomb.knock;
      this.knockVel.x += (dx/len) * power;
      this.knockVel.y += (dy/len) * power;
      this.knockTimer = 0.25;
    }
    clearRoomBuff(){
      if(!this.roomBuff) return;
      const snapshot = this.roomBuff.snapshot || null;
      if(snapshot){
        if(typeof snapshot.baseDamage === 'number'){ this.baseDamage = snapshot.baseDamage; }
        if(typeof snapshot.fireInterval === 'number'){ this.fireInterval = snapshot.fireInterval; }
        if(typeof snapshot.fireCd === 'number'){ this.fireCd = Math.min(snapshot.fireCd, this.fireInterval); }
        if(typeof snapshot.tearLife === 'number'){ this.tearLife = snapshot.tearLife; }
        if(typeof snapshot.tearSpeed === 'number'){ this.tearSpeed = snapshot.tearSpeed; }
        if(typeof snapshot.homingTears === 'boolean'){ this.homingTears = snapshot.homingTears; }
        if(typeof snapshot.homingStrength === 'number'){ this.homingStrength = snapshot.homingStrength; }
        if(typeof snapshot.canPierceObstacles === 'boolean'){ this.canPierceObstacles = snapshot.canPierceObstacles; }
      }
      this.roomBuff = null;
      this.updateBrimstoneChargeMetrics();
      this.recalculateDamage();
    }
    applyRoomBuff(buff){
      if(!buff) return;
      const roomKey = buff.roomKey ?? null;
      if(this.roomBuff && this.roomBuff.roomKey && roomKey && this.roomBuff.roomKey !== roomKey){
        this.clearRoomBuff();
      }
      if(!this.roomBuff){
        const snapshot = {
          baseDamage: this.baseDamage,
          fireInterval: this.fireInterval,
          fireCd: this.fireCd,
          tearLife: this.tearLife,
          tearSpeed: this.tearSpeed,
          homingTears: this.homingTears,
          homingStrength: this.homingStrength,
          canPierceObstacles: this.canPierceObstacles,
        };
        this.roomBuff = {roomKey, snapshot, effects: []};
      }
      const effects = Array.isArray(this.roomBuff.effects) ? this.roomBuff.effects : (this.roomBuff.effects = []);
      const stored = {...buff};
      if(stored.type){
        for(let i=effects.length-1;i>=0;i--){
          if(effects[i]?.type === stored.type){ effects.splice(i,1); }
        }
      }
      effects.push(stored);
      const snapshot = this.roomBuff.snapshot;
      if(snapshot){
        if(typeof snapshot.baseDamage === 'number'){ this.baseDamage = snapshot.baseDamage; }
        if(typeof snapshot.fireInterval === 'number'){ this.fireInterval = snapshot.fireInterval; }
        if(typeof snapshot.fireCd === 'number'){ this.fireCd = Math.min(snapshot.fireCd, this.fireInterval); }
        if(typeof snapshot.tearLife === 'number'){ this.tearLife = snapshot.tearLife; }
        if(typeof snapshot.tearSpeed === 'number'){ this.tearSpeed = snapshot.tearSpeed; }
        if(typeof snapshot.homingTears === 'boolean'){ this.homingTears = snapshot.homingTears; }
        if(typeof snapshot.homingStrength === 'number'){ this.homingStrength = snapshot.homingStrength; }
        if(typeof snapshot.canPierceObstacles === 'boolean'){ this.canPierceObstacles = snapshot.canPierceObstacles; }
      }
      for(const effect of effects){
        if(!effect) continue;
        if(Number.isFinite(effect.damageBonus) && effect.damageBonus!==0){
          this.baseDamage = +(this.baseDamage + effect.damageBonus);
        }
        if(Number.isFinite(effect.fireRateBonus) && effect.fireRateBonus!==0){
          adjustFireRate(this, effect.fireRateBonus);
        }
        if(Number.isFinite(effect.rangeMultiplier) && effect.rangeMultiplier>0){
          this.tearLife *= effect.rangeMultiplier;
        }
        if(Number.isFinite(effect.speedMultiplier) && effect.speedMultiplier>0){
          this.tearSpeed *= effect.speedMultiplier;
        }
        if(effect.homing){
          this.homingTears = true;
          if(Number.isFinite(effect.homingStrength)){
            this.homingStrength = Math.max(this.homingStrength, effect.homingStrength);
          }
        }
        if(effect.pierceObstacles || effect.pierce){
          this.canPierceObstacles = true;
        }
      }
      this.recalculateDamage();
      if(typeof this.onHolyHeartRoomChange === 'function'){
        this.onHolyHeartRoomChange();
      }
    }
    handleRoomChange(room){
      if(!room){ this.clearRoomBuff(); return; }
      const key = `${room.i},${room.j}`;
      if(this.roomBuff && this.roomBuff.roomKey && this.roomBuff.roomKey !== key){
        this.clearRoomBuff();
      } else if(this.roomBuff && !this.roomBuff.roomKey){
        this.clearRoomBuff();
      }
      if(this.bombProgenitor){
        const state = this.bombProgenitor;
        state.chainCount = 0;
        state.chainTimer = 0;
        state.chainPosition = null;
        if(state.reticleEffect){
          state.reticleEffect.life = Math.min(state.reticleEffect.life, 0.02);
          state.reticleEffect = null;
        }
        state.reticle = null;
      }
    }
    setActiveItem(item){
      if(!item){
        this.activeItem = null;
        this.activeMaxCharge = this.baseActiveMaxCharge;
        this.activeCharge = clamp(this.activeCharge, 0, this.activeMaxCharge);
        return;
      }
      this.activeItem = {...item};
      if(Number.isFinite(item.maxCharge) && item.maxCharge>0){
        this.activeMaxCharge = Math.max(1, Math.floor(item.maxCharge));
      } else {
        this.activeMaxCharge = this.baseActiveMaxCharge;
      }
      if(Number.isFinite(item.startCharge)){
        this.activeCharge = clamp(Math.floor(item.startCharge), 0, this.activeMaxCharge);
      } else {
        this.activeCharge = clamp(this.activeCharge, 0, this.activeMaxCharge);
      }
    }
    enableFullMapVision(dungeonInstance){
      this.fullMapVision = true;
      if(dungeonInstance && typeof dungeonInstance.revealAllRooms === 'function'){
        dungeonInstance.revealAllRooms();
      }
    }
    setSingleUseItem(item){
      if(!item){
        this.singleUseItem = null;
        return;
      }
      this.singleUseItem = {...item};
    }
    canUseSingleUseItem(){
      return !!(this.singleUseItem && typeof this.singleUseItem.use === 'function');
    }
    useSingleUseItem(context){
      if(!this.singleUseItem) return false;
      const item = this.singleUseItem;
      const handler = item.use;
      const result = handler ? handler(this, context) : true;
      if(result === false) return false;
      let consume = true;
      if(result && typeof result === 'object' && 'consume' in result){
        consume = !!result.consume;
      }
      if(consume){
        this.singleUseItem = null;
      }
      return result ?? true;
    }
    gainActiveCharge(amount=1){
      if(!Number.isFinite(amount) || amount<=0) return false;
      const max = Math.max(0, this.activeMaxCharge ?? 0);
      if(max<=0) return false;
      const prev = this.activeCharge;
      this.activeCharge = clamp(Math.floor(prev + amount), 0, max);
      return this.activeCharge !== prev;
    }
    canUseActiveItem(){
      if(!this.activeItem) return false;
      if(typeof this.activeItem.use !== 'function') return false;
      const max = Math.max(0, this.activeMaxCharge ?? 0);
      return max>0 && this.activeCharge >= max;
    }
    useActiveItem(context){
      if(!this.canUseActiveItem()) return false;
      const handler = this.activeItem.use;
      const result = handler ? handler(this, context) : true;
      if(result === false) return false;
      let consume = this.activeMaxCharge;
      if(typeof result === 'number' && Number.isFinite(result)){
        consume = clamp(Math.floor(result), 0, this.activeMaxCharge);
      } else if(result && typeof result === 'object' && Number.isFinite(result.consume)){
        consume = clamp(Math.floor(result.consume), 0, this.activeMaxCharge);
      }
      if(consume<=0) consume = this.activeMaxCharge;
      this.activeCharge = Math.max(0, this.activeCharge - consume);
      return result || true;
    }
    recalculateDamage(){
      let dmg = this.baseDamage;
      if(this.effects.bloodPower){ dmg += this.hp * 0.3; }
      if(this.effects.moneyPower){ dmg += this.coins * 0.05; }
      if(this.effects.despairPower){ const missing = this.maxHp - this.hp; dmg += missing * 0.6; }
      const holyMultiplier = (this.holyHeartState && this.holyHeartState.enabled && this.holyHeartState.blessingActive)
        ? Math.max(0.01, this.holyHeartState.blessingMultiplier || 2.5)
        : 1;
      this.damage = +(Math.max(0.4, dmg) * this.damageMultiplier * holyMultiplier).toFixed(2);
    }
  }

  function acquireNearestEnemy(source){
    const room = dungeon?.current;
    if(!room) return null;
    let best=null;
    let bestDist=Infinity;
    for(const enemy of room.enemies){
      if(!enemy || enemy.dead) continue;
      const dx = enemy.x - source.x;
      const dy = enemy.y - source.y;
      const dist = dx*dx + dy*dy;
      if(dist < bestDist){
        bestDist = dist;
        best = enemy;
      }
    }
    return best;
  }

  function followerDefaultDraw(follower, ctx){
    const radius = follower.r || 6;
    const baseColor = follower.color || '#e0f2fe';
    ctx.save();
    ctx.globalAlpha = 0.9;
    const glow = ctx.createRadialGradient(follower.x, follower.y, radius*0.2, follower.x, follower.y, radius*1.4);
    glow.addColorStop(0, colorWithAlpha(baseColor, 0.85));
    glow.addColorStop(1, colorWithAlpha(baseColor, 0));
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(follower.x, follower.y, radius*1.4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.arc(follower.x, follower.y, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = shadeColor(baseColor, -0.25);
    ctx.lineWidth = 1.4;
    ctx.stroke();
    ctx.restore();
  }

  function followerMirrorShotHandler(options={}){
    const damageMultiplier = Number.isFinite(options.damageMultiplier) ? options.damageMultiplier : 1;
    const enableBrimstone = options.brimstone !== false;
    return function(follower, type, shot){
      if(type === 'tear'){
        if(!shot) return;
        const cloneOptions = {...(shot.options || {})};
        const damage = Math.max(0.01, shot.damage * damageMultiplier);
        runtime.bullets.push(new Bullet(follower.x, follower.y, shot.vx, shot.vy, shot.life, damage, cloneOptions));
      } else if(type === 'brimstone-start' && enableBrimstone){
        if(!shot) return;
        if(follower.brimstoneBeam){ endBeam(follower.brimstoneBeam); }
        const dir = shot.dir || {x:0,y:-1};
        const beam = new BrimstoneProjectile(follower, dir, {
          duration: shot.duration,
          tickFrames: shot.tickFrames,
          damageScale: shot.damageScale ?? 1,
          width: shot.width,
        });
        follower.brimstoneBeam = beam;
        if(!Array.isArray(runtime.beams)){ runtime.beams = []; }
        runtime.beams.push(beam);
      } else if(type === 'brimstone-stop' && follower.brimstoneBeam){
        endBeam(follower.brimstoneBeam);
        follower.brimstoneBeam = null;
      }
    };
  }

  function computePlayerRange(playerRef){
    const speed = playerRef?.tearSpeed ?? CONFIG.player.tearSpeed;
    const life = playerRef?.tearLife ?? CONFIG.player.tearLife;
    return Math.max(90, speed * life);
  }

  function findNearestRedHeart(playerRef){
    const room = dungeon?.current;
    if(!room) return null;
    const range = computePlayerRange(playerRef) * 0.5;
    const rangeSq = range * range;
    let best=null;
    let bestDist=Infinity;
    for(const pickup of room.pickups){
      if(!pickup || pickup.type!=='heart' || pickup.kind==='soul') continue;
      const dx = pickup.x - playerRef.x;
      const dy = pickup.y - playerRef.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= rangeSq && distSq < bestDist){
        bestDist = distSq;
        best = pickup;
      }
    }
    return best;
  }

  function spawnCollectorReward(follower){
    const room = dungeon?.current;
    if(!room) return;
    const choices = ['soul','card','key','bomb','coin'];
    const choice = choices[Math.floor(rand()*choices.length)] || 'coin';
    let pickup=null;
    if(choice==='soul'){
      pickup = makeSoulHeartPickup(follower.x, follower.y, 1);
    } else if(choice==='card'){
      const card = rollCard();
      if(card){ pickup = makeCardPickup(follower.x, follower.y, card); }
    } else {
      const amount = choice==='coin' ? 4 : 1;
      pickup = makeResourcePickup(choice, follower.x, follower.y, amount);
    }
    if(!pickup){
      pickup = makeResourcePickup('coin', follower.x, follower.y, 3);
    }
    if(pickup){
      pickup.spawnGrace = CONFIG.pickupSpawnGrace ?? 0;
      room.pickups.push(pickup);
    }
  }

  function createFollowerEntity(player, config={}){
    if(!player) return null;
    const scale = Number.isFinite(config.sizeScale) ? config.sizeScale : (1/3);
    const radius = Math.max(4, (player.r || CONFIG.player.radius || 12) * scale);
    const follower = {
      player,
      slug: config.slug || 'follower',
      name: config.name || '跟班',
      priority: Number.isFinite(config.priority) ? config.priority : 10,
      anchorToPlayer: !!config.anchorToPlayer,
      spacingMultiplier: Number.isFinite(config.spacingMultiplier) ? config.spacingMultiplier : 1,
      followSpeed: Number.isFinite(config.followSpeed) ? config.followSpeed : (player.speed * 1.1 + 60),
      damageMultiplier: Number.isFinite(config.damageMultiplier) ? config.damageMultiplier : 1,
      color: config.color || '#e0f2fe',
      behavior: config.behavior || {},
      x: player.x + (config.initialOffset?.x ?? randRange(-6,6)),
      y: player.y + (config.initialOffset?.y ?? randRange(-6,6)),
      r: radius,
    };
    const playerSpacing = (typeof player.getFollowerBaseSpacing === 'function')
      ? player.getFollowerBaseSpacing()
      : (player.r || CONFIG.player.radius || 12);
    follower.baseSpacing = Math.max(6, playerSpacing * follower.spacingMultiplier);
    follower.trailOffset = follower.baseSpacing;
    follower.draw = function(ctx){
      if(follower.behavior && typeof follower.behavior.draw === 'function'){
        follower.behavior.draw(follower, ctx, player);
        return;
      }
      followerDefaultDraw(follower, ctx);
    };
    follower.getDesiredPosition = function(owner, dt){
      if(follower.behavior && typeof follower.behavior.getAnchorPosition === 'function'){
        const pos = follower.behavior.getAnchorPosition(follower, owner, dt);
        if(pos && Number.isFinite(pos.x) && Number.isFinite(pos.y)){
          return {x:pos.x, y:pos.y};
        }
      }
      if(owner && !follower.anchorToPlayer && typeof owner.getFollowerTrailPoint === 'function'){
        const base = typeof owner.getFollowerBaseSpacing === 'function'
          ? owner.getFollowerBaseSpacing()
          : follower.baseSpacing;
        const distance = Math.max(base, follower.trailOffset || follower.baseSpacing);
        const point = owner.getFollowerTrailPoint(distance);
        if(point && Number.isFinite(point.x) && Number.isFinite(point.y)){
          return {x: point.x, y: point.y};
        }
      }
      const leader = follower.anchorToPlayer ? owner : (follower.leader || owner);
      if(!leader){
        return {x:follower.x, y:follower.y};
      }
      const dx = leader.x - follower.x;
      const dy = leader.y - follower.y;
      const dist = Math.hypot(dx, dy) || 1;
      const desired = Math.max(6, follower.baseSpacing);
      return {
        x: leader.x - (dx/dist) * desired,
        y: leader.y - (dy/dist) * desired,
      };
    };
    follower.onPlayerShot = function(type, shot, owner){
      if(follower.behavior && typeof follower.behavior.onPlayerShot === 'function'){
        follower.behavior.onPlayerShot(follower, type, shot, owner);
      }
    };
    follower.update = function(dt, owner){
      follower.damage = (owner?.damage ?? 1) * follower.damageMultiplier;
      let handled = false;
      if(follower.behavior && typeof follower.behavior.update === 'function'){
        handled = follower.behavior.update(follower, owner, dt) === true;
      }
      if(!handled){
        const target = follower.getDesiredPosition(owner, dt) || {x:follower.x,y:follower.y};
        const toX = target.x - follower.x;
        const toY = target.y - follower.y;
        const dist = Math.hypot(toX, toY);
        const speed = Math.max(40, follower.followSpeed);
        if(dist>1e-3){
          const step = Math.min(dist, speed * dt);
          follower.x += (toX/dist) * step;
          follower.y += (toY/dist) * step;
        }
      }
      if(follower.behavior && typeof follower.behavior.afterUpdate === 'function'){
        follower.behavior.afterUpdate(follower, owner, dt);
      }
    };
    return follower;
  }

  function createSideAnchorBehavior(side='left', damageMultiplier=0.75){
    const sideDir = side==='left' ? -1 : 1;
    return {
      getAnchorPosition(follower, owner){
        let nx = owner?.moveDir?.x ?? 0;
        let ny = owner?.moveDir?.y ?? -1;
        const len = Math.hypot(nx, ny);
        if(!(len>1e-4)){
          nx = 0; ny = -1;
        } else {
          nx /= len; ny /= len;
        }
        const perpX = -ny;
        const perpY = nx;
        const body = owner?.r || CONFIG.player.radius || 12;
        const sideDist = body * 1.15;
        const forward = body * 0.35;
        return {
          x: owner.x + perpX * sideDist * sideDir + nx * forward,
          y: owner.y + perpY * sideDist * sideDir + ny * forward,
        };
      },
      onPlayerShot: followerMirrorShotHandler({damageMultiplier}),
    };
  }

  function createShooterBehavior(options={}){
    const rate = Math.max(0.1, options.rate || 1);
    const cooldown = 1 / rate;
    const speedMultiplier = Number.isFinite(options.speedMultiplier) ? options.speedMultiplier : 1;
    const rangeMultiplier = Number.isFinite(options.rangeMultiplier) ? options.rangeMultiplier : 1;
    const homing = !!options.homing;
    const homingStrength = Number.isFinite(options.homingStrength) ? options.homingStrength : (homing ? 12 : 6);
    const damage = Number.isFinite(options.damage) ? options.damage : 3;
    return {
      afterUpdate(follower, owner, dt){
        follower.fireTimer = Math.max(0, (follower.fireTimer || 0) - dt);
        if(follower.fireTimer>0) return;
        const target = acquireNearestEnemy(follower);
        if(!target) return;
        const dx = target.x - follower.x;
        const dy = target.y - follower.y;
        const len = Math.hypot(dx, dy);
        if(!(len>1e-4)) return;
        const baseSpeed = (owner?.tearSpeed ?? CONFIG.player.tearSpeed) * speedMultiplier;
        const vx = (dx/len) * baseSpeed;
        const vy = (dy/len) * baseSpeed;
        const life = Math.max(0.2, (owner?.tearLife ?? CONFIG.player.tearLife) * rangeMultiplier);
        const options = {homing, homingStrength};
        runtime.bullets.push(new Bullet(follower.x, follower.y, vx, vy, life, damage, options));
        follower.fireTimer = cooldown;
      }
    };
  }

  function createAuntBehavior(){
    const MAX_CHARGE = 2.2;
    const MIN_CHARGE = 0.25;
    const FLASH_INTERVAL = 0.12;
    return {
      update(follower, owner, dt){
        if(follower.brimstoneBeam && follower.brimstoneBeam.alive === false){
          follower.brimstoneBeam = null;
        }
        if(follower.brimstoneBeam){
          follower.beamTimer = Math.max(0, (follower.beamTimer || 0) - dt);
          if(follower.beamTimer<=0){
            endBeam(follower.brimstoneBeam);
            follower.brimstoneBeam = null;
          }
          follower.charging = false;
          follower.chargeProgress = 0;
          follower.flashOn = false;
          return false;
        }
        const state = follower.auntState || (follower.auntState = {charge:0, flash:0, dir:{x:0,y:-1}, charging:false});
        const shot = owner?.getShotInput?.() || owner?.shotInput || null;
        const pressed = !!(shot && shot.pressed);
        if(pressed){
          state.charging = true;
          const dirX = Number.isFinite(shot.dirX) ? shot.dirX : (shot.lastDirX ?? 0);
          const dirY = Number.isFinite(shot.dirY) ? shot.dirY : (shot.lastDirY ?? -1);
          const len = Math.hypot(dirX, dirY);
          if(len>1e-4){
            state.dir.x = dirX / len;
            state.dir.y = dirY / len;
          }
          state.charge = Math.min(MAX_CHARGE, state.charge + dt);
          follower.chargeProgress = clamp(state.charge / MAX_CHARGE, 0, 1);
          state.flash = (state.flash || 0) + dt;
          if(state.flash >= FLASH_INTERVAL){
            follower.flashOn = !follower.flashOn;
            state.flash = 0;
          }
          follower.charging = true;
        } else {
          if(state.charging){
            const len = Math.hypot(state.dir.x, state.dir.y);
            if(len>1e-4 && state.charge >= MIN_CHARGE){
              follower.pendingBeam = {
                dirX: state.dir.x / len,
                dirY: state.dir.y / len,
                chargeProgress: clamp(state.charge / MAX_CHARGE, 0, 1),
              };
            }
          }
          state.charging = false;
          state.charge = 0;
          state.flash = 0;
          follower.charging = false;
          follower.flashOn = false;
          follower.chargeProgress = 0;
        }
        return false;
      },
      afterUpdate(follower, owner){
        if(!follower.pendingBeam || follower.brimstoneBeam){
          return;
        }
        const payload = follower.pendingBeam;
        follower.pendingBeam = null;
        const len = Math.hypot(payload.dirX, payload.dirY);
        if(!(len>1e-4)){
          return;
        }
        const dir = {x: payload.dirX / len, y: payload.dirY / len};
        const baseWidth = (owner?.r || CONFIG.player.radius || 12) * 1.1;
        const chargeRatio = clamp(payload.chargeProgress || 0, 0, 1);
        const width = baseWidth * (1 + chargeRatio * 0.35);
        const damageScale = 0.75 + chargeRatio * 0.15;
        const duration = 1.5 + chargeRatio * 0.2;
        follower.damage = 1;
        const beam = new BrimstoneProjectile(follower, dir, {
          duration,
          tickFrames: 8,
          damageScale,
          width,
        });
        follower.brimstoneBeam = beam;
        follower.beamTimer = duration;
        follower.flashOn = false;
        follower.charging = false;
        follower.chargeProgress = 0;
        if(!Array.isArray(runtime.beams)){ runtime.beams = []; }
        runtime.beams.push(beam);
      },
      draw(follower, ctx){
        const radius = follower.r || 6;
        const progress = clamp(follower.chargeProgress || 0, 0, 1);
        const baseColor = '#fca5a5';
        const chargedColor = '#dc2626';
        const mixed = mixHexColor(baseColor, chargedColor, progress);
        const fillColor = follower.flashOn ? shadeColor(mixed, 0.25) : mixed;
        ctx.save();
        if(progress>0){
          const glow = ctx.createRadialGradient(
            follower.x,
            follower.y,
            radius * 0.4,
            follower.x,
            follower.y,
            radius * (1.8 + progress * 0.4)
          );
          glow.addColorStop(0, colorWithAlpha(shadeColor(fillColor, 0.4), 0.9));
          glow.addColorStop(1, colorWithAlpha(fillColor, 0));
          ctx.fillStyle = glow;
          ctx.globalAlpha = 0.75;
          ctx.beginPath();
          ctx.arc(follower.x, follower.y, radius * (1.4 + progress * 0.6), 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.arc(follower.x, follower.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = shadeColor(fillColor, -0.35);
        ctx.lineWidth = 1.4 + progress * 0.4;
        ctx.stroke();
        ctx.restore();
      },
      onRoomEntered(follower){
        follower.pendingBeam = null;
        if(follower.brimstoneBeam){
          endBeam(follower.brimstoneBeam);
          follower.brimstoneBeam = null;
        }
        if(follower.auntState){
          follower.auntState.charge = 0;
          follower.auntState.flash = 0;
          follower.auntState.charging = false;
        }
        follower.charging = false;
        follower.flashOn = false;
        follower.chargeProgress = 0;
      }
    };
  }

  function createCollectorBehavior(){
    return {
      update(follower, owner, dt){
        const room = dungeon?.current;
        if(!room) return false;
        if(follower.collectTarget && !room.pickups.includes(follower.collectTarget)){
          follower.collectTarget = null;
        }
        if(!follower.collectTarget){
          follower.collectTarget = findNearestRedHeart(owner);
        }
        if(follower.collectTarget){
          const target = follower.collectTarget;
          const dx = target.x - follower.x;
          const dy = target.y - follower.y;
          const dist = Math.hypot(dx, dy);
          const speed = Math.max(60, owner.speed * 0.75);
          if(dist>1e-3){
            const step = Math.min(dist, speed * dt);
            follower.x += (dx/dist) * step;
            follower.y += (dy/dist) * step;
          }
          if(dist <= (follower.r + (target.r || 10) + 2)){
            const wasteEnabled = true;
            const result = tryPlayerCollectHeart(target, {allowWaste:wasteEnabled});
            if(result && result.collected){
              if(result.consumed){
                const arr = room.pickups;
                const idx = arr.indexOf(target);
                if(idx>=0) arr.splice(idx,1);
              }
              if(result.gained || wasteEnabled){
                follower.collectedHearts = (follower.collectedHearts || 0) + 1;
                if(follower.collectedHearts >= 3){
                  spawnCollectorReward(follower);
                  follower.collectedHearts = 0;
                }
              }
            }
            follower.collectTarget = null;
          }
          return true;
        }
        return false;
      },
      draw(follower, ctx){
        const radius = follower.r || 6;
        ctx.save();
        ctx.fillStyle = '#1f2937';
        ctx.beginPath();
        ctx.arc(follower.x, follower.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#fbbf24';
        ctx.lineWidth = 1.2;
        ctx.stroke();
        ctx.restore();
      },
      onRoomEntered(follower){
        follower.collectTarget = null;
        if(follower.pendingBeam){ follower.pendingBeam = null; }
      }
    };
  }

  function grantBrotherFollower(player){
    if(!player?.addFollower) return;
    player.addFollower({
      slug:'brother',
      name:'兄弟',
      priority:1,
      anchorToPlayer:false,
      spacingMultiplier:0.9,
      damageMultiplier:1,
      color:'#fde68a',
      behavior:{
        onPlayerShot: followerMirrorShotHandler({damageMultiplier:1}),
      }
    });
  }

  function grantSisterFollowers(player){
    if(!player?.addFollower) return;
    player.addFollower({
      slug:'sister-left',
      name:'姐妹',
      priority:0,
      anchorToPlayer:true,
      spacingMultiplier:0.8,
      damageMultiplier:0.75,
      color:'#fda4af',
      behavior: createSideAnchorBehavior('left', 0.75),
    });
    player.addFollower({
      slug:'sister-right',
      name:'姐妹',
      priority:0,
      anchorToPlayer:true,
      spacingMultiplier:0.8,
      damageMultiplier:0.75,
      color:'#bfdbfe',
      behavior: createSideAnchorBehavior('right', 0.75),
    });
    player.rebuildFollowerOrder();
  }

  function grantCousinFollower(player){
    if(!player?.addFollower) return;
    player.addFollower({
      slug:'cousin',
      name:'表哥',
      priority:2,
      spacingMultiplier:1.1,
      color:'#a5b4fc',
      behavior: createShooterBehavior({damage:5, rate:2, speedMultiplier:2, rangeMultiplier:2, homing:true, homingStrength:14}),
    });
  }

  function grantYoungerCousinFollower(player){
    if(!player?.addFollower) return;
    player.addFollower({
      slug:'younger-cousin',
      name:'表弟',
      priority:3,
      spacingMultiplier:1.2,
      color:'#bbf7d0',
      behavior: createShooterBehavior({damage:4, rate:3, speedMultiplier:1.5, rangeMultiplier:1.5, homing:false}),
    });
  }

  function grantAuntFollower(player){
    if(!player?.addFollower) return;
    player.addFollower({
      slug:'aunt-brimstone',
      name:'大姨妈',
      priority:3,
      spacingMultiplier:1.2,
      color:'#fca5a5',
      behavior: createAuntBehavior(),
    });
  }

  function grantCollectorFollower(player){
    if(!player?.addFollower) return;
    player.addFollower({
      slug:'black-buddy',
      name:'黑屁股',
      priority:6,
      anchorToPlayer:false,
      spacingMultiplier:1.2,
      color:'#1f2937',
      behavior: createCollectorBehavior(),
    });
  }


  const TEAR_RADIUS_BASE = 5;
  const TEAR_RADIUS_GROWTH = 3.2;
  function calcTearRadius(damage){
    // 参考以撒的结合的弹丸成长：使用平方根降低增长曲线的坡度，避免数值过激
    const dmg = Math.max(0.25, damage);
    return TEAR_RADIUS_BASE + TEAR_RADIUS_GROWTH * (Math.sqrt(dmg) - 1);
  }

  class Bullet{
    constructor(x,y,vx,vy,life,damage=1,options={}){
      this.x=x;
      this.y=y;
      this.vx=vx;
      this.vy=vy;
      this.life=life;
      this.damage=damage;
      this.alive=true;
      this.r=calcTearRadius(damage);
      this.pierceObstacles = !!options.pierce;
      this.pierceEnemies = !!options.pierceEnemies;
      this.homing = !!options.homing;
      this.homingStrength = Number.isFinite(options.homingStrength) ? Math.max(0, options.homingStrength) : 6;
      this.color = typeof options.color === 'string' ? options.color : '#a6e3ff';
      this.trailColor = typeof options.trailColor === 'string' ? options.trailColor : null;
      if(this.pierceEnemies){
        this.hitEnemies = new WeakSet();
      }
      if(options && options.holyAura){
        const auraOpts = options.holyAura;
        const radiusMultiplier = Math.max(0.5, Number(auraOpts.radiusMultiplier) || 3);
        const interval = Math.max(1/120, Number(auraOpts.interval) || (8/60));
        const damageRatio = Math.max(0, Number(auraOpts.damageRatio) || 0.4);
        const fillColor = typeof auraOpts.fillColor === 'string' ? auraOpts.fillColor : '#fef9c3';
        const strokeColor = typeof auraOpts.strokeColor === 'string' ? auraOpts.strokeColor : '#fde68a';
        const playerRef = auraOpts.player || null;
        this.holyAura = {
          radiusMultiplier,
          interval,
          timer: interval,
          damageRatio,
          fillColor,
          strokeColor,
          player: playerRef,
          pulse: 0,
        };
      }
    }
    destroy(options={}){
      if(!this.alive) return;
      this.alive = false;
      const count = Math.max(4, Math.round(4 + Math.sqrt(Math.max(this.damage, 0.25)) * 1.5));
      spawnBulletDisperse(this.x, this.y, {
        color: this.color,
        accent: this.trailColor,
        count,
        radius: this.r,
        speed: 120 + this.r * 9,
        glowStrength: 0.75 + Math.min(0.6, this.damage * 0.08),
        ...options,
      });
    }
    update(dt){
      if(this.homing){
        const room = dungeon?.current;
        if(room){
          let target=null;
          let best=Infinity;
          for(const enemy of room.enemies){
            if(enemy.dead) continue;
            const d = dist(this, enemy);
            if(d < best){ best = d; target = enemy; }
          }
          if(target){
            const speed = Math.hypot(this.vx, this.vy);
            if(speed>1e-3){
              const toX = target.x - this.x;
              const toY = target.y - this.y;
              const len = Math.hypot(toX,toY) || 1;
              const nx = toX / len;
              const ny = toY / len;
              const curX = this.vx / speed;
              const curY = this.vy / speed;
              const turn = clamp(this.homingStrength * dt, 0, 1);
              const mixX = curX*(1-turn) + nx*turn;
              const mixY = curY*(1-turn) + ny*turn;
              const mixLen = Math.hypot(mixX, mixY) || 1;
              this.vx = (mixX/mixLen) * speed;
              this.vy = (mixY/mixLen) * speed;
            }
          }
        }
      }
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
      if(this.life<=0){ this.destroy(); return; }
      if(this.x<0||this.x>CONFIG.roomW||this.y<0||this.y>CONFIG.roomH){ this.destroy(); return; }
      if(!this.pierceObstacles){
        for(const obs of dungeon.current.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(this, obs)){ this.destroy({glowStrength:0.45}); break; }
        }
      }
      if(this.holyAura){
        this.updateHolyAura(dt);
      }
    }
    hasHitEnemy(enemy){
      if(!this.pierceEnemies || !enemy) return false;
      if(!this.hitEnemies){ this.hitEnemies = new WeakSet(); }
      return this.hitEnemies.has(enemy);
    }
    markEnemyHit(enemy){
      if(!this.pierceEnemies || !enemy) return;
      if(!this.hitEnemies){ this.hitEnemies = new WeakSet(); }
      this.hitEnemies.add(enemy);
    }
    draw(){
      const baseColor = this.color || '#a6e3ff';
      const highlight = shadeColor(baseColor, 0.28);
      const shadow = shadeColor(baseColor, -0.35);
      ctx.save();
      if(this.holyAura){
        this.drawHolyAura();
      }
      const gradient = ctx.createRadialGradient(
        this.x - this.r*0.25,
        this.y - this.r*0.32,
        Math.max(0.6, this.r*0.12),
        this.x,
        this.y,
        this.r
      );
      gradient.addColorStop(0, colorWithAlpha(highlight, 0.95));
      gradient.addColorStop(0.55, colorWithAlpha(baseColor, 0.8));
      gradient.addColorStop(1, colorWithAlpha(shadow, 0.35));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.95;
      ctx.strokeStyle = colorWithAlpha(shadow, 0.88);
      ctx.lineWidth = Math.max(1.1, this.r * 0.32);
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*0.66, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
    updateHolyAura(dt){
      const aura = this.holyAura;
      if(!aura) return;
      const playerRef = aura.player;
      const room = dungeon?.current;
      aura.pulse += dt;
      aura.timer -= dt;
      const radius = Math.max(this.r * aura.radiusMultiplier, this.r * 1.2);
      aura.radius = radius;
      if(!room || !Array.isArray(room.enemies) || !playerRef){
        return;
      }
      const damageBase = Math.max(0.01, (playerRef.damage || 0) * aura.damageRatio);
      while(aura.timer <= 0){
        aura.timer += aura.interval;
        if(damageBase <= 0){
          continue;
        }
        for(const enemy of room.enemies){
          if(!enemy || enemy.dead) continue;
          const range = radius + (enemy.r || 0);
          if(dist(this, enemy) <= range){
            const killed = enemy.damage ? enemy.damage(damageBase) : false;
            if(killed){
              handleEnemyDeath(enemy, room);
            } else if(typeof enemy.damageFlashTimer === 'number'){
              enemy.damageFlashTimer = Math.max(enemy.damageFlashTimer, 0.08);
            }
          }
        }
      }
    }
    drawHolyAura(){
      const aura = this.holyAura;
      if(!aura || !aura.radius) return;
      const radius = aura.radius;
      const pulsePhase = aura.pulse || 0;
      const alpha = 0.22 + 0.12 * Math.sin(pulsePhase * 6.5);
      const outerAlpha = 0.28 + 0.18 * Math.sin((pulsePhase + 0.6) * 5.2);
      ctx.save();
      ctx.globalAlpha = clamp(alpha, 0.05, 0.6);
      const fill = ctx.createRadialGradient(this.x, this.y, radius*0.1, this.x, this.y, radius);
      fill.addColorStop(0, colorWithAlpha(aura.fillColor || '#fef9c3', 0.9));
      fill.addColorStop(1, colorWithAlpha(aura.fillColor || '#fef9c3', 0));
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = clamp(outerAlpha, 0.1, 0.75);
      ctx.strokeStyle = colorWithAlpha(aura.strokeColor || '#fde68a', 0.85);
      ctx.lineWidth = Math.max(1.2, radius * 0.12);
      ctx.beginPath();
      ctx.arc(this.x, this.y, radius * 0.82, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  class CompressedPeachSeed{
    constructor({player,x,y,vx,vy,damage,life,travelDistance,fragmentConfig,color,trailColor,holyAura}){
      this.player = player || null;
      this.x = Number.isFinite(x) ? x : 0;
      this.y = Number.isFinite(y) ? y : 0;
      this.prevX = this.x;
      this.prevY = this.y;
      this.vx = Number.isFinite(vx) ? vx : 0;
      this.vy = Number.isFinite(vy) ? vy : 0;
      this.damage = Math.max(0.05, Number(damage) || 1);
      this.r = calcTearRadius(this.damage);
      this.life = Math.max(0.1, Number(life) || 0.8);
      this.remainingLife = this.life;
      this.travelDistance = Math.max(20, Number(travelDistance) || 80);
      this.traveled = 0;
      this.alive = true;
      this.pierceObstacles = true;
      this.pierceEnemies = true;
      this.hitEnemies = new WeakSet();
      this.color = typeof color === 'string' ? color : '#f9a8d4';
      this.trailColor = typeof trailColor === 'string' ? trailColor : '#f472b6';
      this.fragmentConfig = fragmentConfig || null;
      if(holyAura){
        const aura = {...holyAura};
        aura.player = aura.player || this.player;
        aura.timer = Math.max(0.01, Number(aura.timer) || Number(aura.interval) || 0.1);
        aura.pulse = aura.pulse || 0;
        this.holyAura = aura;
      } else {
        this.holyAura = null;
      }
    }
    hasHitEnemy(enemy){
      if(!this.pierceEnemies || !enemy) return false;
      return this.hitEnemies?.has(enemy) || false;
    }
    markEnemyHit(enemy){
      if(!this.pierceEnemies || !enemy) return;
      this.hitEnemies?.add?.(enemy);
    }
    update(dt){
      if(!this.alive) return;
      this.prevX = this.x;
      this.prevY = this.y;
      const dx = this.vx * dt;
      const dy = this.vy * dt;
      this.x += dx;
      this.y += dy;
      const step = Math.hypot(dx, dy);
      this.traveled += step;
      this.remainingLife = Math.max(0, this.remainingLife - dt);
      if(this.holyAura){
        this.updateHolyAura(dt);
      }
      if(this.traveled >= this.travelDistance){
        this.split();
        return;
      }
      if(this.remainingLife <= 0){
        this.destroy();
      }
    }
    split(){
      if(!this.alive) return;
      const config = this.fragmentConfig;
      if(config && runtime?.bullets){
        const angles = Array.isArray(config.spreadAngles) && config.spreadAngles.length ? config.spreadAngles : [0];
        const baseAngle = Math.atan2(this.vy, this.vx);
        const remainLife = Math.max(0.12, config.life || this.remainingLife || 0.3);
        for(const offset of angles){
          const angle = baseAngle + offset;
          const speed = Math.max(40, Number(config.fragmentSpeed) || 80);
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const frag = new CompressedPeachFragment({
            player: config.player || this.player,
            x: this.x,
            y: this.y,
            vx,
            vy,
            damage: config.damage,
            life: remainLife,
            travelBeforeOrbit: config.travelBeforeOrbit,
            orbitRadius: config.orbitRadius,
            orbitAmplitude: config.orbitAmplitude,
            orbitSpeed: config.orbitSpeed,
            oscillationSpeed: config.oscillationSpeed,
            color: config.color,
            trailColor: config.trailColor,
            holyAura: config.holyAura,
          });
          runtime.bullets.push(frag);
        }
        spawnBulletDisperse(this.x, this.y, {
          color:this.color,
          accent:this.trailColor,
          radius:this.r*0.9,
          count:10,
          speed:140,
          glowStrength:0.65,
        });
      }
      this.destroy({silent:true});
    }
    destroy(options={}){
      if(!this.alive) return;
      this.alive = false;
      if(options.silent) return;
      spawnBulletDisperse(this.x, this.y, {
        color:this.color,
        accent:this.trailColor,
        radius:this.r,
        count:8,
        speed:110,
        glowStrength:0.55,
      });
    }
    draw(){
      if(!this.alive) return;
      const baseColor = this.color || '#f9a8d4';
      const highlight = shadeColor(baseColor, 0.2);
      const shadow = shadeColor(baseColor, -0.35);
      ctx.save();
      if(this.holyAura){
        this.drawHolyAura();
      }
      const gradient = ctx.createRadialGradient(
        this.x - this.r*0.25,
        this.y - this.r*0.32,
        Math.max(0.6, this.r*0.15),
        this.x,
        this.y,
        this.r
      );
      gradient.addColorStop(0, colorWithAlpha(highlight, 0.95));
      gradient.addColorStop(0.5, colorWithAlpha(baseColor, 0.82));
      gradient.addColorStop(1, colorWithAlpha(shadow, 0.38));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = colorWithAlpha(this.trailColor || baseColor, 0.9);
      ctx.lineWidth = Math.max(1.2, this.r * 0.34);
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*0.58, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  class CompressedPeachFragment{
    constructor({player,x,y,vx,vy,damage,life,travelBeforeOrbit,orbitRadius,orbitAmplitude,orbitSpeed,oscillationSpeed,color,trailColor,holyAura}){
      this.player = player || null;
      this.x = Number.isFinite(x) ? x : 0;
      this.y = Number.isFinite(y) ? y : 0;
      this.prevX = this.x;
      this.prevY = this.y;
      this.vx = Number.isFinite(vx) ? vx : 0;
      this.vy = Number.isFinite(vy) ? vy : 0;
      this.damage = Math.max(0.05, Number(damage) || 1);
      this.r = calcTearRadius(this.damage) * 0.9;
      this.life = Math.max(0.15, Number(life) || 0.6);
      this.remainingLife = this.life;
      this.travelBeforeOrbit = Math.max(16, Number(travelBeforeOrbit) || 60);
      this.traveled = 0;
      this.phase = 0;
      this.anchorX = this.x;
      this.anchorY = this.y;
      this.orbitRadius = Math.max(20, Number(orbitRadius) || 48);
      this.orbitAmplitude = Math.max(4, Number(orbitAmplitude) || 14);
      this.orbitSpeed = Math.max(0.2, Number(orbitSpeed) || Math.PI*0.8);
      this.oscillationSpeed = Math.max(0.2, Number(oscillationSpeed) || Math.PI);
      this.oscTimer = 0;
      this.pierceObstacles = true;
      this.pierceEnemies = true;
      this.hitEnemies = new WeakSet();
      this.alive = true;
      this.color = typeof color === 'string' ? color : '#fda4af';
      this.trailColor = typeof trailColor === 'string' ? trailColor : '#fb7185';
      if(holyAura){
        const aura = {...holyAura};
        aura.player = aura.player || this.player;
        aura.timer = Math.max(0.01, Number(aura.timer) || Number(aura.interval) || 0.1);
        aura.pulse = aura.pulse || 0;
        this.holyAura = aura;
      } else {
        this.holyAura = null;
      }
    }
    hasHitEnemy(enemy){
      if(!this.pierceEnemies || !enemy) return false;
      return this.hitEnemies?.has(enemy) || false;
    }
    markEnemyHit(enemy){
      if(!this.pierceEnemies || !enemy) return;
      this.hitEnemies?.add?.(enemy);
    }
    update(dt){
      if(!this.alive) return;
      this.prevX = this.x;
      this.prevY = this.y;
      this.remainingLife = Math.max(0, this.remainingLife - dt);
      if(this.remainingLife <= 0){
        this.destroy();
        return;
      }
      if(this.phase === 0){
        const dx = this.vx * dt;
        const dy = this.vy * dt;
        this.x += dx;
        this.y += dy;
        this.traveled += Math.hypot(dx, dy);
        if(this.traveled >= this.travelBeforeOrbit){
          this.phase = 1;
          this.anchorX = this.x;
          this.anchorY = this.y;
          this.oscTimer = 0;
          this.orbitAngle = Math.atan2(this.vy, this.vx);
        }
      }
      if(this.phase === 1){
        this.oscTimer += dt;
        this.orbitAngle -= this.orbitSpeed * dt;
        const radius = this.orbitRadius + Math.sin(this.oscTimer * this.oscillationSpeed) * this.orbitAmplitude;
        this.x = this.anchorX + Math.cos(this.orbitAngle) * radius;
        this.y = this.anchorY + Math.sin(this.orbitAngle) * radius;
      }
      if(this.holyAura){
        this.updateHolyAura(dt);
      }
      if(dt>0){
        this.vx = (this.x - this.prevX) / dt;
        this.vy = (this.y - this.prevY) / dt;
      }
      if(this.phase === 1){
        const margin = 12;
        if(this.x < -margin || this.x > CONFIG.roomW + margin || this.y < -margin || this.y > CONFIG.roomH + margin){
          this.destroy();
        }
      }
    }
    destroy(){
      if(!this.alive) return;
      this.alive = false;
      spawnBulletDisperse(this.x, this.y, {
        color:this.color,
        accent:this.trailColor,
        radius:this.r*0.85,
        count:6,
        speed:100,
        glowStrength:0.5,
      });
    }
    draw(){
      if(!this.alive) return;
      const baseColor = this.color || '#fda4af';
      const highlight = shadeColor(baseColor, 0.22);
      const shadow = shadeColor(baseColor, -0.4);
      ctx.save();
      if(this.holyAura){
        this.drawHolyAura();
      }
      const gradient = ctx.createRadialGradient(
        this.x - this.r*0.3,
        this.y - this.r*0.35,
        Math.max(0.5, this.r*0.18),
        this.x,
        this.y,
        this.r
      );
      gradient.addColorStop(0, colorWithAlpha(highlight, 0.98));
      gradient.addColorStop(0.6, colorWithAlpha(baseColor, 0.82));
      gradient.addColorStop(1, colorWithAlpha(shadow, 0.35));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      const tailAlpha = this.phase === 1 ? 0.7 : 0.4;
      ctx.globalAlpha = tailAlpha;
      ctx.strokeStyle = colorWithAlpha(this.trailColor || baseColor, tailAlpha);
      ctx.lineWidth = Math.max(1.1, this.r * 0.42);
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x - this.vx * 0.03, this.y - this.vy * 0.03);
      ctx.stroke();
      ctx.restore();
    }
  }

  if(Bullet?.prototype){
    CompressedPeachSeed.prototype.updateHolyAura = Bullet.prototype.updateHolyAura;
    CompressedPeachSeed.prototype.drawHolyAura = Bullet.prototype.drawHolyAura;
    CompressedPeachFragment.prototype.updateHolyAura = Bullet.prototype.updateHolyAura;
    CompressedPeachFragment.prototype.drawHolyAura = Bullet.prototype.drawHolyAura;
  }

  class Bomb{
    constructor(x,y,options={}){
      const opts = options || {};
      this.x=x;
      this.y=y;
      this.r=14;
      this.timer=Number.isFinite(opts.fuse) ? opts.fuse : CONFIG.bomb.fuse;
      this.exploded=false;
      this.explosionTimer=0;
      this.done=false;
      this.vx=0;
      this.vy=0;
      this.owner = opts.owner || null;
      const usePlayerStats = !this.owner || this.owner === 'player';
      this.spawnGrace = Number.isFinite(opts.spawnGrace)
        ? opts.spawnGrace
        : (CONFIG.bomb.spawnGrace ?? CONFIG.pickupSpawnGrace ?? 0);
      const radiusMultiplier = Number.isFinite(opts.radiusMultiplier)
        ? opts.radiusMultiplier
        : (usePlayerStats ? (player?.bombRadiusMultiplier ?? 1) : 1);
      const damageMultiplier = Number.isFinite(opts.damageMultiplier)
        ? opts.damageMultiplier
        : (usePlayerStats ? (player?.bombDamageMultiplier ?? 1) : 1);
      this.radiusMultiplier = Math.max(0, radiusMultiplier);
      this.damageMultiplier = Math.max(0, damageMultiplier);
      this.shakeStrength = Number.isFinite(opts.shakeStrength)
        ? opts.shakeStrength
        : (usePlayerStats ? (player?.bombShakeStrength ?? 0) : 0);
      const baseRadius = Number.isFinite(opts.baseRadius) ? opts.baseRadius : CONFIG.bomb.radius;
      this.explosionRadius = baseRadius * this.radiusMultiplier;
      this.customDamage = Number.isFinite(opts.customDamage) ? opts.customDamage : null;
      this.customKnock = Number.isFinite(opts.customKnock) ? opts.customKnock : null;
      this.damageSource = opts.damageSource || null;
    }
    update(dt){
      if(this.done) return;
      if(this.spawnGrace>0){ this.spawnGrace = Math.max(0, this.spawnGrace - dt); }
      if(this.exploded){
        this.explosionTimer = Math.max(0, this.explosionTimer - dt);
        if(this.explosionTimer<=0){ this.done=true; }
        return;
      }
      this.integrateMotion(dt);
      this.timer -= dt;
      if(this.timer<=0){ this.explode(); }
    }
    integrateMotion(dt){
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      const drag = Math.exp(-dt*4.2);
      this.vx *= drag;
      this.vy *= drag;
      if(Math.abs(this.vx) < 1e-2) this.vx = 0;
      if(Math.abs(this.vy) < 1e-2) this.vy = 0;
      keepBombInBounds(this);
      if(this.spawnGrace<=0){
        resolveBombObstacles(this);
      }
    }
    applyImpulse(dx,dy,strength){
      if(this.done || this.exploded) return;
      const len = Math.hypot(dx,dy) || 0.0001;
      const power = strength ?? CONFIG.bomb.knock;
      this.vx += (dx/len) * power;
      this.vy += (dy/len) * power;
      const speed = Math.hypot(this.vx, this.vy);
      const maxSpeed = 480;
      if(speed > maxSpeed){
        const scale = maxSpeed / speed;
        this.vx *= scale;
        this.vy *= scale;
      }
    }
    explode(){
      if(this.exploded) return;
      this.exploded=true;
      this.explosionTimer = 0.4;
      this.vx = 0;
      this.vy = 0;
      handleBombExplosion(dungeon.current, this);
    }
    draw(){
      if(this.exploded){
        const ratio = this.explosionTimer / 0.4;
        const baseRadius = this.explosionRadius || (CONFIG.bomb.radius * (this.radiusMultiplier || 1));
        const radius = baseRadius * (1 + (1-ratio)*0.2);
        ctx.save();
        ctx.globalAlpha = Math.max(0, ratio*0.7);
        const g = ctx.createRadialGradient(this.x,this.y,radius*0.15,this.x,this.y,radius);
        g.addColorStop(0,'#fff5');
        g.addColorStop(0.4,'#ffd5');
        g.addColorStop(1,'#ff4d');
        ctx.fillStyle=g;
        ctx.beginPath(); ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = Math.max(0, ratio*0.9);
        ctx.strokeStyle='#ffe4';
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,radius*0.55,0,Math.PI*2); ctx.stroke();
        ctx.restore();
        return;
      }
      const progress = Math.max(0, CONFIG.bomb.fuse - this.timer);
      const freq = 2 + progress*6;
      const pulse = Math.sin(progress*freq*Math.PI) > 0 ? '#ff6b6b' : '#ffffff';
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = '#2f3345';
      ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = pulse;
      ctx.beginPath(); ctx.arc(0,0,this.r*0.7,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2f3345';
      ctx.fillRect(-2,-this.r*1.1,4,this.r*0.6);
      ctx.restore();
    }
  }

  class BrimstoneProjectile{
    constructor(owner, dir, options={}){
      this.owner = owner;
      const norm = Math.hypot(dir?.x ?? 0, dir?.y ?? 0) || 1;
      this.dir = {x:(dir?.x ?? 0)/norm, y:(dir?.y ?? -1)/norm};
      const duration = Number.isFinite(options.duration) ? Math.max(0.05, options.duration) : (CONFIG.brimstone?.beamDuration ?? 2);
      this.timer = duration;
      this.totalDuration = duration;
      const rawTick = Number.isFinite(options.tickFrames) ? options.tickFrames : (CONFIG.brimstone?.tickFrames ?? 15);
      const tickFrames = Math.max(1, rawTick);
      this.tickInterval = tickFrames / 60;
      this.tickTimer = 0;
      this.damageScale = Number.isFinite(options.damageScale) ? options.damageScale : (CONFIG.brimstone?.damageScale ?? 0.7);
      const ownerRadius = owner?.r ?? 18;
      const offset = Number.isFinite(options.startOffset) ? options.startOffset : (ownerRadius + Math.max(ownerRadius*0.2, 6));
      this.startOffset = offset;
      this.widthOverride = options.width;
      this.alive = true;
      this.homing = !!options.homing;
      const homingDefault = Number.isFinite(options.homingStrength) ? options.homingStrength : (owner?.homingStrength ?? 10);
      this.homingStrength = Math.max(0, homingDefault);
      this.visualSeed = rand();
      this.sparkTimers = {start:0,end:0};
      this.sparkStartInterval = Math.max(0.02, Number(options.sparkStartInterval) || 0.045);
      this.sparkEndInterval = Math.max(0.025, Number(options.sparkEndInterval) || 0.055);
      this.wobblePhase = rand()*Math.PI*2;
    }
    getWidth(){
      if(Number.isFinite(this.widthOverride)) return this.widthOverride;
      if(this.owner && typeof this.owner.getBrimstoneWidth === 'function'){
        const width = this.owner.getBrimstoneWidth();
        if(Number.isFinite(width) && width>0) return width;
      }
      return 24;
    }
    getGeometry(){
      return computeBeamGeometry({owner:this.owner, dir:this.dir, startOffset:this.startOffset});
    }
    applyDamage(){
      const room = dungeon?.current;
      if(!room || !this.owner) return;
      const geom = this.getGeometry();
      if(!geom || geom.length<=0) return;
      const enemies = room.enemies;
      const half = Math.max(4, this.getWidth() * 0.5);
      const damageValue = Math.max(0, (this.owner?.damage ?? 1) * this.damageScale);
      for(const enemy of enemies){
        if(enemy.dead) continue;
        const result = pointSegmentDistance(enemy.x, enemy.y, geom.startX, geom.startY, geom.endX, geom.endY);
        const threshold = half + (enemy.r || 12);
        if(result.distance <= threshold){
          if(enemy.damage(damageValue)){ handleEnemyDeath(enemy, room); }
        }
      }
    }
    updateHoming(dt){
      if(!this.homing || !this.owner) return;
      const room = dungeon?.current;
      if(!room) return;
      let target=null;
      let best=Infinity;
      for(const enemy of room.enemies){
        if(enemy.dead) continue;
        const dx = enemy.x - this.owner.x;
        const dy = enemy.y - this.owner.y;
        const d = Math.hypot(dx,dy);
        if(d < best){ best = d; target = enemy; }
      }
      if(!target) return;
      const toX = target.x - this.owner.x;
      const toY = target.y - this.owner.y;
      const len = Math.hypot(toX,toY) || 1;
      const nx = toX / len;
      const ny = toY / len;
      const curLen = Math.hypot(this.dir.x, this.dir.y) || 1;
      const curX = this.dir.x / curLen;
      const curY = this.dir.y / curLen;
      const turn = clamp(this.homingStrength * dt, 0, 1);
      const mixX = curX*(1-turn) + nx*turn;
      const mixY = curY*(1-turn) + ny*turn;
      const mixLen = Math.hypot(mixX, mixY) || 1;
      this.dir.x = mixX / mixLen;
      this.dir.y = mixY / mixLen;
    }
    update(dt){
      if(!this.owner){ this.finish(); return; }
      this.timer -= dt;
      if(this.owner){
        this.owner.brimstoneBeamTimer = Math.max(0, this.timer);
        this.owner.brimstoneFiring = this.timer>0;
      }
      if(this.timer <= 0){ this.finish(); return; }
      this.updateHoming(dt);
      this.wobblePhase = (this.wobblePhase || 0) + dt * 2.8;
      if(this.wobblePhase > Math.PI * 200){ this.wobblePhase -= Math.PI * 200; }
      this.tickTimer -= dt;
      if(this.tickTimer <= 0){
        this.tickTimer += this.tickInterval;
        this.applyDamage();
        audio.play('brimstoneTick', {volume: 0.35});
      }
      const timers = this.sparkTimers;
      if(timers){
        timers.start -= dt;
        timers.end -= dt;
        const needStart = timers.start <= 0;
        const needEnd = timers.end <= 0;
        if(needStart || needEnd){
          const geom = this.getGeometry();
          if(geom && geom.length>0){
            const width = Math.max(6, this.getWidth());
            if(needStart){
              timers.start = randRange(this.sparkStartInterval*0.5, this.sparkStartInterval*1.25);
              spawnBeamSparkBurst(geom.startX, geom.startY, {
                dir: this.dir,
                speed: 260,
                count: Math.max(4, Math.round(width/6)),
                radius: width*0.45,
                color: '#fb923c',
                accent: '#fde68a',
                life: 0.32,
                flow: 1,
              });
            }
            if(needEnd){
              timers.end = randRange(this.sparkEndInterval*0.6, this.sparkEndInterval*1.3);
              spawnBeamSparkBurst(geom.endX, geom.endY, {
                dir: this.dir,
                speed: 220,
                count: Math.max(4, Math.round(width/5)),
                radius: width*0.55,
                color: '#f97316',
                accent: '#fed7aa',
                life: 0.38,
                flow: -0.45,
                swirl: true,
              });
            }
          } else {
            if(needStart) timers.start = this.sparkStartInterval;
            if(needEnd) timers.end = this.sparkEndInterval;
          }
        }
      }
    }
    finish(){
      if(!this.alive) return;
      this.alive = false;
      if(this.owner){
        if(this.owner.brimstoneBeam === this){
          this.owner.brimstoneBeam = null;
        }
        this.owner.brimstoneFiring = false;
        this.owner.brimstoneBeamTimer = 0;
      }
    }
    draw(ctx){
      const geom = this.getGeometry();
      if(!geom || geom.length<=0) return;
      const width = Math.max(6, this.getWidth());
      const palette = {...(this.palette || {})};
      if(this.owner && typeof this.owner.collectSynergyOptions === 'function'){
        const synergy = this.owner.collectSynergyOptions('impact-dash-trail', {colors:{}});
        if(synergy && synergy.colors){
          for(const key of Object.keys(synergy.colors)){
            const value = synergy.colors[key];
            if(typeof value === 'string'){ palette[key] = value; }
          }
        }
      }
      const samples = buildCurvedBeamSamples(geom, width, {
        phase: this.wobblePhase || 0,
        seed: this.visualSeed || 0,
        amplitudeFactor: Number.isFinite(this.amplitudeFactor) ? this.amplitudeFactor : undefined,
      });
      if(samples.length<2) return;
      drawCurvedBeam(samples, geom, width, palette, {seed: this.visualSeed || 0});
    }
  }

  function createImpactDashTrail(owner, options={}){
    const radius = Math.max(6, Number(options.radius) || ((owner?.r || 12) * 2));
    const lifetime = Math.max(0.2, Number(options.lifetime) || 1);
    const tickInterval = Math.max(1/120, Number(options.tickInterval) || (20/60));
    const damageScale = Number.isFinite(options.damageScale) ? options.damageScale : 4;
    const minStep = Math.max(2, Number(options.minStep) || radius * 0.4);
    const visualIntensity = Number.isFinite(options.visualIntensity) ? clamp(options.visualIntensity, 0.4, 2) : 1;
    const sparkleRate = Math.max(0, Number(options.sparkleRate) || 0);
    const sparkleLife = Math.max(0.12, Number(options.sparkleLife) || 0.35);
    const paletteSource = options.colors || options.palette || {};
    const palette = {
      outer: '#0ea5e9',
      mid: '#38bdf8',
      inner: '#ecfeff',
      gradientInner: '#fde68a',
      gradientMid: '#fca5a5',
      gradientOuter: '#f97316',
      stroke: '#fb7185',
      glowStart: '#fde68a',
      glowEnd: '#fbbf24',
      glowOuter: '#fb923c',
      burstStart: '#fb923c',
      burstStartAccent: '#fde68a',
      burstEnd: '#f97316',
      burstEndAccent: '#fed7aa',
      sparkle: '#e0f2fe',
    };
    if(typeof options.sparkleColor === 'string'){ palette.sparkle = options.sparkleColor; }
    for(const key of Object.keys(paletteSource)){
      const value = paletteSource[key];
      if(typeof value === 'string'){ palette[key] = value; }
    }
    const sparkleColor = palette.sparkle;
    const homingStrength = Math.max(0, Number(options.homingStrength) || 0);
    const homingSpeed = Math.max(0, Number(options.homingSpeed) || 0);
    const homingRange = Math.max(0, Number(options.homingRange) || 0);
    const homingWhileInactive = options.homingWhileInactive !== false;
    const maxStretch = Math.max(radius * 1.5, Number(options.homingMaxStretch) || radius * 6);
    const trail = {
      type:'impact-dash',
      owner,
      alive: true,
      follow: true,
      radius,
      ttl: lifetime,
      life: lifetime,
      tickInterval,
      tickTimer: tickInterval,
      damageScale,
      minStep,
      visualIntensity,
      sparkleRate,
      sparkleLife,
      sparkleColor,
      palette,
      homing: !!options.homing,
      homingStrength: homingStrength>0 ? homingStrength : Math.max(0, owner?.homingStrength ?? 0),
      homingSpeed,
      homingRange,
      homingWhileInactive,
      maxStretch,
      sparkleAccumulator: 0,
      sparkles: [],
      points: [],
      segmentLengths: [],
      totalLength: 0,
      finalLength: 0,
      addPoint(x,y){
        if(!Number.isFinite(x) || !Number.isFinite(y)) return;
        const pts = this.points;
        if(!pts.length){
          pts.push({x,y});
          return;
        }
        const last = pts[pts.length-1];
        const dx = x - last.x;
        const dy = y - last.y;
        const dist = Math.hypot(dx, dy);
        if(dist < 1e-4){
          return;
        }
        if(dist < this.minStep && pts.length>1){
          last.x = x;
          last.y = y;
          const prev = pts[pts.length-2];
          const newLen = Math.hypot(last.x - prev.x, last.y - prev.y);
          const idx = this.segmentLengths.length - 1;
          if(idx>=0){
            this.totalLength -= this.segmentLengths[idx];
            this.segmentLengths[idx] = newLen;
            this.totalLength += newLen;
          }
          return;
        }
        pts.push({x,y});
        const segLen = pts.length>1 ? Math.hypot(x - pts[pts.length-2].x, y - pts[pts.length-2].y) : 0;
        this.segmentLengths.push(segLen);
        this.totalLength += segLen;
      },
      updateLastSegmentLength(){
        const pts = this.points;
        if(pts.length<2) return;
        const lastIdx = pts.length-1;
        const prev = pts[lastIdx-1];
        const last = pts[lastIdx];
        const newLen = Math.hypot(last.x - prev.x, last.y - prev.y);
        const segIdx = this.segmentLengths.length-1;
        if(segIdx>=0){
          const oldLen = this.segmentLengths[segIdx] || 0;
          this.segmentLengths[segIdx] = newLen;
          this.totalLength += newLen - oldLen;
        } else {
          this.segmentLengths[0] = newLen;
          this.totalLength = newLen;
        }
      },
      distanceToPath(x,y){
        const pts = this.points;
        if(pts.length===0) return Infinity;
        if(pts.length===1) return Math.hypot(x - pts[0].x, y - pts[0].y);
        let best = Infinity;
        for(let i=0;i<pts.length-1;i++){
          const p0 = pts[i];
          const p1 = pts[i+1];
          const res = pointSegmentDistance(x,y,p0.x,p0.y,p1.x,p1.y);
          if(res.distance < best) best = res.distance;
        }
        return best;
      },
      samplePointAt(distance){
        const pts = this.points;
        if(pts.length===0) return null;
        if(pts.length===1) return {x:pts[0].x, y:pts[0].y};
        let remaining = Math.max(0, distance);
        for(let i=0;i<this.segmentLengths.length;i++){
          const segLen = this.segmentLengths[i];
          if(remaining <= segLen){
            const p0 = pts[i];
            const p1 = pts[i+1];
            const t = segLen>0 ? remaining / segLen : 0;
            return {
              x: p0.x + (p1.x - p0.x) * t,
              y: p0.y + (p1.y - p0.y) * t,
            };
          }
          remaining -= segLen;
        }
        const last = pts[pts.length-1];
        return {x:last.x, y:last.y};
      },
      spawnSparkle(){
        if(this.sparkleRate<=0) return;
        const pts = this.points;
        if(!pts.length) return;
        let position = null;
        if(this.totalLength>0){
          const target = Math.random() * this.totalLength;
          position = this.samplePointAt(target);
        }
        if(!position){
          const last = pts[pts.length-1];
          position = {x:last.x, y:last.y};
        }
        if(!position) return;
        const angle = Math.random() * Math.PI * 2;
        const speed = 18 + Math.random() * 26;
        const sparkle = {
          x: position.x,
          y: position.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: this.sparkleLife,
          maxLife: this.sparkleLife,
        };
        this.sparkles.push(sparkle);
      },
      applyHoming(dt){
        if(!this.homing) return;
        if(!this.follow && !this.homingWhileInactive) return;
        const pts = this.points;
        if(pts.length<2) return;
        const room = dungeon?.current;
        if(!room || !Array.isArray(room.enemies) || !room.enemies.length) return;
        const tail = pts[pts.length-1];
        let target=null;
        let best=Infinity;
        const rangeLimit = this.homingRange>0 ? this.homingRange : Infinity;
        for(const enemy of room.enemies){
          if(enemy.dead) continue;
          const d = Math.hypot(enemy.x - tail.x, enemy.y - tail.y);
          if(rangeLimit>0 && d>rangeLimit) continue;
          if(d < best){ best = d; target = enemy; }
        }
        if(!target) return;
        const prev = pts[pts.length-2];
        const baseSpeed = this.homingSpeed>0 ? this.homingSpeed : Math.max(150, (owner?.speed || CONFIG.player.speed || 210) * 1.25);
        const strength = this.homingStrength>0 ? this.homingStrength : Math.max(owner?.homingStrength || 0, 6);
        const step = baseSpeed * dt;
        if(step<=0) return;
        const toX = target.x - tail.x;
        const toY = target.y - tail.y;
        const dist = Math.hypot(toX, toY);
        if(!(dist>1e-4)) return;
        const strengthScale = clamp(strength / 12, 0.25, 2);
        const move = Math.min(dist, step * (0.5 + 0.5 * strengthScale));
        const nx = toX / dist;
        const ny = toY / dist;
        const oldX = tail.x;
        const oldY = tail.y;
        tail.x += nx * move;
        tail.y += ny * move;
        let segLen = Math.hypot(tail.x - prev.x, tail.y - prev.y);
        const stretchLimit = this.maxStretch>0 ? this.maxStretch : Infinity;
        if(segLen > stretchLimit){
          const excess = segLen - stretchLimit;
          tail.x -= nx * excess;
          tail.y -= ny * excess;
          segLen = stretchLimit;
        }
        this.updateLastSegmentLength();
        if(!this.follow && this.homingWhileInactive){
          this.finalLength = Math.max(this.finalLength, this.totalLength);
        }
        if(this.points.length>2){
          const prevPrev = this.points[this.points.length-3];
          if(prevPrev){
            const adjust = clamp(move / Math.max(1, segLen), 0, 1) * 0.35;
            if(adjust>0){
              prev.x += (tail.x - oldX) * adjust;
              prev.y += (tail.y - oldY) * adjust;
              const segIdx = this.segmentLengths.length-2;
              if(segIdx>=0){
                const oldLen = this.segmentLengths[segIdx] || 0;
                const newLen = Math.hypot(prev.x - prevPrev.x, prev.y - prevPrev.y);
                this.segmentLengths[segIdx] = newLen;
                this.totalLength += newLen - oldLen;
              }
            }
          }
        }
      },
      applyDamage(){
        const room = dungeon?.current;
        if(!room || !Array.isArray(room.enemies)) return;
        const ownerDamage = Number.isFinite(this.owner?.damage) ? this.owner.damage : 1;
        const damageValue = Math.max(0, ownerDamage * this.damageScale);
        if(damageValue<=0) return;
        for(const enemy of room.enemies){
          if(enemy.dead) continue;
          const threshold = this.radius + (enemy.r || 12);
          if(this.distanceToPath(enemy.x, enemy.y) <= threshold){
            if(enemy.damage(damageValue)){ handleEnemyDeath(enemy, room); }
          }
        }
      },
      pruneToLength(target){
        target = Math.max(0, target);
        let length = this.totalLength;
        if(length <= target) return;
        while(this.points.length > 1 && length - (this.segmentLengths[0] || 0) >= target){
          const removed = this.segmentLengths.shift() || 0;
          this.points.shift();
          length -= removed;
        }
        this.totalLength = length;
        if(this.points.length <= 1){
          this.segmentLengths.length = Math.max(0, this.points.length - 1);
          return;
        }
        if(length > target){
          const excess = length - target;
          const firstSeg = this.segmentLengths[0] || 0;
          if(firstSeg > 1e-6 && excess < firstSeg){
            const p0 = this.points[0];
            const p1 = this.points[1];
            const nx = (p1.x - p0.x) / firstSeg;
            const ny = (p1.y - p0.y) / firstSeg;
            p0.x += nx * excess;
            p0.y += ny * excess;
            this.segmentLengths[0] = firstSeg - excess;
            this.totalLength = target;
          } else {
            this.segmentLengths.shift();
            this.points.shift();
            this.totalLength = Math.max(0, length - firstSeg);
          }
        }
      },
      finalize(){
        if(!this.follow) return;
        this.follow = false;
        this.life = this.ttl;
        this.finalLength = this.totalLength;
      },
      finish(){
        this.alive = false;
        this.follow = false;
      },
      update(dt){
        if(!this.alive) return;
        if(this.follow){
          this.life = this.ttl;
          this.finalLength = this.totalLength;
        } else {
          this.life = Math.max(0, this.life - dt);
          const ratio = this.ttl>0 ? clamp(this.life / this.ttl, 0, 1) : 0;
          this.pruneToLength(this.finalLength * ratio);
          if(this.life<=0 || this.points.length<=1){
            this.alive = false;
          }
        }
        if(this.homing && (this.follow || this.homingWhileInactive)){
          this.applyHoming(dt);
        }
        if(this.sparkleRate>0){
          this.sparkleAccumulator += dt * this.sparkleRate;
          while(this.sparkleAccumulator >= 1){
            this.spawnSparkle();
            this.sparkleAccumulator -= 1;
          }
        }
        if(this.sparkles.length){
          for(let i=this.sparkles.length-1;i>=0;i--){
            const s = this.sparkles[i];
            s.life -= dt;
            if(s.life <= 0){
              this.sparkles.splice(i,1);
              continue;
            }
            if(Number.isFinite(s.vx) && Number.isFinite(s.vy)){
              s.x += s.vx * dt;
              s.y += s.vy * dt;
              s.vx *= 0.82;
              s.vy *= 0.82;
            }
          }
        }
        this.tickTimer -= dt;
        if(this.tickTimer <= 0){
          this.tickTimer += this.tickInterval;
          this.applyDamage();
        }
      },
      draw(ctx){
        if(!ctx) return;
        const pts = this.points;
        if(pts.length<2) return;
        const intensity = clamp(this.visualIntensity ?? 1, 0.4, 2);
        const alphaBase = this.follow ? clamp(0.72 + (intensity-1)*0.12, 0.35, 1) : clamp(this.life / this.ttl, 0, 1);
        const alpha = clamp(alphaBase, 0, 1);
        if(alpha<=0) return;
        ctx.save();
        ctx.globalAlpha *= alpha;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        const hitWidth = Math.max(4, this.radius * 2);
        const outerWidth = hitWidth * 1.15;
        const midWidth = hitWidth;
        const innerWidth = hitWidth * 0.55;
        const outerAlpha = clamp(0.45 + (intensity-1)*0.18, 0.25, 0.85);
        const midAlpha = clamp(0.6 + (intensity-1)*0.2, 0.35, 0.95);
        const innerAlpha = clamp(0.85 + (intensity-1)*0.25, 0.5, 1);
        const palette = this.palette || {};
        const outerColor = palette.outer || '#0ea5e9';
        const midColor = palette.mid || '#38bdf8';
        const innerColor = palette.inner || '#ecfeff';
        const gradientInner = palette.gradientInner || shadeColor(innerColor, 0.05);
        const gradientMid = palette.gradientMid || shadeColor(midColor, -0.05);
        const gradientOuter = palette.gradientOuter || shadeColor(outerColor, -0.25);
        ctx.strokeStyle = colorWithAlpha(outerColor, outerAlpha);
        ctx.lineWidth = outerWidth;
        ctx.shadowColor = colorWithAlpha(midColor, 0.45 * outerAlpha);
        ctx.shadowBlur = Math.max(6, this.radius * 0.65 * intensity);
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
        ctx.stroke();
        ctx.shadowBlur = Math.max(4, this.radius * 0.45 * intensity);
        ctx.strokeStyle = colorWithAlpha(midColor, midAlpha);
        ctx.lineWidth = midWidth;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
        ctx.stroke();
        ctx.globalCompositeOperation = 'lighter';
        ctx.strokeStyle = colorWithAlpha(innerColor, innerAlpha);
        ctx.lineWidth = innerWidth;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
        ctx.stroke();
        if(this.sparkles.length){
          for(const s of this.sparkles){
            const lifeRatio = s.maxLife>0 ? clamp(s.life / s.maxLife, 0, 1) : 0;
            const size = Math.max(1.5, this.radius * 0.22 + this.radius * 0.35 * lifeRatio * intensity);
            const sparkleAlpha = clamp((0.28 + 0.5 * lifeRatio) * intensity, 0.15, 0.9);
            ctx.fillStyle = colorWithAlpha(this.sparkleColor, sparkleAlpha);
            ctx.beginPath();
            ctx.arc(s.x, s.y, size, 0, Math.PI*2);
            ctx.fill();
          }
        }
        ctx.restore();
      }
    };
    return trail;
  }

  // ======= 道具叠层增强 =======
  registerItemStackEffect('impact-chocolate', (player, count)=>{
    if(!player) return;
    if(typeof player.enableImpactDash === 'function'){
      player.enableImpactDash();
    } else if(!player.impactDash && typeof player.createImpactDashState === 'function'){
      player.impactDash = player.createImpactDashState();
    }
    if(typeof player.updateImpactDashStackBonuses === 'function'){
      player.updateImpactDashStackBonuses(count);
    } else if(player.impactDash){
      const dash = player.impactDash;
      const extra = Math.max(0, count - 1);
      const radius = player.r || CONFIG.player.radius || 12;
      const baseDistanceUnits = Number.isFinite(dash.baseDistanceUnits) ? dash.baseDistanceUnits : 8;
      const perExtra = Number.isFinite(dash.distanceUnitsPerExtra) ? dash.distanceUnitsPerExtra : 3;
      const distanceUnits = baseDistanceUnits + extra * perExtra;
      dash.distanceUnits = Math.max(baseDistanceUnits, distanceUnits);
      const dashDistance = Math.max(radius * 2, radius * 2 * dash.distanceUnits);
      dash.currentDashDistance = dashDistance;
      const baseDuration = Number.isFinite(dash.baseDashDuration) ? dash.baseDashDuration : 0.18;
      let baseSpeed = Number(dash.baseDashSpeed);
      if(!Number.isFinite(baseSpeed) || baseSpeed<=0){
        const baseDistance = radius * 2 * baseDistanceUnits;
        baseSpeed = baseDuration>0 ? baseDistance / baseDuration : dashDistance / Math.max(baseDuration, 0.12);
        dash.baseDashSpeed = baseSpeed;
      }
      dash.dashDuration = Math.max(0.12, baseSpeed>0 ? dashDistance / baseSpeed : (baseDuration + extra * 0.05));
      const baseCooldown = Number.isFinite(dash.baseCooldownDuration) ? dash.baseCooldownDuration : (Number(dash.cooldownDuration) || 5);
      dash.baseCooldownDuration = baseCooldown;
      const cooldownDuration = Math.max(0.5, baseCooldown - extra * 0.5);
      dash.cooldownDuration = cooldownDuration;
      if(dash.cooldown > cooldownDuration){ dash.cooldown = cooldownDuration; }
      const basePost = Number.isFinite(dash.basePostInvulnDuration) ? dash.basePostInvulnDuration : (Number(dash.postInvulnDuration) || 1);
      dash.basePostInvulnDuration = basePost;
      const durationGain = Math.max(0, dash.dashDuration - baseDuration);
      dash.postInvulnDuration = Math.max(0, basePost + durationGain * 0.5);
      const growth = Number(dash.stackGrowth) || 1.5;
      let multiplier = extra>0 ? Math.pow(growth, extra) : 1;
      const maxMultiplier = Number(dash.maxStackMultiplier);
      if(Number.isFinite(maxMultiplier) && maxMultiplier>0){
        multiplier = Math.min(multiplier, maxMultiplier);
      }
      dash.trailRadiusMultiplier = multiplier;
      dash.trailDamageMultiplier = multiplier;
      const intensity = clamp(0.9 + extra * 0.22, 0.9, 1.8);
      dash.trailVisualIntensity = intensity;
      dash.trailSparkleRate = extra>0 ? Math.min(22, 6 + extra * 4) : 0;
      dash.trailSparkleLife = clamp(0.3 + extra * 0.04, 0.3, 0.6);
      dash.trailSparkleColor = count>=4 ? '#f0fdf4' : '#e0f2fe';
      dash.canBreakObstacles = count>3;
    }
  });

  registerItemStackEffect('hot-chocolate', (player, count)=>{
    if(!player) return;
    if(typeof player.enableHotChocolate === 'function'){
      player.enableHotChocolate();
    } else {
      if(!player.hotChocolate) player.hotChocolate = {enabled:true};
      else player.hotChocolate.enabled = true;
    }
    if(typeof player.updateHotChocolateStackBonuses === 'function'){
      player.updateHotChocolateStackBonuses(count);
    }
  });

  registerItemStackEffect('seer-map', (player, count)=>{
    if(!player) return;
    player.fullMapVision = true;
    if(dungeon?.revealAllRooms){ dungeon.revealAllRooms(); }
    const extra = Math.max(0, count - 1);
    const discountSteps = Math.min(extra, 4);
    const multiplier = clamp(1 - discountSteps * 0.08, 0.65, 1);
    player.shopPriceMultiplier = multiplier;
    player.shopPriceOffset = extra>0 ? Math.min(3, extra) : 0;
    player.cardDropBonus = Math.min(0.25, extra * 0.05);
  });

  registerItemStackEffect('rope', (player, count)=>{
    if(!player) return;
    player.flying = true;
    const extra = Math.max(0, count - 1);
    const capped = Math.min(extra, 4);
    const speedBonus = capped * 18;
    const tearBonus = capped * 20;
    const prevSpeed = Number(player.ropeSpeedBonus) || 0;
    if(Math.abs(speedBonus - prevSpeed) > 1e-4){
      player.speed += speedBonus - prevSpeed;
      player.ropeSpeedBonus = speedBonus;
    }
    const prevTear = Number(player.ropeTearSpeedBonus) || 0;
    if(Math.abs(tearBonus - prevTear) > 1e-4){
      player.tearSpeed += tearBonus - prevTear;
      player.ropeTearSpeedBonus = tearBonus;
    }
  });

  function onObstacleDestroyed(room, obs){
    if(!room || !obs) return;
    const parent = obs.parent;
    if(parent && typeof parent.remaining === 'number'){
      parent.remaining = Math.max(0, parent.remaining - 1);
      if(parent.hidden && !parent.lootDropped && parent.remaining<=0){
        parent.lootDropped = true;
        const dropPos = parent.dropPos || {x: obs.x + obs.w/2, y: obs.y + obs.h/2};
        const dropX = clamp(dropPos.x, 70, CONFIG.roomW-70);
        const dropY = clamp(dropPos.y, 80, CONFIG.roomH-80);
        spawnRandomDrop(room, dropX, dropY);
        if(rand() < CONFIG.obstacles.hiddenItemChance){
          const item = rollItem();
          room.pickups.push({type:'item', x:clamp(dropX,80,CONFIG.roomW-80), y:clamp(dropY,90,CONFIG.roomH-90), r:18, item, vx:0, vy:0, solid:false});
        }
      }
    }
  }

  function handleBombExplosion(room, bomb){
    if(!room) return;
    const radius = bomb?.explosionRadius || (CONFIG.bomb.radius * (bomb?.radiusMultiplier ?? 1));
    const circle = {x:bomb.x, y:bomb.y, r:radius};
    const damage = Number.isFinite(bomb?.customDamage)
      ? bomb.customDamage
      : CONFIG.bomb.damage * (bomb?.damageMultiplier ?? 1);
    const knockPower = Number.isFinite(bomb?.customKnock)
      ? bomb.customKnock
      : CONFIG.bomb.knock;
    for(const enemy of room.enemies){
      if(enemy.dead) continue;
      const d = dist(bomb, enemy);
      if(d <= radius + enemy.r){
        if(typeof enemy.damage === 'function'){
          if(enemy.damage(damage)){ handleEnemyDeath(enemy, room); }
        }
        const len = Math.max(1, d);
        const push = (radius - Math.min(radius, d)) * 0.6;
        if(enemy.knock!==undefined){ enemy.knock = 0.35; }
        enemy.x += (enemy.x - bomb.x)/len * push;
        enemy.y += (enemy.y - bomb.y)/len * push;
        if(enemy.base){
          enemy.base.x += (enemy.base.x - bomb.x)/len * push;
          enemy.base.y += (enemy.base.y - bomb.y)/len * push;
        }
        if(enemy.vx!==undefined && enemy.vy!==undefined && enemy.state!=='charge'){
          enemy.vx += (enemy.x - bomb.x)/len * 160;
          enemy.vy += (enemy.y - bomb.y)/len * 160;
        }
      }
    }
    if(player){
      const dp = dist(player, bomb);
      if(dp <= radius + player.r){
        player.applyImpulse(player.x - bomb.x, player.y - bomb.y, knockPower);
        player.hurt(CONFIG.bomb.playerDamage, {cause:'explosion'});
      }
    }
    for(const obs of room.obstacles){
      if(obs.destroyed) continue;
      if(circleRectOverlap(circle, obs)){
        obs.destroyed = true;
        onObstacleDestroyed(room, obs);
      }
    }
    if(room.pickups){
      for(const drop of room.pickups){
        if(!isPhysicalPickup(drop)) continue;
        if(dist(drop, bomb) <= radius + drop.r){
          pushPickup(drop, bomb, knockPower * 1.45, {force:true});
          ensurePickupMotion(drop);
          drop.vx *= 1.25;
          drop.vy *= 1.25;
        }
      }
    }
    for(const other of room.bombs){
      if(other===bomb || other.done || other.exploded) continue;
      const db = dist(other, bomb);
      if(db <= radius + other.r){
        other.applyImpulse(other.x - bomb.x, other.y - bomb.y, knockPower * 1.1);
      }
    }
    for(const proj of runtime.enemyProjectiles){
      if(!proj.alive) continue;
      if(dist(proj, bomb) <= radius){ proj.alive=false; }
    }
    if(bomb?.shakeStrength){
      addScreenShake(bomb.shakeStrength, 0.32);
    }
  }

  const ENEMY_SPAWN_RADIUS = {
    chaser:12,
    orbiter:10,
    gasbag:14,
    bomber:13,
    tinyfly:8,
    elderfly:13,
    spider:16,
    splitter:13,
    volatile:11,
    sentry:12,
    dashling:11,
    burrower:13,
    spark:10,
    brood:14,
  };

  const MAX_BOSS_SUMMONS = 5;
  const GLOBAL_BOSS_SUMMON_KEY = {tag:'global-boss-summon'};

  function rollEnemyType(depth){
    const floorLevel = Math.max(1, Math.floor(currentFloor || 1));
    const weights = [
      {type:'chaser', w: 2.6},
      {type:'orbiter', w: 1.2 + depth*0.05},
      {type:'gasbag', w: 0.7 + depth*0.04},
      {type:'bomber', w: (floorLevel<=1 ? 1.4 : 0.6) + depth*0.03},
      {type:'tinyfly', w: 0.6 + Math.max(0, depth-1)*0.05},
      {type:'elderfly', w: 0.75 + depth*0.06},
      {type:'spider', w: 0.65 + depth*0.07},
      {type:'sentry', w: 0.4 + depth*0.05},
    ];
    if(floorLevel >= 2){
      weights.push({type:'volatile', w: 0.5 + Math.max(0, depth-1)*0.05});
      weights.push({type:'spark', w: 0.45 + Math.max(0, depth-1)*0.05});
      weights.push({type:'dashling', w: 0.5 + Math.max(0, depth-1)*0.05});
    }
    if(floorLevel >= 3){
      weights.push({type:'splitter', w: 0.45 + Math.max(0, depth-2)*0.06});
      weights.push({type:'burrower', w: 0.35 + Math.max(0, depth-2)*0.05});
      weights.push({type:'brood', w: 0.3 + Math.max(0, depth-2)*0.05});
    }
    const total = weights.reduce((sum, entry)=>sum+entry.w,0);
    let r = rand()*total;
    for(const entry of weights){
      r -= entry.w;
      if(r<=0) return entry.type;
    }
    return 'chaser';
  }

  function makeEnemy(type, pos, depth){
    const hp = Math.max(1, Math.round(CONFIG.enemy.baseHP + depth*0.24 + rand()*1.0));
    let enemy;
    if(type==='chaser') enemy = new EnemyChaser(pos.x,pos.y,hp);
    else if(type==='orbiter') enemy = new EnemyOrbiter(pos.x,pos.y,hp);
    else if(type==='gasbag') enemy = new EnemyGasbag(pos.x,pos.y, Math.max(hp+1, 3));
    else if(type==='bomber') enemy = new EnemyBomber(pos.x,pos.y, Math.max(hp, 3));
    else if(type==='tinyfly') enemy = new EnemyTinyFly(pos.x,pos.y, Math.max(1, Math.round(1 + depth*0.15)));
    else if(type==='elderfly') enemy = new EnemyElderFly(pos.x,pos.y, Math.max(hp, 3));
    else if(type==='spider') enemy = new EnemySpiderLeaper(pos.x,pos.y, Math.max(hp+1, 4));
    else if(type==='splitter') enemy = new EnemySplitter(pos.x,pos.y, Math.max(hp+2, 4));
    else if(type==='volatile') enemy = new EnemyVolatile(pos.x,pos.y, Math.max(hp, 2));
    else if(type==='sentry') enemy = new EnemySentry(pos.x,pos.y, Math.max(hp+1, 4));
    else if(type==='dashling') enemy = new EnemyDashling(pos.x,pos.y, Math.max(hp, 3));
    else if(type==='burrower') enemy = new EnemyBurrower(pos.x,pos.y, Math.max(hp+1, 4));
    else if(type==='spark') enemy = new EnemySpark(pos.x,pos.y, Math.max(hp, 2));
    else if(type==='brood') enemy = new EnemyBrood(pos.x,pos.y, Math.max(hp+1, 4));
    else enemy = new EnemyChaser(pos.x,pos.y,hp);
    return prepareEnemy(enemy);
  }

  const BOSS_TUNING = Object.freeze({
    sizeScale: 0.8,
    tempoScale: 1.2,
    heavyAttackWeight: 0.8,
    deathShake: { intensity: 7.5, duration: 0.5 },
  });
  function scaleBossRadius(value){
    if(!Number.isFinite(value)) return value;
    return value * BOSS_TUNING.sizeScale;
  }
  function scaleBossTempo(value){
    if(!Number.isFinite(value)) return value;
    return value * BOSS_TUNING.tempoScale;
  }
  function applyBossHeavyChance(baseChance){
    if(!Number.isFinite(baseChance)) return baseChance;
    return clamp(baseChance * BOSS_TUNING.heavyAttackWeight, 0, 0.98);
  }
  function adjustBossHeavyThreshold(baseThreshold){
    if(!Number.isFinite(baseThreshold)) return baseThreshold;
    return 1 - (1 - baseThreshold) * BOSS_TUNING.heavyAttackWeight;
  }
  function pickWeightedOption(options){
    if(!Array.isArray(options) || options.length===0) return null;
    let total = 0;
    for(const opt of options){
      total += Math.max(0, Number(opt.weight) || 0);
    }
    if(total<=0){
      return options[0];
    }
    const roll = rand() * total;
    let acc = 0;
    for(const opt of options){
      acc += Math.max(0, Number(opt.weight) || 0);
      if(roll <= acc){
        return opt;
      }
    }
    return options[options.length-1];
  }

  function makeBoss(pos, room){
    const bossId = room?.bossId || 'idol';
    let boss;
    const meta = getBossMeta(bossId);
    const bossName = room?.bossName || meta.name;
    switch(bossId){
      case 'master':
        boss = new EnemyBossMaster(pos.x, pos.y, bossName);
        break;
      case 'hydra':
        boss = new EnemyBossHydra(pos.x, pos.y, bossName);
        break;
      case 'seer':
        boss = new EnemyBossSeer(pos.x, pos.y, bossName);
        break;
      case 'titan':
        boss = new EnemyBossTitan(pos.x, pos.y, bossName);
        break;
      case 'umbra':
        boss = new EnemyBossUmbra(pos.x, pos.y, bossName);
        break;
      case 'paradox':
        boss = new EnemyBossParadox(pos.x, pos.y, bossName);
        break;
      default:
        boss = new EnemyBoss(pos.x, pos.y, bossName);
        break;
    }
    boss.room = room;
    return prepareEnemy(boss);
  }

  class EnemyChaser{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=12; this.hp=hp;
      this.speed = CONFIG.enemy.speed * randRange(0.9,1.2);
      this.tint = '#ff6b6b';
      this.tintLight = '#ff9aa2';
      initializeEnemyStats(this, {speedFields:['speed']});
      this.knockDamping = 7;
      ensureEnemyKnockState(this);
    }
    update(dt){
      const to = {x:player.x - this.x, y:player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1; to.x/=l; to.y/=l;
      const slowMul = this.hitSlowTimer>0 ? this.hitSlowFactor : 1;
      const knocked = resolveEnemyKnockback(this, dt);
      if(!knocked){
        const moveSpeed = this.speed * getEnemyGlobalSpeedMultiplier() * slowMul;
        this.x += to.x * moveSpeed * dt;
        this.y += to.y * moveSpeed * dt;
      }
      // 碰撞到玩家
      if(dist(this, player) < this.r + player.r){
        player.hurt(1);
        applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:160, duration:0.2, slowFactor:0.75, slowDuration:0.25});
      }
      resolveEntityObstacles(this);
    }
    draw(){ drawBlob(this.x,this.y,this.r,'#ff9aa2','#ff6b6b'); }
    damage(d){
      if(this.dead) return false;
      this.hp-=d;
      if(this.hp<=0){ this.dead=true; return true; }
      applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:150, duration:0.18, slowFactor:0.75, slowDuration:0.28});
      return false;
    }
  }

  class EnemyOrbiter{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=10; this.hp=hp;
      this.t=rand()*Math.PI*2; this.base={x,y}; this.range=40+rand()*25;
      this.omega = 2+rand()*1.5; this.speed=40; this.flying=true;
      this.tint = '#7aa2ff';
      this.tintLight = '#b4c7ff';
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{ enemy.omega *= scaling.aggression; }
      });
      this.knockDamping = 7;
      ensureEnemyKnockState(this);
    }
    update(dt){
      const prevX = this.x;
      const prevY = this.y;
      const knocked = resolveEnemyKnockback(this, dt);
      if(knocked){
        const dx = this.x - prevX;
        const dy = this.y - prevY;
        if(Number.isFinite(dx)) this.base.x += dx;
        if(Number.isFinite(dy)) this.base.y += dy;
      } else {
        const slowMul = this.hitSlowTimer>0 ? this.hitSlowFactor : 1;
        this.t += this.omega*dt;
        const orbitRadius = this.range;
        this.x = this.base.x + Math.cos(this.t)*orbitRadius;
        this.y = this.base.y + Math.sin(this.t)*orbitRadius;
        const drift = this.speed * getEnemyGlobalSpeedMultiplier() * slowMul;
        // 慢慢靠近玩家（弱追踪）
        const dx = player.x - this.base.x; const dy = player.y - this.base.y;
        const l = Math.hypot(dx,dy)||1; this.base.x += (dx/l)*drift*dt*0.6; this.base.y += (dy/l)*drift*dt*0.6;
      }
      // 慢慢靠近玩家（弱追踪）
      if(dist(this, player) < this.r + player.r){
        player.hurt(1);
        applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:130, duration:0.16, slowFactor:0.8, slowDuration:0.2});
      }
      resolveEntityObstacles(this);
    }
    draw(){ drawBlob(this.x,this.y,this.r,'#b4c7ff','#7aa2ff'); }
    damage(d){
      if(this.dead) return false;
      this.hp-=d;
      if(this.hp<=0){ this.dead=true; return true; }
      applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:120, duration:0.16, slowFactor:0.8, slowDuration:0.2});
      return false;
    }
  }

  class EnemyBomber{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.bomber || {};
      this.x=x; this.y=y; this.r=13; this.hp=hp;
      this.speed = (cfg.speed || 70) * randRange(0.85,1.1);
      this.knockDamping = 7;
      this.cooldownBase = Math.max(1.6, cfg.cooldown || 4);
      this.cooldown = randRange(this.cooldownBase*0.6, this.cooldownBase*1.1);
      this.fuse = Math.max(1, cfg.fuse || 2.4);
      this.wanderTimer = randRange(0.8,1.8);
      this.wanderAngle = rand()*Math.PI*2;
      this.tint = '#fbbf24';
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{
          const aggression = Math.max(0.5, scaling.aggression || 1);
          enemy.cooldownBase = Math.max(1.2, enemy.cooldownBase / aggression);
          enemy.cooldown = Math.max(1, enemy.cooldownBase);
        }
      });
      ensureEnemyKnockState(this);
    }
    dropBomb(){
      const room = dungeon?.current;
      if(!room) return;
      const bomb = new Bomb(this.x, this.y, {
        owner: 'enemy',
        fuse: this.fuse,
        spawnGrace: 0.12,
        radiusMultiplier: 1,
        damageMultiplier: 1,
        shakeStrength: 0,
      });
      bomb.vx = 0;
      bomb.vy = 0;
      room.bombs.push(bomb);
      addScreenShake(3, 0.18);
    }
    update(dt){
      if(this.dead) return;
      const slowMul = this.hitSlowTimer>0 ? this.hitSlowFactor : 1;
      if(!resolveEnemyKnockback(this, dt)){
        this.wanderTimer -= dt;
        if(this.wanderTimer<=0){
          this.wanderAngle = rand()*Math.PI*2;
          this.wanderTimer = randRange(0.9,1.9);
        }
        const moveSpeed = this.speed * getEnemyGlobalSpeedMultiplier() * slowMul;
        this.x += Math.cos(this.wanderAngle) * moveSpeed * dt;
        this.y += Math.sin(this.wanderAngle) * moveSpeed * dt;
      }
      this.cooldown -= dt;
      if(this.cooldown<=0){
        this.dropBomb();
        this.cooldown = randRange(this.cooldownBase*0.8, this.cooldownBase*1.25);
      }
      this.x = clamp(this.x, 46, CONFIG.roomW-46);
      this.y = clamp(this.y, 56, CONFIG.roomH-56);
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r){
        player.hurt(1);
        applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:160, duration:0.22, slowFactor:0.7, slowDuration:0.3});
      }
    }
    damage(d){
      if(this.dead) return false;
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:150, duration:0.2, slowFactor:0.7, slowDuration:0.3});
      return false;
    }
    draw(){
      const pulse = 0.9 + 0.1*Math.sin(performance.now()/200 + this.x*0.02);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(pulse, pulse);
      const bodyGrad = ctx.createRadialGradient(0, -this.r*0.2, this.r*0.3, 0, 0, this.r);
      bodyGrad.addColorStop(0, '#6b7280');
      bodyGrad.addColorStop(1, '#374151');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.25, -this.r*0.25, this.r*0.35, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.r*0.25, -this.r*0.15, this.r*0.28, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#f97316';
      ctx.fillRect(-this.r*0.18, -this.r*0.85, this.r*0.36, this.r*0.5);
      ctx.fillStyle = '#facc15';
      ctx.fillRect(-this.r*0.6, this.r*0.15, this.r*1.2, this.r*0.35);
      ctx.restore();
    }
  }

  class EnemyGasbag{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=14; this.hp=hp;
      const cfg = CONFIG.enemy.gasbag;
      this.speed = cfg.speed * randRange(0.85,1.15);
      this.wanderAngle = rand()*Math.PI*2;
      this.wanderTimer = randRange(0.6,1.4);
      this.safeRadius = cfg.safeRadius;
      this.fuse = -1;
      this.flashTimer = 0;
      this.cooldown = 0;
      this.flying = false;
      this.tint = '#f97316';
      this.tintLight = '#fdba74';
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{
          enemy.triggerCooldownBase = Math.max(0.25, cfg.triggerCooldown / scaling.aggression);
          enemy.triggerChance = Math.min(0.98, cfg.triggerChance * scaling.aggression);
          enemy.fuseDuration = Math.max(0.45, cfg.fuse / scaling.aggression);
        }
      });
      this.knockDamping = 6.5;
      ensureEnemyKnockState(this);
    }
    startFuse(){
      if(this.fuse>0) return;
      this.fuse = this.fuseDuration;
      this.flashTimer = this.fuse;
    }
    detonate(){
      if(this.dead) return;
      this.dead = true;
      const cfg = CONFIG.enemy.gasbag;
      if(player && dist(this, player) < this.r + cfg.explosionRadius){
        player.hurt(1, {cause:'explosion'});
        player.applyImpulse(player.x - this.x, player.y - this.y, 180);
      }
      const room = dungeon?.current;
      if(room){
        const count = Math.floor(randRange(cfg.spawnMin, cfg.spawnMax+1));
        for(let i=0;i<count;i++){
          const ang = rand()*Math.PI*2;
          const rad = randRange(14, 38);
          const pos = {
            x: clamp(this.x + Math.cos(ang)*rad, 60, CONFIG.roomW-60),
            y: clamp(this.y + Math.sin(ang)*rad, 60, CONFIG.roomH-60)
          };
          queueEnemySpawn(makeEnemy('tinyfly', pos, dungeon.depth));
        }
        handleEnemyDeath(this, room);
      }
    }
    update(dt){
      if(this.dead) return;
      const cfg = CONFIG.enemy.gasbag;
      this.flashTimer = Math.max(0, this.flashTimer - dt);
      if(this.fuse>0){
        this.fuse -= dt;
        if(this.fuse<=0){ this.detonate(); return; }
      }
      const slowMul = this.hitSlowTimer>0 ? this.hitSlowFactor : 1;
      const knocked = resolveEnemyKnockback(this, dt);
      if(!knocked){
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const d = Math.hypot(dx,dy)||1;
        if(this.fuse<=0 && d < cfg.triggerRange){
          this.cooldown -= dt * this.aggression;
          if(this.cooldown<=0){
            if(rand() < Math.min(0.98, this.triggerChance)){ this.startFuse(); }
            this.cooldown = this.triggerCooldownBase;
          }
        } else {
          this.cooldown = Math.max(0, this.cooldown - dt*0.5*this.aggression);
        }
        if(d < this.safeRadius){
          const retreat = this.speed * getEnemyGlobalSpeedMultiplier() * slowMul;
          this.x += (dx/d) * retreat * dt;
          this.y += (dy/d) * retreat * dt;
        } else {
          this.wanderTimer -= dt;
          if(this.wanderTimer<=0){
            this.wanderAngle = rand()*Math.PI*2;
            this.wanderTimer = randRange(0.6,1.4);
          }
          const roam = this.speed * 0.45 * getEnemyGlobalSpeedMultiplier() * slowMul;
          this.x += Math.cos(this.wanderAngle) * roam * dt;
          this.y += Math.sin(this.wanderAngle) * roam * dt;
        }
      }
      this.x = clamp(this.x, 46, CONFIG.roomW-46);
      this.y = clamp(this.y, 56, CONFIG.roomH-56);
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r){
        player.hurt(1);
        applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:180, duration:0.18, slowFactor:0.7, slowDuration:0.3});
      }
    }
    damage(d){
      if(this.dead) return false;
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:200, duration:0.2, slowFactor:0.7, slowDuration:0.35});
      return false;
    }
    draw(){
      const telegraph = this.fuse>0;
      const base = telegraph ? '#ffd6a8' : '#fcd5ce';
      const edge = telegraph ? '#fb923c' : '#f973a6';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = '#2f1d38';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.25, -this.r*0.15, this.r*0.18, this.r*0.26, 0, 0, Math.PI*2);
      ctx.ellipse(this.r*0.25, -this.r*0.15, this.r*0.18, this.r*0.26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      if(telegraph){
        ctx.save();
        ctx.globalAlpha = 0.65 + 0.3*Math.sin(performance.now()/80);
        ctx.strokeStyle = '#ffd29a';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r + 8, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }
  }

  class EnemySplitter{
    constructor(x,y,baseHp, options={}){
      const cfg = CONFIG.enemy.splitter || {};
      this.x=x; this.y=y;
      this.seedHp = options.seedHp ?? baseHp;
      this.splitLevel = options.splitLevel ?? 0;
      this.maxSplits = Math.max(0, Math.floor(cfg.maxSplits ?? 3));
      const decay = clamp(cfg.radiusDecay ?? 0.9, 0.55, 1);
      const baseRadius = cfg.radius ?? 14;
      this.r = Math.max(8, baseRadius * Math.pow(decay, this.splitLevel));
      const speedBase = cfg.speed ?? (CONFIG.enemy.speed * 0.75);
      const perSplit = cfg.speedScalePerSplit ?? 0.12;
      this.speed = speedBase * randRange(0.9,1.1) * (1 + perSplit * this.splitLevel);
      this.pauseDuration = Math.max(0, cfg.pause ?? 1);
      this.spawnGrace = options.spawnGrace ?? (this.splitLevel>0 ? Math.min(this.pauseDuration, 0.65) : 0.25);
      this.reengageTimer = options.reengageTimer ?? (this.splitLevel>0 ? this.pauseDuration : 0);
      this.scaling = getFloorScalingFactors();
      const hpDecay = clamp(cfg.hpDecay ?? 0.75, 0.1, 1);
      const scaledSeed = Math.max(1, Math.round(this.seedHp * this.scaling.hp));
      const totalHp = Math.max(1, Math.round(scaledSeed * Math.pow(hpDecay, this.splitLevel)));
      const branches = Math.pow(2, this.splitLevel);
      this.hp = Math.max(1, Math.round(totalHp / branches));
      this.speed *= this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.flying = false;
      this.splitTriggered = false;
      this.preventDrops = false;
      this.tint = '#a855f7';
      this.tintLight = '#d8b4fe';
      this.knockDamping = 7;
      ensureEnemyKnockState(this);
    }
    update(dt){
      if(!player) return;
      if(this.spawnGrace>0){ this.spawnGrace = Math.max(0, this.spawnGrace - dt); }
      if(this.reengageTimer>0){ this.reengageTimer = Math.max(0, this.reengageTimer - dt); }
      const to = {x:player.x - this.x, y:player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1;
      const nx = to.x/l, ny = to.y/l;
      const slowMul = this.hitSlowTimer>0 ? this.hitSlowFactor : 1;
      const knocked = resolveEnemyKnockback(this, dt);
      if(!knocked && this.reengageTimer<=0){
        const moveSpeed = this.speed * getEnemyGlobalSpeedMultiplier() * slowMul;
        this.x += nx * moveSpeed * dt;
        this.y += ny * moveSpeed * dt;
      }
      this.x = clamp(this.x, 36, CONFIG.roomW-36);
      this.y = clamp(this.y, 44, CONFIG.roomH-44);
      resolveEntityObstacles(this);
      if(this.spawnGrace<=0 && this.reengageTimer<=0 && dist(this, player) < this.r + player.r){
        player.hurt(1);
        applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:170, duration:0.2, slowFactor:0.75, slowDuration:0.25});
        this.reengageTimer = Math.max(this.reengageTimer, 0.35);
      }
    }
    draw(){
      const idle = this.reengageTimer>0 || this.spawnGrace>0;
      const base = idle ? '#ede9fe' : '#d8b4fe';
      const edge = idle ? '#c4b5fd' : '#a855f7';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.28, -this.r*0.1, this.r*0.16, 0, Math.PI*2);
      ctx.arc(this.r*0.28, -this.r*0.1, this.r*0.16, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      if(idle){
        ctx.save();
        const phase = performance.now()/180 + this.splitLevel;
        const pulse = 6 + 3*Math.sin(phase);
        const ratio = this.pauseDuration>0 ? this.reengageTimer/this.pauseDuration : 0;
        ctx.globalAlpha = 0.25 + 0.25*Math.max(0, ratio);
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + pulse, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){
        this.dead = true;
        return true;
      }
      applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:160, duration:0.2, slowFactor:0.75, slowDuration:0.3});
      return false;
    }
    onDeath(room){
      if(this.splitTriggered) return;
      if(this.splitLevel >= this.maxSplits) return;
      this.splitTriggered = true;
      this.preventDrops = true;
      const nextLevel = this.splitLevel + 1;
      const cfg = CONFIG.enemy.splitter || {};
      const delay = Math.max(0, cfg.pause ?? 1);
      const childSpawnGrace = Math.min(delay, 0.65);
      for(let i=0;i<2;i++){
        const angle = rand()*Math.PI*2;
        const radius = this.r + 10 + rand()*8;
        const pos = {
          x: clamp(this.x + Math.cos(angle)*radius, 50, CONFIG.roomW-50),
          y: clamp(this.y + Math.sin(angle)*radius, 56, CONFIG.roomH-56)
        };
        queueEnemySpawn(new EnemySplitter(pos.x, pos.y, this.seedHp, {
          splitLevel: nextLevel,
          seedHp: this.seedHp,
          spawnGrace: childSpawnGrace,
          reengageTimer: delay,
        }));
      }
      if(room){ room.chargeGranted = false; room.combatRoom = true; }
    }
  }

  class EnemyVolatile{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.volatile || {};
      this.x=x; this.y=y; this.r=11; this.hp=hp;
      this.state='chase';
      this.spawnGrace = 0.18;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      const baseSpeed = cfg.speed ?? (CONFIG.enemy.speed * 1.35);
      this.speed = baseSpeed * randRange(0.95,1.15) * this.scaling.speed;
      this.aggression = this.scaling.aggression;
      const playerRadius = player?.r ?? CONFIG.player.radius ?? 12;
      const triggerMul = cfg.triggerMultiplier ?? 2;
      this.explosionRadius = playerRadius * (cfg.explosionRadiusMultiplier ?? 1.5);
      this.triggerRange = Math.max(playerRadius * triggerMul + this.r, this.explosionRadius + this.r + 2);
      this.damageAmount = cfg.damage ?? 2;
      const fuse = Math.max(0.25, cfg.fuse ?? 0.5);
      this.fuseDuration = Math.max(0.2, fuse / this.aggression);
      this.fuseTimer = 0;
      this.flashTimer = 0;
      this.exploded = false;
      this.flying = false;
      this.tint = '#f97316';
      this.tintLight = '#fdba74';
      this.knockDamping = 7;
      ensureEnemyKnockState(this);
    }
    startFuse(){
      if(this.state==='fuse' || this.exploded) return;
      this.state='fuse';
      this.fuseTimer = this.fuseDuration;
      this.flashTimer = 0;
    }
    triggerExplosion(){
      if(this.exploded) return;
      this.exploded = true;
      spawnCircularEffect(this.x, this.y, this.explosionRadius + 6, {
        duration:0.35,
        innerColor:'#fff6',
        midColor:'#fdba74',
        outerColor:'#f97316',
      });
      const room = dungeon?.current;
      if(player){
        const d = dist(this, player);
        if(d <= this.explosionRadius + player.r){
          player.hurt(this.damageAmount, {cause:'explosion'});
          player.applyImpulse(player.x - this.x, player.y - this.y, 220);
        }
      }
      this.dead = true;
      if(room){ handleEnemyDeath(this, room); }
    }
    update(dt){
      if(!player || this.exploded) return;
      if(this.spawnGrace>0){ this.spawnGrace = Math.max(0, this.spawnGrace - dt); }
      const slowMul = this.hitSlowTimer>0 ? this.hitSlowFactor : 1;
      const knocked = resolveEnemyKnockback(this, dt);
      if(knocked){
        resolveEntityObstacles(this);
        return;
      }
      const to = {x:player.x - this.x, y:player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1;
      const nx = to.x/l, ny = to.y/l;
      if(this.state==='fuse'){
        this.fuseTimer = Math.max(0, this.fuseTimer - dt * this.aggression);
        this.flashTimer += dt * 10;
        if(this.fuseTimer<=0){ this.triggerExplosion(); return; }
      } else {
        const moveSpeed = this.speed * getEnemyGlobalSpeedMultiplier() * slowMul;
        this.x += nx * moveSpeed * dt;
        this.y += ny * moveSpeed * dt;
        if(l <= this.triggerRange){ this.startFuse(); }
      }
      this.x = clamp(this.x, 34, CONFIG.roomW-34);
      this.y = clamp(this.y, 42, CONFIG.roomH-42);
      resolveEntityObstacles(this);
      if(this.spawnGrace<=0){
        const overlap = dist(this, player);
        if(overlap < this.r + player.r){ this.triggerExplosion(); return; }
      }
    }
    draw(){
      if(this.exploded) return;
      const base = this.state==='fuse' ? '#f97316' : '#fde68a';
      const edge = this.state==='fuse' ? '#b91c1c' : '#f59e0b';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x, this.y - this.r*0.1);
      ctx.fillStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.3, 0, this.r*0.16, 0, Math.PI*2);
      ctx.arc(this.r*0.3, 0, this.r*0.16, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      if(this.state==='fuse'){
        ctx.save();
        const pulse = 0.5 + 0.5*Math.sin(this.flashTimer*8);
        ctx.globalAlpha = 0.4 + 0.35*pulse;
        ctx.strokeStyle = '#fb923c';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.explosionRadius * (0.9 + 0.2*pulse), 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    damage(d){
      if(this.exploded) return false;
      this.hp -= d;
      if(this.hp<=0){
        this.dead = true;
        return true;
      }
      applyEnemyKnockback(this, this.x - player.x, this.y - player.y, {power:180, duration:0.2, slowFactor:0.7, slowDuration:0.3});
      if(this.state==='fuse'){
        this.state='chase';
        this.fuseTimer = 0;
      }
      return false;
    }
  }

  class EnemyTinyFly{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=8; this.hp=hp;
      this.speed = CONFIG.enemy.tinyFly.speed * randRange(0.85,1.15);
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = true;
      this.tint = '#facc15';
      this.tintLight = '#fef08a';
      initializeEnemyStats(this, {speedFields:['speed']});
    }
    update(dt){
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.85;
        this.knockVy *= 0.85;
      } else {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const d = Math.hypot(dx,dy)||1;
        this.x += (dx/d) * this.speed * dt;
        this.y += (dy/d) * this.speed * dt;
      }
      this.x = clamp(this.x, 36, CONFIG.roomW-36);
      this.y = clamp(this.y, 40, CONFIG.roomH-40);
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const wobble = Math.sin(performance.now()/120 + this.x*0.01)*1.2;
      drawBlob(this.x,this.y,this.r,'#fef08a','#facc15');
      ctx.save();
      ctx.translate(this.x,this.y - this.r*0.2);
      ctx.rotate(wobble*0.05);
      ctx.fillStyle = '#fde68aaa';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.8, -this.r*0.3, this.r*0.9, this.r*0.35, -0.6, 0, Math.PI*2);
      ctx.ellipse(this.r*0.8, -this.r*0.3, this.r*0.9, this.r*0.35, 0.6, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.12;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*140;
      this.knockVy = (vec.y/len)*140;
      return false;
    }
  }

  class EnemyElderFly{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=13; this.hp=hp;
      const cfg = CONFIG.enemy.elderFly;
      this.speed = cfg.speed;
      this.fireInterval = cfg.fireInterval;
      this.telegraphWindow = cfg.telegraph;
      this.projectileSpeed = cfg.projectileSpeed;
      this.tint = '#93c5fd';
      this.tintLight = '#dbeafe';
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{
          enemy.fireInterval = Math.max(0.7, cfg.fireInterval / scaling.aggression);
          enemy.telegraphWindow = Math.max(0.25, cfg.telegraph / scaling.aggression);
          enemy.projectileSpeed = cfg.projectileSpeed * scaling.speed;
        }
      });
      this.fireTimer = randRange(this.telegraphWindow, this.fireInterval);
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.charging = false;
      this.flying = true;
    }
    update(dt){
      const cfg = CONFIG.enemy.elderFly;
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.84;
        this.knockVy *= 0.84;
      } else {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        let mx=0, my=0;
        if(distLen < cfg.minRange){ mx = -dx/distLen; my = -dy/distLen; }
        else if(distLen > cfg.maxRange){ mx = dx/distLen; my = dy/distLen; }
        else { mx = -dy/distLen; my = dx/distLen; }
        this.x += mx * this.speed * dt;
        this.y += my * this.speed * dt;
      }
      this.x = clamp(this.x, 50, CONFIG.roomW-50);
      this.y = clamp(this.y, 54, CONFIG.roomH-54);
      resolveEntityObstacles(this);
      this.fireTimer -= dt * this.aggression;
      if(this.fireTimer <= 0){
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        const speed = this.projectileSpeed + rand()*50;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.8, 'tear'));
        this.fireTimer = this.fireInterval;
        this.charging = false;
      } else {
        this.charging = this.fireTimer <= this.telegraphWindow;
      }
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const charging = this.charging;
      const base = charging ? '#fde68a' : '#dbeafe';
      const edge = charging ? '#f97316' : '#93c5fd';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = charging ? '#7f1d1d' : '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.3, -this.r*0.05, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.3, -this.r*0.05, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.18;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*150;
      this.knockVy = (vec.y/len)*150;
      return false;
    }
  }

  class EnemySentry{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.sentry;
      this.x=x; this.y=y; this.r=12; this.hp=hp;
      this.rotateSpeed = cfg.rotateSpeed * randRange(0.85,1.15);
      this.projectileSpeed = cfg.projectileSpeed;
      this.projectileLife = cfg.projectileLife;
      this.fireInterval = cfg.fireInterval;
      this.fireTimer = 0;
      this.burstShots = 0;
      this.burstSpacing = 0;
      this.burstSpacingBase = cfg.burstSpacing;
      this.telegraphTimer = 0;
      this.telegraphTotal = 0;
      this.rotation = rand()*Math.PI*2;
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = false;
      this.tint = '#38bdf8';
      this.tintLight = '#e0f2fe';
      initializeEnemyStats(this, {
        speedFields:[],
        extra:(enemy, scaling)=>{
          enemy.fireInterval = Math.max(0.9, cfg.fireInterval / Math.max(0.75, scaling.aggression));
          enemy.rotateSpeed *= scaling.aggression;
          enemy.projectileSpeed = cfg.projectileSpeed * scaling.speed;
          enemy.burstSpacingBase = Math.max(0.12, cfg.burstSpacing / Math.max(0.7, scaling.aggression));
        }
      });
      this.fireTimer = randRange(this.fireInterval*0.6, this.fireInterval*1.2);
    }
    update(dt){
      const cfg = CONFIG.enemy.sentry;
      const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
      this.rotation = stepTowardsAngle(this.rotation, targetAngle, this.rotateSpeed * dt);
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.86;
        this.knockVy *= 0.86;
      }
      this.x = clamp(this.x, 40, CONFIG.roomW-40);
      this.y = clamp(this.y, 46, CONFIG.roomH-46);
      resolveEntityObstacles(this);
      if(this.telegraphTimer>0){
        this.telegraphTimer -= dt * this.aggression;
        if(this.telegraphTimer<=0){
          this.burstShots = cfg.burst;
          this.burstSpacing = 0;
        }
      } else if(this.burstShots>0){
        this.burstSpacing -= dt;
        if(this.burstSpacing<=0){
          const offsets = [-cfg.spread, 0, cfg.spread];
          for(const offset of offsets){
            const angle = this.rotation + offset;
            runtime.enemyProjectiles.push(new EnemyProjectile(
              this.x,
              this.y,
              Math.cos(angle)*this.projectileSpeed,
              Math.sin(angle)*this.projectileSpeed,
              this.projectileLife,
              'needle'
            ));
          }
          this.burstShots--;
          this.burstSpacing = this.burstShots>0 ? this.burstSpacingBase : 0;
        }
      } else {
        this.fireTimer -= dt * this.aggression;
        if(this.fireTimer<=0){
          this.telegraphTimer = cfg.telegraph;
          this.fireTimer = this.fireInterval;
        }
      }
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const cfg = CONFIG.enemy.sentry;
      const telegraphing = this.telegraphTimer>0;
      const bursting = this.burstShots>0 && this.telegraphTimer<=0;
      const base = telegraphing ? '#fee2e2' : '#e0f2fe';
      const edge = telegraphing ? '#f97316' : '#38bdf8';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(-this.r*0.45, -this.r*0.28, this.r*0.9, this.r*0.56);
      ctx.fillStyle = telegraphing ? '#fb923c' : '#38bdf8';
      ctx.fillRect(-this.r*0.2, -this.r*0.62, this.r*0.95, this.r*0.24);
      if(bursting){
        ctx.globalAlpha = 0.35;
        ctx.fillRect(-this.r*0.2, -this.r*0.86, this.r*0.95, this.r*0.18);
      }
      ctx.restore();
      if(telegraphing){
        ctx.save();
        ctx.globalAlpha = 0.4 + 0.35*Math.sin(performance.now()/140);
        ctx.strokeStyle = '#fb923c';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r*1.8, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.14;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*140;
      this.knockVy = (vec.y/len)*140;
      return false;
    }
  }

  class EnemyDashling{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.dashling;
      this.x=x; this.y=y; this.r=11; this.hp=hp;
      this.speed = cfg.speed * randRange(0.9,1.1);
      this.dashSpeed = cfg.dashSpeed * randRange(0.9,1.05);
      this.dashDuration = cfg.dashDuration;
      this.windupDuration = cfg.windup;
      this.recoverDuration = cfg.recover;
      this.preferredRange = cfg.preferredRange;
      this.state='stalk';
      this.timer = randRange(0.8,1.4);
      this.dashDir = 0;
      this.windupProgress = 0;
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = false;
      this.strafeDir = rand()<0.5?-1:1;
      this.strafeSwapTimer = randRange(1.1,2.1);
      this.trail = [];
      this.tint = '#fb7185';
      this.tintLight = '#fecdd3';
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{
          enemy.dashSpeed = cfg.dashSpeed * scaling.speed;
        }
      });
      this.windupDuration = Math.max(0.35, this.windupDuration / Math.max(0.8, this.aggression));
      this.recoverDuration = Math.max(0.45, this.recoverDuration / Math.max(0.8, this.aggression));
      this.timer = Math.max(0.4, this.timer / Math.max(0.8, this.aggression));
    }
    update(dt){
      const cfg = CONFIG.enemy.dashling;
      for(const t of this.trail){ t.life -= dt; }
      this.trail = this.trail.filter(t=>t.life>0);
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.85;
        this.knockVy *= 0.85;
      } else {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        if(this.state==='stalk'){
          this.timer -= dt * this.aggression;
          this.strafeSwapTimer -= dt;
          if(this.strafeSwapTimer<=0){
            this.strafeDir *= -1;
            this.strafeSwapTimer = randRange(1.1,2.1);
          }
          let mx=0, my=0;
          if(distLen > this.preferredRange + 30){ mx = dx/distLen; my = dy/distLen; }
          else if(distLen < this.preferredRange - 40){ mx = -dx/distLen; my = -dy/distLen; }
          else {
            mx = -dy/distLen * this.strafeDir;
            my = dx/distLen * this.strafeDir;
          }
          this.x += mx * this.speed * dt;
          this.y += my * this.speed * dt;
          if(this.timer<=0){
            this.state='windup';
            this.timer = this.windupDuration;
            this.dashDir = Math.atan2(dy, dx);
            this.windupProgress = 0;
          }
        } else if(this.state==='windup'){
          this.timer -= dt * this.aggression;
          this.windupProgress = clamp(1 - this.timer/Math.max(0.001,this.windupDuration), 0, 1);
          this.x -= Math.cos(this.dashDir) * this.speed * 0.2 * dt;
          this.y -= Math.sin(this.dashDir) * this.speed * 0.2 * dt;
          if(this.timer<=0){
            this.state='dash';
            this.timer = this.dashDuration;
            this.trail.length = 0;
          }
        } else if(this.state==='dash'){
          this.x += Math.cos(this.dashDir) * this.dashSpeed * dt;
          this.y += Math.sin(this.dashDir) * this.dashSpeed * dt;
          this.timer -= dt;
          this.trail.push({x:this.x, y:this.y, life:0.18});
          if(this.timer<=0){
            this.state='recover';
            this.timer = this.recoverDuration;
          }
        } else if(this.state==='recover'){
          this.timer -= dt * this.aggression;
          this.x -= Math.cos(this.dashDir) * this.speed * 0.6 * dt;
          this.y -= Math.sin(this.dashDir) * this.speed * 0.6 * dt;
          if(this.timer<=0){
            this.state='stalk';
            this.timer = Math.max(0.4, randRange(0.8,1.4) / Math.max(0.8, this.aggression));
          }
        }
      }
      this.x = clamp(this.x, 34, CONFIG.roomW-34);
      this.y = clamp(this.y, 42, CONFIG.roomH-42);
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      ctx.save();
      for(const t of this.trail){
        const alpha = clamp(t.life/0.18, 0, 1);
        ctx.globalAlpha = alpha*0.5;
        drawBlob(t.x, t.y, this.r*0.9, '#fed7aa', '#f97316');
      }
      ctx.restore();
      const telegraphing = this.state==='windup';
      const dashing = this.state==='dash';
      const base = dashing ? '#fecdd3' : telegraphing ? '#fee2e2' : '#e0f2fe';
      const edge = dashing ? '#fb7185' : telegraphing ? '#f97316' : '#60a5fa';
      drawBlob(this.x,this.y,this.r,base,edge);
      if(telegraphing){
        ctx.save();
        ctx.globalAlpha = 0.35 + 0.25*Math.sin(performance.now()/80);
        ctx.strokeStyle = '#f97316';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r*2.1, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.16;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*150;
      this.knockVy = (vec.y/len)*150;
      if(this.state==='dash'){ this.state='recover'; this.timer = this.recoverDuration; }
      return false;
    }
  }

  class EnemyBurrower{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.burrower;
      this.x=x; this.y=y; this.r=13; this.hp=hp;
      this.speed = cfg.idleSpeed * randRange(0.9,1.1);
      this.burrowSpeed = cfg.burrowSpeed;
      this.emergeSpeed = cfg.emergeSpeed;
      this.burrowDuration = cfg.burrowTime;
      this.emergeDuration = cfg.emergeDuration;
      this.surfaceWindow = {min: cfg.surfaceMin, max: cfg.surfaceMax};
      this.state='surface';
      this.surfaceTimer = randRange(cfg.surfaceMin, cfg.surfaceMax);
      this.burrowTimer = 0;
      this.emergeTimer = 0;
      this.dashDir = 0;
      this.invulnerable = false;
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = false;
      this.wanderAngle = rand()*Math.PI*2;
      this.wanderTimer = randRange(0.6,1.2);
      this.tint = '#4ade80';
      this.tintLight = '#bbf7d0';
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{
          enemy.burrowSpeed = cfg.burrowSpeed * scaling.speed;
          enemy.emergeSpeed = cfg.emergeSpeed * scaling.speed;
          enemy.burrowDuration = Math.max(0.5, cfg.burrowTime / Math.max(0.8, scaling.aggression));
          enemy.emergeDuration = Math.max(0.25, cfg.emergeDuration / Math.max(0.8, scaling.aggression));
          const min = Math.max(0.7, cfg.surfaceMin / Math.max(0.9, scaling.aggression));
          const max = Math.max(min+0.3, cfg.surfaceMax / Math.max(0.9, scaling.aggression));
          enemy.surfaceWindow = {min, max};
        }
      });
      this.surfaceTimer = randRange(this.surfaceWindow.min, this.surfaceWindow.max);
    }
    update(dt){
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.84;
        this.knockVy *= 0.84;
        resolveEntityObstacles(this);
        return;
      }
      if(this.state==='surface'){
        this.surfaceTimer -= dt * this.aggression;
        this.wanderTimer -= dt;
        if(this.wanderTimer<=0){
          const bias = Math.atan2(player.y - this.y, player.x - this.x);
          this.wanderAngle = bias + randRange(-1.4,1.4);
          this.wanderTimer = randRange(0.7,1.3);
        }
        const mx = Math.cos(this.wanderAngle);
        const my = Math.sin(this.wanderAngle);
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        this.x += (mx*0.5 + (dx/distLen)*0.5) * this.speed * dt;
        this.y += (my*0.5 + (dy/distLen)*0.5) * this.speed * dt;
        resolveEntityObstacles(this);
        if(this.surfaceTimer<=0){
          this.state='burrow';
          this.burrowTimer = this.burrowDuration;
          this.invulnerable = true;
          this.emergeTarget = {x: player.x, y: player.y};
        }
      } else if(this.state==='burrow'){
        this.burrowTimer -= dt * this.aggression;
        if(this.emergeTarget){
          this.emergeTarget.x = clamp(this.emergeTarget.x + (player.x - this.emergeTarget.x)*dt*1.6, 38, CONFIG.roomW-38);
          this.emergeTarget.y = clamp(this.emergeTarget.y + (player.y - this.emergeTarget.y)*dt*1.6, 44, CONFIG.roomH-44);
          const dx = this.emergeTarget.x - this.x;
          const dy = this.emergeTarget.y - this.y;
          const distLen = Math.hypot(dx,dy)||1;
          this.x += (dx/distLen) * this.burrowSpeed * dt;
          this.y += (dy/distLen) * this.burrowSpeed * dt;
        }
        if(this.burrowTimer<=0){
          this.state='emerge';
          this.invulnerable = false;
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          this.dashDir = Math.atan2(dy, dx);
          this.emergeTimer = this.emergeDuration;
        }
      } else if(this.state==='emerge'){
        this.emergeTimer -= dt;
        this.x += Math.cos(this.dashDir) * this.emergeSpeed * dt;
        this.y += Math.sin(this.dashDir) * this.emergeSpeed * dt;
        resolveEntityObstacles(this);
        if(this.emergeTimer<=0){
          this.state='surface';
          this.surfaceTimer = randRange(this.surfaceWindow.min, this.surfaceWindow.max);
        }
      }
      this.x = clamp(this.x, 34, CONFIG.roomW-34);
      this.y = clamp(this.y, 42, CONFIG.roomH-42);
      if(this.state!=='burrow' && dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      if(this.state==='burrow'){
        ctx.save();
        const pulse = 0.6 + 0.4*Math.sin(performance.now()/90);
        ctx.globalAlpha = 0.4 + 0.3*pulse;
        ctx.fillStyle = '#0f172a';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + this.r*0.5, this.r*1.2, this.r*0.6, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#f59e0b55';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r*(1.1+0.2*pulse), 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
        return;
      }
      const emerging = this.state==='emerge';
      const base = emerging ? '#fde68a' : '#fef3c7';
      const edge = emerging ? '#f97316' : '#fbbf24';
      drawBlob(this.x,this.y,this.r,base,edge);
      if(emerging){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = '#f97316';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r*1.7, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    getShadowConfig(){
      if(this.state==='burrow'){
        return {visible:false};
      }
      return null;
    }
    damage(d){
      if(this.state==='burrow') return false;
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.18;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*160;
      this.knockVy = (vec.y/len)*160;
      return false;
    }
  }

  class EnemySpark{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.spark;
      this.base = {x,y};
      this.x=x; this.y=y; this.r=10; this.hp=hp;
      this.theta = rand()*Math.PI*2;
      this.range = randRange(cfg.rangeMin, cfg.rangeMax);
      this.orbitSpeed = cfg.orbitSpeed * randRange(0.85,1.15);
      this.driftSpeed = cfg.driftSpeed * randRange(0.85,1.1);
      this.fireInterval = cfg.fireInterval;
      this.burstSpacingBase = cfg.burstSpacing;
      this.projectileSpeed = cfg.projectileSpeed;
      this.projectileLife = cfg.projectileLife;
      this.fireTimer = randRange(this.fireInterval*0.5, this.fireInterval*1.2);
      this.burstShots = 0;
      this.burstSpacing = 0;
      this.glowOffset = rand()*Math.PI*2;
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = true;
      this.tint = '#fbbf24';
      this.tintLight = '#fef9c3';
      initializeEnemyStats(this, {
        speedFields:[],
        extra:(enemy, scaling)=>{
          enemy.driftSpeed = cfg.driftSpeed * scaling.speed;
          enemy.orbitSpeed = cfg.orbitSpeed * scaling.speed;
          enemy.projectileSpeed = cfg.projectileSpeed * scaling.speed;
          enemy.fireInterval = Math.max(1.2, cfg.fireInterval / Math.max(0.8, scaling.aggression));
          enemy.burstSpacingBase = Math.max(0.16, cfg.burstSpacing / Math.max(0.9, scaling.aggression));
        }
      });
      this.fireTimer = randRange(this.fireInterval*0.5, this.fireInterval*1.2);
    }
    update(dt){
      const cfg = CONFIG.enemy.spark;
      this.theta += this.orbitSpeed * dt;
      const dx = player.x - this.base.x;
      const dy = player.y - this.base.y;
      const distLen = Math.hypot(dx,dy)||1;
      this.base.x += (dx/distLen) * this.driftSpeed * 0.45 * dt;
      this.base.y += (dy/distLen) * this.driftSpeed * 0.45 * dt;
      this.base.x = clamp(this.base.x, 44, CONFIG.roomW-44);
      this.base.y = clamp(this.base.y, 48, CONFIG.roomH-48);
      this.x = this.base.x + Math.cos(this.theta) * this.range;
      this.y = this.base.y + Math.sin(this.theta) * this.range;
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.85;
        this.knockVy *= 0.85;
      }
      if(this.burstShots>0){
        this.burstSpacing -= dt;
        if(this.burstSpacing<=0){
          const bolts = Math.max(4, cfg.bolts|0);
          for(let i=0;i<bolts;i++){
            const angle = i*(Math.PI*2/bolts) + randRange(-0.08,0.08);
            runtime.enemyProjectiles.push(new EnemyProjectile(
              this.x,
              this.y,
              Math.cos(angle)*this.projectileSpeed,
              Math.sin(angle)*this.projectileSpeed,
              this.projectileLife,
              'spark'
            ));
          }
          this.burstShots--;
          this.burstSpacing = this.burstShots>0 ? this.burstSpacingBase : 0;
        }
      } else {
        this.fireTimer -= dt * this.aggression;
        if(this.fireTimer<=0){
          this.fireTimer = this.fireInterval;
          this.burstShots = cfg.burst;
          this.burstSpacing = 0;
        }
      }
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const pulse = 0.75 + 0.25*Math.sin(performance.now()/160 + this.glowOffset);
      const radius = this.r * (0.9 + 0.15*Math.sin(performance.now()/90 + this.glowOffset));
      const gradient = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, radius*1.6);
      gradient.addColorStop(0, '#fef9c3');
      gradient.addColorStop(0.5, '#fde047cc');
      gradient.addColorStop(1, '#fbbf24' + Math.floor(pulse*120).toString(16).padStart(2,'0'));
      ctx.save();
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = '#fde047';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(this.base.x, this.base.y, this.range, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.12;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*140;
      this.knockVy = (vec.y/len)*140;
      return false;
    }
  }

  class EnemyBrood{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.brood;
      this.x=x; this.y=y; this.r=14; this.hp=hp;
      this.speed = cfg.speed * randRange(0.9,1.1);
      this.preferredRange = cfg.preferredRange;
      this.spawnIntervalBase = cfg.spawnInterval;
      this.spawnTimer = randRange(cfg.spawnInterval*0.6, cfg.spawnInterval*1.1);
      this.maxMinions = cfg.spawnMax;
      this.minionSpread = cfg.minionSpread;
      this.minionRefs = [];
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = false;
      this.strafeDir = rand()<0.5?-1:1;
      initializeEnemyStats(this, {
        speedFields:['speed'],
        extra:(enemy, scaling)=>{
          enemy.spawnIntervalBase = Math.max(2.6, cfg.spawnInterval / Math.max(0.9, scaling.aggression));
          enemy.minionHp = Math.max(1, Math.round(1 * scaling.hp));
        }
      });
      this.spawnTimer = randRange(this.spawnIntervalBase*0.6, this.spawnIntervalBase*1.1);
      this.tint = '#f97316';
      this.tintLight = '#fde68a';
    }
    update(dt){
      this.minionRefs = this.minionRefs.filter(m=>m && !m.dead);
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.84;
        this.knockVy *= 0.84;
      } else {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        let mx=0, my=0;
        if(distLen < this.preferredRange - 30){ mx = -dx/distLen; my = -dy/distLen; }
        else if(distLen > this.preferredRange + 60){ mx = dx/distLen; my = dy/distLen; }
        else {
          mx = -dy/distLen * this.strafeDir;
          my = dx/distLen * this.strafeDir;
        }
        this.x += mx * this.speed * dt;
        this.y += my * this.speed * dt;
        if(rand()<0.01){ this.strafeDir *= -1; }
      }
      this.x = clamp(this.x, 40, CONFIG.roomW-40);
      this.y = clamp(this.y, 46, CONFIG.roomH-46);
      resolveEntityObstacles(this);
      this.spawnTimer -= dt * this.aggression;
      if(this.spawnTimer<=0 && this.minionRefs.length < this.maxMinions){
        if(dungeon?.current && dungeon.current.enemies.length < (CONFIG.enemy.maxPerRoom||5) + this.maxMinions){
          const angle = rand()*Math.PI*2;
          const radius = this.minionSpread;
          const spawnX = clamp(this.x + Math.cos(angle)*radius, 36, CONFIG.roomW-36);
          const spawnY = clamp(this.y + Math.sin(angle)*radius, 44, CONFIG.roomH-44);
          const minion = new EnemyTinyFly(spawnX, spawnY, Math.max(1, this.minionHp));
          minion.isBroodling = true;
          this.minionRefs.push(minion);
          queueEnemySpawn(minion);
        }
        this.spawnTimer = this.spawnIntervalBase;
      }
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const base = '#fde68a';
      const edge = '#f97316';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x,this.y - this.r*0.2);
      ctx.fillStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.32, -this.r*0.05, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.32, -this.r*0.05, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      if(this.minionRefs.length){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = '#f97316';
        ctx.setLineDash([4,3]);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.minionSpread*1.2, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.18;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*160;
      this.knockVy = (vec.y/len)*160;
      return false;
    }
  }

  class EnemySpiderLeaper{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.spider;
      this.x=x; this.y=y; this.r=13; this.hp=hp;
      this.state='idle';
      this.cooldown = randRange(1.2, cfg.cooldown);
      this.telegraphTimer = 0;
      this.leapDuration = 0;
      this.leapElapsed = 0;
      this.leapStart = {x,y};
      this.leapEnd = {x,y};
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.aggression = this.scaling.aggression;
      this.cooldownBase = Math.max(0.6, cfg.cooldown / this.aggression);
      this.cooldown = Math.max(0.4, this.cooldown / this.aggression);
      this.telegraphDuration = Math.max(0.2, cfg.telegraph / this.aggression);
      this.leapSpeed = cfg.leapSpeed * this.scaling.speed;
      this.tint = '#f87171';
      this.tintLight = '#fecaca';
    }
    beginLeap(){
      const cfg = CONFIG.enemy.spider;
      const targetX = clamp(player.x, 50, CONFIG.roomW-50);
      const targetY = clamp(player.y, 60, CONFIG.roomH-60);
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const distLen = Math.hypot(dx,dy)||1;
      const travel = Math.min(cfg.maxDistance, distLen);
      const nx = dx/distLen;
      const ny = dy/distLen;
      this.leapStart = {x:this.x, y:this.y};
      this.leapEnd = {
        x: clamp(this.x + nx*travel, 40, CONFIG.roomW-40),
        y: clamp(this.y + ny*travel, 46, CONFIG.roomH-46)
      };
      this.leapDuration = Math.max(0.2, travel / this.leapSpeed);
      this.leapElapsed = 0;
      this.state='leap';
    }
    update(dt){
      const cfg = CONFIG.enemy.spider;
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.85;
        this.knockVy *= 0.85;
        resolveEntityObstacles(this);
        return;
      }
      if(this.state==='idle'){
        this.cooldown -= dt * this.aggression;
        if(this.cooldown<=0){
          this.state='telegraph';
          this.telegraphTimer = this.telegraphDuration;
        }
      } else if(this.state==='telegraph'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.telegraphTimer<=0){
          this.beginLeap();
        }
      } else if(this.state==='leap'){
        this.leapElapsed = Math.min(this.leapDuration, this.leapElapsed + dt);
        const ratio = this.leapDuration>0 ? this.leapElapsed / this.leapDuration : 1;
        const ease = ratio<0.5 ? 2*ratio*ratio : -1 + (4 - 2*ratio)*ratio; // easeInOutQuad
        this.x = this.leapStart.x + (this.leapEnd.x - this.leapStart.x) * ease;
        this.y = this.leapStart.y + (this.leapEnd.y - this.leapStart.y) * ease;
        if(dist(this, player) < this.r + player.r){ player.hurt(1); }
        if(this.leapElapsed>=this.leapDuration){
          this.state='idle';
          this.cooldown = this.cooldownBase;
          this.x = this.leapEnd.x;
          this.y = this.leapEnd.y;
        }
      }
      if(this.state!=='leap'){ resolveEntityObstacles(this); }
      this.x = clamp(this.x, 36, CONFIG.roomW-36);
      this.y = clamp(this.y, 44, CONFIG.roomH-44);
    }
    getAltitude(){
      if(this.state!=='leap' || this.leapDuration<=0) return 0;
      const ratio = this.leapElapsed / this.leapDuration;
      return Math.sin(Math.PI * ratio);
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.2;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*180;
      this.knockVy = (vec.y/len)*180;
      return false;
    }
    draw(){
      const altitude = this.getAltitude();
      const telegraphing = this.state==='telegraph';
      const base = telegraphing ? '#fed7aa' : '#cbd5f5';
      const edge = telegraphing ? '#f97316' : '#8b5cf6';
      drawBlob(this.x, this.y - altitude*this.r*0.8, this.r, base, edge);
      ctx.save();
      ctx.translate(this.x, this.y - altitude*this.r*0.8);
      ctx.fillStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.35, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.35, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    getShadowConfig(){
      const altitude = clamp(this.getAltitude?.() ?? 0, 0, 1.2);
      return {
        x: this.x,
        y: this.y,
        radius: this.r,
        altitude,
        flying: altitude>0.05,
        alpha: 0.35 + 0.25*altitude,
        stretch: 0.6,
        scale: 1 - altitude*0.35,
      };
    }
  }

  class EnemyBoss{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(36);
      this.hp=70; this.maxHp=this.hp;
      this.name=name;
      this.state='idle';
      this.attackTimer=scaleBossTempo(1.5); this.chargeTimer=0; this.recoverTimer=0;
      this.hitFlash=0; this.enraged=false;
      this.telegraphTimer=0; this.telegraphTotal=0; this.telegraphType='';
      this.attackPlan=null; this.nextCooldown=0; this.afterChargePlan=null;
      this.isBossEntity = true;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.round(this.hp * this.scaling.hp);
      this.maxHp = this.hp;
      this.speedScale = this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.tint = '#fb7185';
      this.tintLight = '#fecaca';
    }
    update(dt){
      const drift = (40 + (this.enraged?25:0)) * this.speedScale;
      if(this.state==='charge'){
        this.chargeTimer -= dt * this.aggression;
        this.x += this.vx*dt; this.y += this.vy*dt;
        if(this.chargeTimer<=0){
          this.state='recover';
          const plan = this.afterChargePlan || {recover:scaleBossTempo(0.6), cooldown:scaleBossTempo(1.8)};
          this.recoverTimer = plan.recover;
          this.nextCooldown = plan.cooldown;
          this.afterChargePlan = null;
          this.telegraphType='';
        }
      } else {
        const to = {x: player.x - this.x, y: player.y - this.y};
        const l = Math.hypot(to.x,to.y)||1;
        const moveScale = this.state==='windup' ? 0.25 : 0.55;
        this.x += (to.x/l) * drift * dt * moveScale;
        this.y += (to.y/l) * drift * dt * moveScale;
        this.x += Math.cos(performance.now()/480) * 18 * dt;
        this.y += Math.sin(performance.now()/360) * 18 * dt;
        if(this.state==='recover'){
          this.recoverTimer -= dt * this.aggression;
          if(this.recoverTimer<=0){
            this.state='idle';
            this.attackTimer = this.nextCooldown || scaleBossTempo(this.enraged ? 1.6 : 2.2);
            this.nextCooldown = 0;
          }
        } else if(this.state==='windup'){
          this.telegraphTimer -= dt * this.aggression;
          if(this.telegraphTimer<=0){ this.executeAttackPlan(); }
        } else {
          this.attackTimer -= dt * this.aggression;
          if(this.attackTimer<=0){ this.chooseAttack(); }
        }
      }
      this.x = clamp(this.x, 90, CONFIG.roomW-90);
      this.y = clamp(this.y, 110, CONFIG.roomH-110);
      if(dist(this, player) < this.r + player.r - 2){ player.hurt(1); }
      resolveEntityObstacles(this);

      if(this.hitFlash>0) this.hitFlash -= dt;
      if(!this.enraged && this.hp <= this.maxHp*0.55){
        this.enraged=true;
        this.attackTimer = Math.min(this.attackTimer, scaleBossTempo(1.1));
      }
    }
    scheduleAttack(type, config, execute){
      const plan = {
        type,
        execute,
        recover: scaleBossTempo(config?.recover ?? 0.7),
        cooldown: scaleBossTempo(config?.cooldown ?? 1.8),
        post: config?.post || 'recover'
      };
      this.attackPlan = plan;
      this.telegraphType = type;
      const windup = scaleBossTempo(config?.windup ?? 0.6);
      this.telegraphTimer = Math.max(0.2, windup);
      this.telegraphTotal = this.telegraphTimer;
      this.state = 'windup';
    }
    executeAttackPlan(){
      const plan = this.attackPlan;
      if(!plan) return;
      this.attackPlan = null;
      this.telegraphTimer = 0;
      this.telegraphTotal = 0;
      plan.execute?.call(this);
      if(plan.post==='charge'){
        this.afterChargePlan = {recover: plan.recover, cooldown: plan.cooldown};
      } else {
        this.state='recover';
        this.recoverTimer = plan.recover;
        this.nextCooldown = plan.cooldown;
        this.telegraphType='';
      }
    }
    chooseAttack(){
      const roll = rand();
      const heavyThreshold = adjustBossHeavyThreshold(0.75);
      if(roll < 0.45){
        this.scheduleAttack('spray', {
          windup: this.enraged ? 0.65 : 0.85,
          recover: this.enraged ? 0.55 : 0.7,
          cooldown: this.enraged ? 1.6 : 2.2
        }, this.sprayAttack);
      } else if(roll < heavyThreshold){
        this.scheduleAttack('summon', {
          windup: this.enraged ? 0.75 : 0.95,
          recover: this.enraged ? 0.65 : 0.85,
          cooldown: this.enraged ? 2.0 : 2.6
        }, this.spawnMinions);
      } else {
        this.scheduleAttack('charge', {
          windup: this.enraged ? 0.7 : 0.95,
          recover: this.enraged ? 0.7 : 0.9,
          cooldown: this.enraged ? 2.4 : 3.2,
          post: 'charge'
        }, this.chargeAttack);
      }
    }
    sprayAttack(){
      const waves = this.enraged ? 3 : 2;
      for(let w=0; w<waves; w++){
        const base = rand()*Math.PI*2;
        const total = 10 + (this.enraged?4:0);
        for(let i=0;i<total;i++){
          const angle = base + (Math.PI*2/total)*i + w*0.12;
          const speed = 120 + rand()*40 + (this.enraged?30:0);
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
        }
      }
      // 指向性射流
      const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
      for(let k=0;k<4;k++){
        const angle = toPlayer + randRange(-0.4,0.4) + k*0.1*(this.enraged?1.2:0.6);
        const speed = 160 + rand()*90;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'needle'));
      }
    }
    spawnMinions(){
      const count = this.enraged ? 3 : 2;
      for(let i=0;i<count;i++){
        const angle = rand()*Math.PI*2;
        const radius = 90 + rand()*60;
        const pos = {x: clamp(this.x + Math.cos(angle)*radius, 70, CONFIG.roomW-70), y: clamp(this.y + Math.sin(angle)*radius, 70, CONFIG.roomH-70)};
        const minion = makeEnemy(rollEnemyType(dungeon.depth+2), pos, dungeon.depth+2);
        minion.r += 2;
        queueEnemySpawn(minion, {bossSummon:true, summoner:this});
      }
    }
    chargeAttack(){
      const to = {x: player.x - this.x, y: player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1;
      const speed = (this.enraged ? 300 : 240) * this.speedScale;
      this.vx = (to.x/l) * speed;
      this.vy = (to.y/l) * speed;
      this.state='charge';
      this.chargeTimer = 0.75;
    }
    damage(d){
      this.hp -= d;
      this.hitFlash = 0.18;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      let outer = this.hitFlash>0 ? '#ffd5dc' : '#ffb4c8';
      let edge = '#d946ef';
      if(this.state==='windup'){
        const ratio = this.telegraphTotal>0 ? clamp(1 - this.telegraphTimer/this.telegraphTotal, 0, 1) : 1;
        if(this.telegraphType==='spray'){
          outer = mixHexColor('#fffbeb', '#f97316', ratio*0.6 + 0.2);
          edge = '#f59e0b';
        } else if(this.telegraphType==='summon'){
          outer = mixHexColor('#ecfeff', '#22d3ee', ratio*0.6 + 0.2);
          edge = '#0ea5e9';
        } else if(this.telegraphType==='charge'){
          outer = mixHexColor('#fee2e2', '#ef4444', ratio*0.7 + 0.2);
          edge = '#dc2626';
        }
      }
      drawBlob(this.x,this.y,this.r, outer,edge);
      ctx.save();
      ctx.translate(this.x,this.y);
      const blink = this.enraged ? 1.5 : 1;
      ctx.fillStyle = this.enraged ? '#ffe5f2' : '#faf6ff';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.35, -this.r*0.15, this.r*0.25, this.r*0.35, 0, 0, Math.PI*2);
      ctx.ellipse(this.r*0.35, -this.r*0.15, this.r*0.25, this.r*0.35, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#151523';
      const eyeOffset = Math.sin(performance.now()/240)*this.r*0.12;
      ctx.beginPath();
      ctx.arc(-this.r*0.32, -this.r*0.12 + eyeOffset, this.r*0.12*blink, 0, Math.PI*2);
      ctx.arc(this.r*0.32, -this.r*0.12 - eyeOffset, this.r*0.12*blink, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#2f1d38';
      ctx.beginPath();
      ctx.moveTo(-this.r*0.4, this.r*0.1);
      ctx.quadraticCurveTo(0, this.r*0.28 + Math.sin(performance.now()/200)*4, this.r*0.4, this.r*0.1);
      ctx.quadraticCurveTo(0, this.r*0.5, -this.r*0.4, this.r*0.1);
      ctx.fill();
      ctx.restore();
      if(this.state==='windup' && this.telegraphType){
        ctx.save();
        const pulse = 0.5 + 0.45*Math.sin(performance.now()/90);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edge;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 14, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  class EnemyBossMaster{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(34);
      this.hp=85; this.maxHp=this.hp;
      this.name=name;
      this.state='idle';
      this.attackCooldown = scaleBossTempo(1.8);
      this.telegraphTimer = 0;
      this.hitFlash = 0;
      this.enraged=false;
      this.recoverTimer = 0;
      this.telegraphType = '';
      this.jumpStart = {x,y};
      this.jumpEnd = {x,y};
      this.jumpDuration = 0.8;
      this.jumpElapsed = 0;
      this.altitude = 0;
      this.isBossEntity = true;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.round(this.hp * this.scaling.hp);
      this.maxHp = this.hp;
      this.speedScale = this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.tint = '#f97316';
      this.tintLight = '#fed7aa';
    }
    update(dt){
      this.hitFlash = Math.max(0, this.hitFlash - dt*3.5);
      if(!this.enraged && this.hp <= this.maxHp*0.45){ this.enraged = true; }
      if(this.state==='idle'){
        this.attackCooldown -= dt * this.aggression;
        const drift = (this.enraged ? 95 : 70) * this.speedScale;
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        this.x += (dx/distLen) * drift * dt * 0.4;
        this.y += (dy/distLen) * drift * dt * 0.4;
        this.x += Math.cos(performance.now()/520) * 18 * dt;
        this.y += Math.sin(performance.now()/430) * 18 * dt;
        resolveEntityObstacles(this);
        if(this.attackCooldown<=0){ this.chooseAttack(); }
        this.altitude = Math.max(0, this.altitude - dt*2.8*this.aggression);
      } else if(this.state==='telegraph-jump' || this.state==='telegraph-wave'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.state==='telegraph-jump'){ this.altitude = 0.12 + 0.04*Math.sin(performance.now()/90); }
        else { this.altitude = Math.max(0, this.altitude - dt*3*this.aggression); }
        if(this.telegraphTimer<=0){
          if(this.state==='telegraph-jump'){ this.beginJump(); }
          else { this.performWave(); }
        }
      } else if(this.state==='jumping'){
        this.jumpElapsed = Math.min(this.jumpDuration, this.jumpElapsed + dt);
        const ratio = this.jumpDuration>0 ? this.jumpElapsed / this.jumpDuration : 1;
        const ease = ratio<0.5 ? 2*ratio*ratio : -1 + (4 - 2*ratio)*ratio;
        this.x = this.jumpStart.x + (this.jumpEnd.x - this.jumpStart.x) * ease;
        this.y = this.jumpStart.y + (this.jumpEnd.y - this.jumpStart.y) * ease;
        this.altitude = Math.sin(Math.PI * ratio);
        if(this.jumpElapsed>=this.jumpDuration){
          this.state='slam';
          this.altitude = 0;
          this.performSlam();
          this.recoverTimer = scaleBossTempo(this.enraged ? 0.6 : 0.75);
        }
      } else if(this.state==='slam'){
        this.recoverTimer -= dt * this.aggression;
        this.altitude = Math.max(0, this.altitude - dt*4*this.aggression);
        if(this.recoverTimer<=0){
          this.state='recover';
          this.attackCooldown = scaleBossTempo(this.enraged ? 1.2 : 1.6);
          this.recoverTimer = scaleBossTempo(this.enraged ? 0.5 : 0.7);
        }
      } else if(this.state==='wave'){
        this.recoverTimer -= dt * this.aggression;
        this.altitude = Math.max(0, this.altitude - dt*3.5*this.aggression);
        if(this.recoverTimer<=0){
          this.state='recover';
          this.attackCooldown = scaleBossTempo(this.enraged ? 1.35 : 1.8);
          this.recoverTimer = scaleBossTempo(this.enraged ? 0.45 : 0.6);
        }
      } else if(this.state==='recover'){
        this.recoverTimer -= dt * this.aggression;
        this.altitude = Math.max(0, this.altitude - dt*3*this.aggression);
        if(this.recoverTimer<=0){ this.state='idle'; }
      }
      this.x = clamp(this.x, 70, CONFIG.roomW-70);
      this.y = clamp(this.y, 90, CONFIG.roomH-90);
    }
    chooseAttack(){
      const jumpChance = applyBossHeavyChance(0.55);
      if(rand() < jumpChance){
        this.state='telegraph-jump';
        this.telegraphTimer = scaleBossTempo(this.enraged ? 1.05 : 1.3);
        this.telegraphTotal = this.telegraphTimer;
        this.telegraphType = 'jump';
      } else {
        this.state='telegraph-wave';
        this.telegraphTimer = scaleBossTempo(this.enraged ? 1.0 : 1.2);
        this.telegraphTotal = this.telegraphTimer;
        this.telegraphType = 'wave';
      }
    }
    beginJump(){
      this.telegraphType = '';
      this.telegraphTotal = 0;
      const maxTravel = this.enraged ? 360 : 320;
      const targetX = clamp(player.x, 80, CONFIG.roomW-80);
      const targetY = clamp(player.y, 96, CONFIG.roomH-96);
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const distLen = Math.hypot(dx,dy)||1;
      const travel = clamp(distLen, 140, maxTravel);
      const nx = dx/distLen;
      const ny = dy/distLen;
      this.jumpStart = {x:this.x, y:this.y};
      this.jumpEnd = {
        x: clamp(this.x + nx*travel, 70, CONFIG.roomW-70),
        y: clamp(this.y + ny*travel, 86, CONFIG.roomH-86)
      };
      const speed = (this.enraged ? 420 : 360) * this.speedScale;
      this.jumpDuration = Math.max(0.55, travel / speed);
      this.jumpElapsed = 0;
      this.state='jumping';
    }
    performSlam(){
      const radius = scaleBossRadius(90 + (this.enraged ? 20 : 0));
      if(player && dist(this, player) <= this.r + radius){
        player.hurt(2);
        player.applyImpulse(player.x - this.x, player.y - this.y, 220);
      }
      const shards = this.enraged ? 14 : 10;
      for(let i=0;i<shards;i++){
        const angle = (Math.PI*2/shards) * i;
        const speed = 180 + rand()*60 + (this.enraged?40:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'tear'));
      }
    }
    performWave(){
      this.telegraphType = '';
      this.telegraphTotal = 0;
      const bursts = this.enraged ? 5 : 4;
      const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
      const spread = 0.3;
      for(let lane=0; lane<bursts; lane++){
        const offset = (lane - (bursts-1)/2) * spread;
        const angle = baseAngle + offset;
        const speed = 220 + rand()*60 + (this.enraged?40:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
      }
      const secondary = this.enraged ? 8 : 6;
      for(let i=0;i<secondary;i++){
        const angle = baseAngle + randRange(-Math.PI, Math.PI);
        const speed = 140 + rand()*40;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 3.2, 'tear'));
      }
      const spawns = this.enraged ? 2 : 1;
      for(let k=0;k<spawns;k++){
        const ang = baseAngle + (k===0?Math.PI/2:-Math.PI/2) + randRange(-0.35,0.35);
        const distLen = 110 + rand()*60;
        const pos = {
          x: clamp(this.x + Math.cos(ang)*distLen, 80, CONFIG.roomW-80),
          y: clamp(this.y + Math.sin(ang)*distLen, 90, CONFIG.roomH-90)
        };
        queueEnemySpawn(makeEnemy('spider', pos, dungeon.depth+1), {bossSummon:true, summoner:this});
      }
      this.state='wave';
      this.recoverTimer = scaleBossTempo(this.enraged ? 0.8 : 1.0);
    }
    damage(d){
      if(this.state==='jumping'){ d *= 0.6; }
      this.hp -= d;
      this.hitFlash = 0.2;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      const telegraph = this.state==='telegraph-jump' || this.state==='telegraph-wave';
      const enraged = this.enraged;
      let base = this.hitFlash>0 ? '#ffe6ef' : (enraged ? '#f87171' : '#ffcad6');
      let edge = enraged ? '#ef4444' : '#f472b6';
      if(telegraph){
        const total = this.telegraphTotal || 1;
        const ratio = clamp(1 - this.telegraphTimer / total, 0, 1);
        if(this.telegraphType==='jump'){
          base = mixHexColor('#fff7ed', '#f97316', 0.3 + ratio*0.6);
          edge = '#ea580c';
        } else if(this.telegraphType==='wave'){
          base = mixHexColor('#fdf4ff', '#ec4899', 0.35 + ratio*0.55);
          edge = '#be185d';
        } else {
          base = '#fda4af';
          edge = '#fb7185';
        }
      }
      drawBlob(this.x, this.y - this.altitude*this.r*0.9, this.r, base, edge);
      ctx.save();
      ctx.translate(this.x, this.y - this.altitude*this.r*0.9);
      ctx.fillStyle = '#2d0f1f';
      ctx.beginPath();
      ctx.arc(-this.r*0.28, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.28, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#3f1d33';
      ctx.beginPath();
      ctx.moveTo(-this.r*0.4, this.r*0.15);
      ctx.quadraticCurveTo(0, this.r*(telegraph?0.45:0.35), this.r*0.4, this.r*0.15);
      ctx.quadraticCurveTo(0, this.r*(telegraph?0.55:0.45), -this.r*0.4, this.r*0.15);
      ctx.fill();
      ctx.restore();
      if(telegraph){
        ctx.save();
        const pulse = 0.6 + 0.25*Math.sin(performance.now()/90);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edge;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.altitude*this.r*0.9, this.r + 10, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  class EnemyBossHydra{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(34);
      this.hp=78; this.maxHp=this.hp;
      this.name=name;
      this.state='orbit';
      this.attackTimer=scaleBossTempo(1.5);
      this.hitFlash=0;
      this.enraged=false;
      this.rotation=rand()*Math.PI*2;
      this.anchorAngle=rand()*Math.PI*2;
      this.anchorRadius=124;
      this.headWiggle=rand()*Math.PI*2;
      this.spiralTimer=0;
      this.spiralCooldown=0;
      this.spiralDir=1;
      this.spiralAngle=0;
      this.pendingBursts=[];
      this.lastAttack='';
      this.isBossEntity=true;
      this.scaling=getFloorScalingFactors();
      this.hp=Math.round(this.hp*this.scaling.hp);
      this.maxHp=this.hp;
      this.speedScale=this.scaling.speed;
      this.aggression=this.scaling.aggression;
      this.tint = '#38bdf8';
      this.tintLight = '#bae6fd';
      this.telegraphTimer = 0;
      this.telegraphTotal = 0;
      this.telegraphType = '';
      this.recoverTimer = 0;
      this.nextCooldown = 0;
      this.attackPlan = null;
    }
    update(dt){
      if(!player) return;
      this.hitFlash = Math.max(0, this.hitFlash - dt*3.4);
      this.rotation += dt * 0.9 * this.speedScale;
      this.headWiggle += dt * 1.8;
      if(!this.enraged && this.hp <= this.maxHp*0.52){
        this.enraged = true;
        this.anchorRadius = 112;
      }
      this.anchorAngle += dt * (0.45 + (this.enraged?0.12:0)) * this.speedScale;
      const wave = Math.sin(performance.now()/520) * 10;
      const targetX = clamp(CONFIG.roomW/2 + Math.cos(this.anchorAngle)*(this.anchorRadius + wave), 78, CONFIG.roomW-78);
      const targetY = clamp(CONFIG.roomH/2 + Math.sin(this.anchorAngle)*(this.anchorRadius*0.72 + wave), 92, CONFIG.roomH-92);
      const followRate = Math.min(1, dt * 3.2);
      const moveScale = this.state==='windup' ? 0.55 : 1;
      this.x += (targetX - this.x) * followRate * moveScale;
      this.y += (targetY - this.y) * followRate * moveScale;
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r - 6){ player.hurt(1); }

      if(this.state==='windup'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.telegraphTimer<=0){ this.executeAttackPlan(); }
      } else if(this.state==='recover'){
        this.recoverTimer -= dt * this.aggression;
        if(this.recoverTimer<=0){
          this.state='orbit';
          this.attackTimer = this.nextCooldown || scaleBossTempo(this.enraged ? 1.6 : 2.0);
          this.nextCooldown = 0;
        }
      } else {
        this.attackTimer -= dt * this.aggression;
        if(this.attackTimer<=0){ this.chooseAttack(); }
      }

      for(let i=this.pendingBursts.length-1;i>=0;i--){
        const burst = this.pendingBursts[i];
        burst.delay -= dt * this.aggression;
        if(burst.delay<=0){
          this.executeBurst(burst);
          this.pendingBursts.splice(i,1);
        }
      }

      if(this.spiralTimer>0){
        this.spiralTimer = Math.max(0, this.spiralTimer - dt);
        this.spiralCooldown -= dt * this.aggression;
        if(this.spiralCooldown<=0){
          this.spiralCooldown += 0.08;
          this.spiralAngle += this.spiralDir * (0.32 + (this.enraged?0.05:0));
          const angle = this.spiralAngle;
          const speed = 150 + rand()*40 + (this.enraged?35:0);
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.8, 'tear'));
        }
      } else {
        this.spiralCooldown = 0;
      }
    }
    chooseAttack(){
      const baseOptions = [
        {type:'fans', weight:1},
        {type:'spiral', weight:BOSS_TUNING.heavyAttackWeight},
        {type:'orbs', weight:1},
      ];
      const options = baseOptions.slice();
      if(this.lastAttack){
        const idx = options.findIndex(opt => opt.type === this.lastAttack);
        if(idx>=0 && options.length>1){ options.splice(idx,1); }
      }
      const choice = pickWeightedOption(options) || options[0];
      const pick = choice?.type || (options[0]?.type ?? 'fans');
      this.lastAttack = pick;
      if(pick==='fans'){
        this.scheduleAttack('fans', {
          windup: this.enraged ? 0.75 : 0.95,
          recover: this.enraged ? 0.6 : 0.75,
          cooldown: this.enraged ? 1.7 : 2.1
        }, this.performFans);
      } else if(pick==='spiral'){
        this.scheduleAttack('spiral', {
          windup: this.enraged ? 0.8 : 1.0,
          recover: this.enraged ? 0.6 : 0.8,
          cooldown: this.enraged ? 1.6 : 2.0
        }, this.performSpiral);
      } else {
        this.scheduleAttack('orbs', {
          windup: this.enraged ? 0.85 : 1.05,
          recover: this.enraged ? 0.65 : 0.85,
          cooldown: this.enraged ? 1.8 : 2.2
        }, this.performOrbs);
      }
    }
    scheduleAttack(type, config, execute){
      this.attackPlan = {
        type,
        execute,
        recover: scaleBossTempo(config?.recover ?? 0.7),
        cooldown: scaleBossTempo(config?.cooldown ?? 1.8)
      };
      this.telegraphType = type;
      const windup = scaleBossTempo(config?.windup ?? 0.6);
      this.telegraphTimer = Math.max(0.25, windup);
      this.telegraphTotal = this.telegraphTimer;
      this.state='windup';
    }
    executeAttackPlan(){
      const plan = this.attackPlan;
      if(!plan) return;
      this.attackPlan = null;
      this.telegraphTimer = 0;
      plan.execute?.call(this);
      this.state='recover';
      this.recoverTimer = plan.recover;
      this.nextCooldown = plan.cooldown;
      this.telegraphType = '';
      this.telegraphTotal = 0;
    }
    performFans(){
      const waves = this.enraged ? 3 : 2;
      for(let w=0; w<waves; w++){
        this.pendingBursts.push({type:'fan', delay:w*0.22, count:this.enraged?7:6, spread:0.48});
      }
      spawnCircularEffect(this.x, this.y, this.r+14, {innerColor:'#cffafe', midColor:'#38bdf8', outerColor:'#0ea5e9'});
    }
    performSpiral(){
      this.spiralTimer = this.enraged ? 1.35 : 1.15;
      this.spiralDir = rand() < 0.5 ? -1 : 1;
      this.spiralAngle = Math.atan2((player?.y ?? this.y) - this.y, (player?.x ?? this.x) - this.x);
      this.spiralCooldown = 0;
      spawnCircularEffect(this.x, this.y, this.r+10, {innerColor:'#ecfeff', midColor:'#67e8f9', outerColor:'#22d3ee'});
    }
    performOrbs(){
      const count = this.enraged ? 4 : 3;
      for(let i=0;i<count;i++){
        const angle = (Math.PI*2/count)*i + randRange(-0.2,0.2);
        const radius = 68 + rand()*14;
        runtime.enemyProjectiles.push(new HydraOrb(this.x, this.y, {
          centerRef: this,
          angle,
          radius,
          orbitSpeed: 1.8 + randRange(-0.2,0.2),
          windup: (this.enraged?0.5:0.65),
          dashSpeed: 210 + rand()*40 + (this.enraged?50:0),
          damage: this.enraged?2:1,
          color: this.enraged ? '#34d399' : '#22d3ee',
        }));
      }
      spawnCircularEffect(this.x, this.y, this.r+18, {innerColor:'#ccfbf1', midColor:'#34d399', outerColor:'#0ea5e9'});
    }
    executeBurst(burst){
      if(burst.type!=='fan') return;
      const headAngles = this.getHeadAngles();
      const count = Math.max(3, burst.count|0);
      const spread = burst.spread ?? 0.4;
      for(const base of headAngles){
        for(let i=0;i<count;i++){
          const offset = count>1 ? (i - (count-1)/2) : 0;
          const angle = base + offset * spread / Math.max(1, (count-1) || 1);
          const speed = 170 + rand()*45 + (this.enraged?35:0);
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.4, 'tear'));
        }
      }
    }
    getHeadAngles(){
      const count = this.enraged ? 4 : 3;
      const base = Math.atan2((player?.y ?? this.y) - this.y, (player?.x ?? this.x) - this.x);
      const separation = 0.55;
      const angles = [];
      for(let i=0;i<count;i++){
        const offset = (i - (count-1)/2) * separation;
        angles.push(base + offset + Math.sin(this.headWiggle + i)*0.18);
      }
      return angles;
    }
    damage(d){
      this.hp -= d;
      this.hitFlash = 0.2;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      let baseColor = this.hitFlash>0 ? '#d1fae5' : (this.enraged ? '#99f6e4' : '#bae6fd');
      let edgeColor = this.enraged ? '#14b8a6' : '#38bdf8';
      if(this.state==='windup' && this.telegraphType){
        const total = this.telegraphTotal || 1;
        const ratio = clamp(1 - this.telegraphTimer / total, 0, 1);
        if(this.telegraphType==='fans'){
          baseColor = mixHexColor('#ecfeff', '#38bdf8', 0.35 + ratio*0.5);
          edgeColor = '#0ea5e9';
        } else if(this.telegraphType==='spiral'){
          baseColor = mixHexColor('#f0fdfa', '#34d399', 0.3 + ratio*0.55);
          edgeColor = '#059669';
        } else if(this.telegraphType==='orbs'){
          baseColor = mixHexColor('#f0f9ff', '#22d3ee', 0.4 + ratio*0.45);
          edgeColor = '#0284c7';
        }
      }
      drawBlob(this.x, this.y, this.r, baseColor, edgeColor);
      ctx.save();
      ctx.translate(this.x, this.y);
      const headAngles = this.getHeadAngles();
      for(const angle of headAngles){
        const distR = this.r*0.95;
        const hx = Math.cos(angle) * distR;
        const hy = Math.sin(angle) * distR;
        ctx.save();
        ctx.translate(hx, hy);
        ctx.rotate(angle);
        ctx.fillStyle = '#0f172a';
        ctx.beginPath();
        ctx.ellipse(0,0,this.r*0.32,this.r*0.22,0,0,Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#e0f2fe';
        ctx.beginPath();
        ctx.arc(this.r*0.12,0,this.r*0.14,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
      ctx.fillStyle = '#0f172a';
      ctx.beginPath();
      ctx.arc(0,0,this.r*0.28,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#67e8f9';
      ctx.beginPath();
      ctx.arc(0,0,this.r*0.14 + Math.sin(performance.now()/220)*1.4,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      if(this.state==='windup' && this.telegraphType){
        ctx.save();
        const pulse = 0.5 + 0.3*Math.sin(performance.now()/100);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edgeColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 12, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
      if(this.spiralTimer>0){
        ctx.save();
        ctx.globalAlpha = 0.35 + 0.25*Math.sin(performance.now()/120);
        ctx.strokeStyle = '#0ea5e9';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r+14, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    getShadowConfig(){
      const altitude = clamp(Number(this.altitude) || 0, 0, 1.2);
      return {
        x: this.x,
        y: this.y,
        radius: this.r,
        altitude,
        flying: altitude>0.05,
        alpha: 0.4 + 0.3*altitude,
        stretch: 0.6,
        scale: 1 - altitude*0.4,
      };
    }
  }

  class EnemyBossSeer{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(30);
      this.hp=74; this.maxHp=this.hp;
      this.name=name;
      this.state='glide';
      this.attackTimer=scaleBossTempo(1.4);
      this.telegraphTimer=0;
      this.telegraphTotal=scaleBossTempo(0.5);
      this.channelTimer=0;
      this.channelType='';
      this.channelTotal=0;
      this.channelDirection=0;
      this.fade=1;
      this.hitFlash=0;
      this.enraged=false;
      this.phase=rand()*Math.PI*2;
      this.runes=[];
      this.lastAttack='';
      this.nextAttackType='';
      this.warpTarget={x,y};
      this.recoverTimer=scaleBossTempo(0.6);
      this.isBossEntity=true;
      this.scaling=getFloorScalingFactors();
      this.hp=Math.round(this.hp*this.scaling.hp);
      this.maxHp=this.hp;
      this.speedScale=this.scaling.speed;
      this.aggression=this.scaling.aggression;
      this.tint = '#a855f7';
      this.tintLight = '#ede9fe';
    }
    update(dt){
      this.hitFlash = Math.max(0, this.hitFlash - dt*3.1);
      if(!this.enraged && this.hp <= this.maxHp*0.5){ this.enraged = true; }
      if(this.runes?.length){ this.updateRunes(dt); }
      if(this.state==='glide') this.handleGlide(dt);
      else if(this.state==='warp') this.handleWarp(dt);
      else if(this.state==='channel') this.handleChannel(dt);
      else if(this.state==='recover') this.handleRecover(dt);
    }
    handleGlide(dt){
      this.phase += dt * (0.6 + this.aggression*0.18);
      const orbitRadius = 122 + (this.enraged?12:0);
      const targetX = clamp(CONFIG.roomW/2 + Math.cos(this.phase)*orbitRadius, 70, CONFIG.roomW-70);
      const targetY = clamp(CONFIG.roomH/2 + Math.sin(this.phase*0.7)*(orbitRadius*0.6), 88, CONFIG.roomH-88);
      this.x += (targetX - this.x) * dt * 2.4;
      this.y += (targetY - this.y) * dt * 2.4;
      if(player){
        this.x += (player.x - this.x) * 0.08 * dt;
        this.y += (player.y - this.y) * 0.08 * dt;
      }
      resolveEntityObstacles(this);
      this.attackTimer -= dt * this.aggression;
      if(this.attackTimer<=0){ this.chooseAttack(); }
    }
    handleWarp(dt){
      this.telegraphTimer -= dt * this.aggression;
      const ratio = this.telegraphTotal>0 ? this.telegraphTimer / this.telegraphTotal : 0;
      this.fade = clamp(ratio, 0.35, 1);
      if(this.telegraphTimer<=0){
        this.x = this.warpTarget.x;
        this.y = this.warpTarget.y;
        spawnCircularEffect(this.x, this.y, this.r+14, {innerColor:'#ede9fe', midColor:'#c084fc', outerColor:'#a855f7'});
        this.state='channel';
        this.channelType=this.nextAttackType;
        const base = this.channelType==='lance' ? 0.58 : (this.channelType==='mirror'?0.65:0.7);
        let channel = scaleBossTempo(base);
        if(this.enraged) channel *= 0.9;
        this.channelTimer = channel;
        this.channelTotal = channel;
        this.channelDirection = Math.atan2((player?.y ?? this.y) - this.y, (player?.x ?? this.x) - this.x);
        this.fade = 1;
      }
    }
    handleChannel(dt){
      this.channelTimer -= dt * this.aggression;
      if(this.channelTimer<=0){
        this.executeAttack(this.channelType);
        this.state='recover';
      }
    }
    handleRecover(dt){
      this.recoverTimer -= dt * this.aggression;
      if(this.recoverTimer<=0){
        this.state='glide';
        this.fade = 1;
        this.channelTotal = 0;
      }
    }
    chooseAttack(){
      const baseOptions = [
        {type:'lance', weight:1},
        {type:'mirror', weight:1},
        {type:'meteor', weight:BOSS_TUNING.heavyAttackWeight},
      ];
      const options = baseOptions.slice();
      if(this.lastAttack){
        const idx = options.findIndex(opt => opt.type===this.lastAttack);
        if(idx>=0 && options.length>1){ options.splice(idx,1); }
      }
      const choice = pickWeightedOption(options) || options[0];
      const pick = choice?.type || (options[0]?.type ?? 'lance');
      this.lastAttack = pick;
      this.startWarp(pick);
    }
    startWarp(type){
      this.state='warp';
      this.nextAttackType = type;
      const baseWindup = type==='lance' ? 0.65 : (type==='mirror' ? 0.7 : 0.75);
      let windup = scaleBossTempo(baseWindup);
      if(this.enraged) windup *= 0.85;
      this.telegraphTotal = windup;
      this.telegraphTimer = windup;
      if(type==='lance' && player){
        const distTarget = this.enraged ? 210 : 240;
        const angle = Math.atan2(player.y - this.y, player.x - this.x) + Math.PI;
        this.warpTarget = {
          x: clamp(player.x + Math.cos(angle)*distTarget, 70, CONFIG.roomW-70),
          y: clamp(player.y + Math.sin(angle)*distTarget, 80, CONFIG.roomH-80),
        };
      } else if(type==='mirror'){
        this.warpTarget = {
          x: clamp(CONFIG.roomW/2 + randRange(-40,40), 70, CONFIG.roomW-70),
          y: clamp(CONFIG.roomH/2 + randRange(-40,40), 90, CONFIG.roomH-90),
        };
      } else {
        const px = player?.x ?? CONFIG.roomW/2;
        this.warpTarget = {
          x: clamp(px + randRange(-60,60), 70, CONFIG.roomW-70),
          y: clamp(CONFIG.roomH/2 - 90 + randRange(-20,20), 80, CONFIG.roomH-90),
        };
      }
    }
    executeAttack(type){
      if(type==='lance') this.performLance();
      else if(type==='mirror') this.performMirror();
      else this.performMeteor();
    }
    performLance(){
      const count = this.enraged ? 5 : 4;
      const baseAngle = this.channelDirection;
      for(let i=0;i<count;i++){
        const offset = count>1 ? (i - (count-1)/2) * 0.08 : 0;
        const angle = baseAngle + offset;
        const speed = 230 + rand()*40 + (this.enraged?45:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'needle'));
      }
      const side = this.enraged ? 6 : 4;
      for(let i=0;i<side;i++){
        const angle = baseAngle + randRange(-0.5,0.5);
        const speed = 150 + rand()*50;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
      }
      addScreenShake(4,0.25);
      spawnCircularEffect(this.x, this.y, this.r+16, {innerColor:'#ede9fe', midColor:'#c4b5fd', outerColor:'#a855f7'});
      this.recoverTimer = scaleBossTempo(this.enraged?0.7:0.85);
      this.attackTimer = scaleBossTempo(this.enraged?1.2:1.5);
    }
    performMirror(){
      const centerX = CONFIG.roomW/2;
      const centerY = CONFIG.roomH/2;
      const count = this.enraged ? 5 : 4;
      const radius = 150 + (this.enraged?12:0);
      this.runes = [];
      for(let i=0;i<count;i++){
        const angle = (Math.PI*2/count)*i;
        const rune = {
          x: clamp(centerX + Math.cos(angle)*radius, 60, CONFIG.roomW-60),
          y: clamp(centerY + Math.sin(angle)*radius, 80, CONFIG.roomH-80),
          timer: scaleBossTempo((0.35 + i*0.1) * (this.enraged?0.85:1)),
          fired:false,
          life:1.1,
        };
        this.runes.push(rune);
      }
      spawnCircularEffect(centerX, centerY, radius+12, {innerColor:'#ede9fe', midColor:'#c4b5fd', outerColor:'#a855f7'});
      this.recoverTimer = scaleBossTempo(this.enraged?0.75:0.95);
      this.attackTimer = scaleBossTempo(this.enraged?1.35:1.65);
    }
    performMeteor(){
      const count = this.enraged ? 8 : 6;
      for(let i=0;i<count;i++){
        const offsetX = randRange(-140,140);
        const spawnX = clamp((player?.x ?? CONFIG.roomW/2) + offsetX, 60, CONFIG.roomW-60);
        runtime.enemyProjectiles.push(new FallingShard(spawnX, 40 - rand()*30, {
          vx: randRange(-20,20),
          vy: 160 + rand()*40,
          accel: 260 + (this.enraged?60:0),
          ground: CONFIG.roomH - 46,
          damage: this.enraged?2:1,
          color: '#a855f7',
        }));
      }
      this.recoverTimer = scaleBossTempo(this.enraged?0.8:1.0);
      this.attackTimer = scaleBossTempo(this.enraged?1.4:1.7);
    }
    updateRunes(dt){
      for(let i=this.runes.length-1;i>=0;i--){
        const rune = this.runes[i];
        rune.timer -= dt * this.aggression;
        if(!rune.fired && rune.timer<=0){
          this.fireRune(rune);
        }
        rune.life -= dt;
        if(rune.life<=0){ this.runes.splice(i,1); }
      }
    }
    fireRune(rune){
      const targetX = player?.x ?? this.x;
      const targetY = player?.y ?? this.y;
      const angle = Math.atan2(targetY - rune.y, targetX - rune.x);
      const speed = 210 + rand()*40 + (this.enraged?50:0);
      runtime.enemyProjectiles.push(new EnemyProjectile(rune.x, rune.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.8, 'needle'));
      runtime.enemyProjectiles.push(new EnemyProjectile(rune.x, rune.y, Math.cos(angle+randRange(-0.2,0.2))*speed*0.75, Math.sin(angle+randRange(-0.2,0.2))*speed*0.75, 4.4, 'tear'));
      spawnCircularEffect(rune.x, rune.y, 20, {innerColor:'#ede9fe', midColor:'#c4b5fd', outerColor:'#a855f7'});
      rune.fired = true;
      rune.life = 0.5;
    }
    damage(d){
      this.hp -= d;
      this.hitFlash = 0.18;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      ctx.save();
      ctx.globalAlpha = this.fade;
      let baseColor = this.hitFlash>0 ? '#fdf4ff' : (this.enraged ? '#e9d5ff' : '#ede9fe');
      let edgeColor = this.enraged ? '#a855f7' : '#c084fc';
      if(this.state==='warp' || this.state==='channel'){
        const type = this.state==='warp' ? this.nextAttackType : this.channelType;
        const total = this.telegraphTotal || 1;
        const ratio = this.state==='warp' ? clamp(1 - this.telegraphTimer / total, 0, 1) : clamp(1 - this.channelTimer / Math.max(this.channelTotal || 1, 1e-3), 0, 1);
        if(type==='lance'){
          baseColor = mixHexColor('#fdf2f8', '#f472b6', 0.3 + ratio*0.5);
          edgeColor = '#db2777';
        } else if(type==='mirror'){
          baseColor = mixHexColor('#ede9fe', '#c084fc', 0.35 + ratio*0.45);
          edgeColor = '#7c3aed';
        } else if(type==='meteor'){
          baseColor = mixHexColor('#f5f3ff', '#f97316', 0.25 + ratio*0.55);
          edgeColor = '#ea580c';
        }
      }
      drawBlob(this.x, this.y, this.r, baseColor, edgeColor);
      ctx.translate(this.x, this.y);
      ctx.save();
      ctx.rotate(Math.sin(performance.now()/600)*0.1);
      ctx.fillStyle = '#0f172a';
      ctx.beginPath();
      ctx.ellipse(0,0,this.r*0.35,this.r*0.5,0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#e0f2fe';
      ctx.beginPath();
      ctx.arc(0,-this.r*0.05,this.r*0.2,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#0f172a';
      ctx.beginPath();
      ctx.arc(0,-this.r*0.05,this.r*0.1,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.restore();
      if(this.state==='channel' && this.channelType==='lance'){
        ctx.save();
        ctx.globalAlpha = 0.7 + 0.2*Math.sin(performance.now()/80);
        ctx.strokeStyle = '#c084fc';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        const endX = this.x + Math.cos(this.channelDirection) * 260;
        const endY = this.y + Math.sin(this.channelDirection) * 260;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.restore();
      }
      if(this.runes){
        for(const rune of this.runes){
          ctx.save();
          const glow = rune.fired ? '#fbbf24' : '#c084fc';
          ctx.globalAlpha = 0.45 + 0.35*Math.sin(performance.now()/130 + (rune.timer||0)*3);
          ctx.strokeStyle = glow;
          ctx.lineWidth = rune.fired ? 3 : 2;
          ctx.beginPath();
          ctx.arc(rune.x, rune.y, 16 + (rune.fired?4:0), 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
      }
      if(this.state==='warp'){
        ctx.save();
        const pulse = 0.55 + 0.25*Math.sin(performance.now()/100);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edgeColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 14, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  class EnemyBossTitan{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(36);
      this.hp=90; this.maxHp=this.hp;
      this.name=name;
      this.state='stalk';
      this.attackTimer=scaleBossTempo(1.8);
      this.recoverTimer=scaleBossTempo(0.7);
      this.leapTimer=0;
      this.leapDuration=0.7;
      this.leapStart={x,y};
      this.leapEnd={x,y};
      this.altitude=0;
      this.hitFlash=0;
      this.enraged=false;
      this.pendingEvents=[];
      this.lastAttack='';
      this.isBossEntity=true;
      this.scaling=getFloorScalingFactors();
      this.hp=Math.round(this.hp*this.scaling.hp);
      this.maxHp=this.hp;
      this.speedScale=this.scaling.speed;
      this.aggression=this.scaling.aggression;
      this.tint = '#f59e0b';
      this.tintLight = '#fef3c7';
      this.telegraphTimer = 0;
      this.telegraphTotal = 0;
      this.telegraphType = '';
      this.attackPlan = null;
      this.nextCooldown = 0;
      this.afterLeapPlan = null;
      this.manualRecoverPlan = null;
      this.activeAttack = '';
    }
    update(dt){
      this.hitFlash = Math.max(0, this.hitFlash - dt*3.2);
      if(!this.enraged && this.hp <= this.maxHp*0.55){ this.enraged = true; }
      if(this.state==='windup') this.handleWindup(dt);
      else if(this.state==='stalk') this.handleStalk(dt);
      else if(this.state==='leap') this.handleLeap(dt);
      else if(this.state==='brace') this.handleBrace(dt);
      else if(this.state==='recover') this.handleRecover(dt);
      for(let i=this.pendingEvents.length-1;i>=0;i--){
        const evt = this.pendingEvents[i];
        evt.delay -= dt * this.aggression;
        if(evt.delay<=0){
          this.executeEvent(evt);
          this.pendingEvents.splice(i,1);
        }
      }
    }
    handleStalk(dt){
      if(player){
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        const speed = (this.enraged?105:85) * this.speedScale;
        this.x += Math.cos(angle) * speed * dt * 0.8;
        this.y += Math.sin(angle) * speed * dt * 0.8;
      }
      this.x += Math.cos(performance.now()/480) * 16 * dt;
      this.y += Math.sin(performance.now()/380) * 14 * dt;
      this.x = clamp(this.x, 80, CONFIG.roomW-80);
      this.y = clamp(this.y, 96, CONFIG.roomH-96);
      resolveEntityObstacles(this);
      if(player && dist(this, player) < this.r + player.r - 4){ player.hurt(1); }
      this.attackTimer -= dt * this.aggression;
      if(this.attackTimer<=0){ this.chooseAttack(); }
    }
    handleWindup(dt){
      if(player){
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        const speed = (this.enraged?105:85) * this.speedScale * 0.45;
        this.x += Math.cos(angle) * speed * dt;
        this.y += Math.sin(angle) * speed * dt;
      }
      this.x += Math.cos(performance.now()/520) * 12 * dt;
      this.y += Math.sin(performance.now()/420) * 10 * dt;
      this.x = clamp(this.x, 80, CONFIG.roomW-80);
      this.y = clamp(this.y, 96, CONFIG.roomH-96);
      resolveEntityObstacles(this);
      this.telegraphTimer -= dt * this.aggression;
      if(this.telegraphTimer<=0){ this.executeAttackPlan(); }
    }
    handleLeap(dt){
      this.leapTimer += dt * this.aggression;
      const ratio = Math.min(1, this.leapTimer / this.leapDuration);
      const ease = ratio<0.5 ? 2*ratio*ratio : -1 + (4 - 2*ratio)*ratio;
      this.x = this.leapStart.x + (this.leapEnd.x - this.leapStart.x) * ease;
      this.y = this.leapStart.y + (this.leapEnd.y - this.leapStart.y) * ease;
      this.altitude = Math.sin(Math.PI * ratio);
      if(ratio>=1){
        this.state='recover';
        this.altitude = 0;
        const plan = this.afterLeapPlan || {recover:scaleBossTempo(this.enraged?0.55:0.7), cooldown:scaleBossTempo(this.enraged?1.3:1.6)};
        this.recoverTimer = plan.recover;
        this.nextCooldown = plan.cooldown;
        this.afterLeapPlan = null;
        this.telegraphType='';
        this.performSlamImpact();
      }
    }
    handleBrace(dt){
      this.telegraphTimer -= dt * this.aggression;
      this.altitude = Math.max(0, this.altitude - dt*2.4);
      if(this.telegraphTimer<=0){
        this.performQuakeImpact();
        this.state='recover';
        const plan = this.manualRecoverPlan || {recover:scaleBossTempo(this.enraged?0.6:0.8), cooldown:scaleBossTempo(this.enraged?1.4:1.7)};
        this.recoverTimer = plan.recover;
        this.nextCooldown = plan.cooldown;
        this.manualRecoverPlan = null;
      }
    }
    handleRecover(dt){
      this.recoverTimer -= dt * this.aggression;
      if(this.recoverTimer<=0){
        this.state='stalk';
        this.altitude = 0;
        this.attackTimer = this.nextCooldown || scaleBossTempo(this.enraged?1.3:1.6);
        this.nextCooldown = 0;
        this.telegraphType='';
        this.telegraphTotal=0;
        this.activeAttack='';
      }
    }
    chooseAttack(){
      const baseOptions = [
        {type:'slam', weight:1},
        {type:'quake', weight:BOSS_TUNING.heavyAttackWeight},
        {type:'boulder', weight:1},
      ];
      const options = baseOptions.slice();
      if(this.lastAttack){
        const idx = options.findIndex(opt => opt.type===this.lastAttack);
        if(idx>=0 && options.length>1){ options.splice(idx,1); }
      }
      const choice = pickWeightedOption(options) || options[0];
      const pick = choice?.type || (options[0]?.type ?? 'slam');
      this.lastAttack = pick;
      if(pick==='slam'){
        this.scheduleAttack('slam', {
          windup: this.enraged ? 0.9 : 1.15,
          recover: this.enraged ? 0.55 : 0.75,
          cooldown: this.enraged ? 1.3 : 1.6,
          post: 'leap'
        }, this.startLeap);
      } else if(pick==='quake'){
        this.scheduleAttack('quake', {
          windup: this.enraged ? 0.7 : 0.95,
          recover: this.enraged ? 0.7 : 0.9,
          cooldown: this.enraged ? 1.4 : 1.7,
          post: 'manual'
        }, this.startQuake);
      } else {
        this.scheduleAttack('boulder', {
          windup: this.enraged ? 0.65 : 0.85,
          recover: this.enraged ? 0.65 : 0.85,
          cooldown: this.enraged ? 1.3 : 1.55
        }, this.startBoulder);
      }
    }
    scheduleAttack(type, config={}, execute){
      this.attackPlan = {
        type,
        execute,
        recover: scaleBossTempo(config.recover ?? 0.7),
        cooldown: scaleBossTempo(config.cooldown ?? 1.6),
        post: config.post || 'recover'
      };
      this.telegraphType = type;
      const windup = scaleBossTempo(config.windup ?? 0.6);
      this.telegraphTimer = Math.max(0.3, windup);
      this.telegraphTotal = this.telegraphTimer;
      this.state='windup';
    }
    executeAttackPlan(){
      const plan = this.attackPlan;
      if(!plan) return;
      this.attackPlan = null;
      const type = plan.type;
      this.telegraphTimer = 0;
      this.telegraphType='';
      this.telegraphTotal=0;
      plan.execute?.call(this);
      this.activeAttack = type;
      if(plan.post==='leap'){
        this.afterLeapPlan = {recover: plan.recover, cooldown: plan.cooldown};
      } else if(plan.post==='manual'){
        this.manualRecoverPlan = {recover: plan.recover, cooldown: plan.cooldown};
      } else {
        this.state='recover';
        this.recoverTimer = plan.recover;
        this.nextCooldown = plan.cooldown;
      }
    }
    startLeap(){
      this.state='leap';
      this.leapStart = {x:this.x, y:this.y};
      const target = player ? {x:player.x, y:player.y} : {x:CONFIG.roomW/2, y:CONFIG.roomH/2};
      const dx = target.x - this.x;
      const dy = target.y - this.y;
      const len = Math.hypot(dx,dy)||1;
      const travel = clamp(len, 120, 260);
      const nx = dx/len;
      const ny = dy/len;
      this.leapEnd = {
        x: clamp(this.x + nx*travel, 80, CONFIG.roomW-80),
        y: clamp(this.y + ny*travel, 96, CONFIG.roomH-96),
      };
      const speed = (this.enraged?320:280) * this.speedScale;
      this.leapDuration = Math.max(0.55, travel / speed);
      this.leapTimer = 0;
      spawnCircularEffect(this.x, this.y, this.r+12, {innerColor:'#fef3c7', midColor:'#facc15', outerColor:'#f97316'});
    }
    startQuake(){
      this.state='brace';
      this.telegraphTimer = scaleBossTempo(this.enraged?0.85:1.05);
      this.altitude = 0;
      spawnCircularEffect(this.x, this.y, this.r+24, {innerColor:'#fef3c7', midColor:'#fcd34d', outerColor:'#f97316'});
      const pulses = this.enraged ? 3 : 2;
      for(let i=0;i<pulses;i++){
        this.pendingEvents.push({type:'quakePulse', delay:scaleBossTempo(0.1 + i*0.22), power:i});
      }
    }
    startBoulder(){
      this.activeAttack = 'boulder';
      const count = this.enraged ? 3 : 2;
      for(let i=0;i<count;i++){
        const angle = Math.atan2((player?.y ?? this.y) - this.y, (player?.x ?? this.x) - this.x) + randRange(-0.4,0.4);
        const speed = 180 + rand()*40;
        runtime.enemyProjectiles.push(new LobbedRock(this.x, this.y - this.r*0.4, {
          vx: Math.cos(angle)*speed,
          vy: -(220 + i*30),
          gravity: 520 + rand()*60,
          ground: CONFIG.roomH - 52,
          damage: this.enraged?2:1,
        }));
      }
      spawnCircularEffect(this.x, this.y, this.r+18, {innerColor:'#fee2e2', midColor:'#fb923c', outerColor:'#f97316'});
    }
    performSlamImpact(){
      addScreenShake(6,0.35);
      spawnCircularEffect(this.x, this.y, this.r+20, {innerColor:'#fee2e2', midColor:'#f97316', outerColor:'#ea580c'});
      const shards = this.enraged ? 12 : 9;
      for(let i=0;i<shards;i++){
        const angle = (Math.PI*2/shards)*i + randRange(-0.05,0.05);
        const speed = 200 + rand()*50 + (this.enraged?40:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.6, 'tear'));
      }
      const waveCount = this.enraged ? 2 : 1;
      for(let i=0;i<waveCount;i++){
        this.pendingEvents.push({type:'shockwave', delay:scaleBossTempo(i*0.15), radius:this.r+16 + i*14});
      }
    }
    performQuakeImpact(){
      addScreenShake(5,0.3);
    }
    executeEvent(evt){
      if(evt.type==='shockwave'){
        runtime.enemyProjectiles.push(new GroundShock(this.x, this.y, {
          inner: evt.radius,
          width: 18,
          speed: 200 + (this.enraged?40:0),
          life: 0.9,
          damage: this.enraged?2:1,
          color: '#f97316',
        }));
      } else if(evt.type==='quakePulse'){
        runtime.enemyProjectiles.push(new GroundShock(this.x, this.y, {
          inner: this.r + 12 + evt.power*22,
          width: 22,
          speed: 190 + (this.enraged?40:0),
          life: 1.0,
          damage: this.enraged?2:1,
          color: '#fb923c',
        }));
      }
    }
    damage(d){
      if(this.state==='leap'){ d *= 0.7; }
      this.hp -= d;
      this.hitFlash = 0.2;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      let baseColor = this.hitFlash>0 ? '#fee2e2' : (this.enraged ? '#fed7aa' : '#fecaca');
      let edgeColor = this.enraged ? '#f97316' : '#fb7185';
      if(this.state==='windup' && this.telegraphType){
        const total = this.telegraphTotal || 1;
        const ratio = clamp(1 - this.telegraphTimer / total, 0, 1);
        if(this.telegraphType==='slam'){
          baseColor = mixHexColor('#fff7ed', '#f97316', 0.35 + ratio*0.55);
          edgeColor = '#ea580c';
        } else if(this.telegraphType==='quake'){
          baseColor = mixHexColor('#fef3c7', '#fbbf24', 0.3 + ratio*0.55);
          edgeColor = '#d97706';
        } else if(this.telegraphType==='boulder'){
          baseColor = mixHexColor('#fef2f2', '#f97316', 0.4 + ratio*0.5);
          edgeColor = '#fb923c';
        }
      }
      drawBlob(this.x, this.y - this.altitude*this.r*0.8, this.r, baseColor, edgeColor);
      ctx.save();
      ctx.translate(this.x, this.y - this.altitude*this.r*0.8);
      ctx.fillStyle = '#78350f';
      ctx.beginPath();
      ctx.arc(-this.r*0.24, -this.r*0.1, this.r*0.16, 0, Math.PI*2);
      ctx.arc(this.r*0.24, -this.r*0.1, this.r*0.16, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#451a03';
      ctx.beginPath();
      ctx.moveTo(-this.r*0.38, this.r*0.18);
      ctx.quadraticCurveTo(0, this.r*(this.enraged?0.45:0.38), this.r*0.38, this.r*0.18);
      ctx.quadraticCurveTo(0, this.r*(this.enraged?0.55:0.48), -this.r*0.38, this.r*0.18);
      ctx.fill();
      ctx.restore();
      if(this.state==='windup' && this.telegraphType){
        ctx.save();
        const pulse = 0.55 + 0.25*Math.sin(performance.now()/100);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edgeColor;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.altitude*this.r*0.8, this.r + 12, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
      if(this.state==='brace'){
        ctx.save();
        ctx.globalAlpha = 0.45 + 0.25*Math.sin(performance.now()/90);
        ctx.strokeStyle = '#f97316';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 16, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
    getShadowConfig(){
      const altitude = clamp(Number(this.altitude) || 0, 0, 1.2);
      return {
        x: this.x,
        y: this.y,
        radius: this.r,
        altitude,
        flying: altitude>0.05,
        alpha: 0.35 + 0.3*altitude,
        stretch: 0.55,
        scale: 1 - altitude*0.3,
      };
    }
  }

  class HydraOrb{
    constructor(x,y,options={}){
      this.x=x; this.y=y;
      this.center = {x, y};
      this.centerRef = options.centerRef || null;
      this.angle = options.angle ?? 0;
      this.radius = options.radius ?? 60;
      this.orbitSpeed = options.orbitSpeed ?? 2.2;
      this.windup = Math.max(0.2, options.windup ?? 0.6);
      this.timer = this.windup;
      this.state='orbit';
      this.life = options.life ?? 5.5;
      this.alive=true;
      this.r = options.r ?? 11;
      this.dashSpeed = options.dashSpeed ?? 220;
      this.damage = Math.max(1, options.damage ?? 1);
      this.color = options.color || '#22d3ee';
      this.vx=0; this.vy=0;
    }
    update(dt){
      if(!this.alive) return;
      this.life -= dt;
      if(this.life<=0){ this.alive=false; return; }
      if(this.centerRef){ this.center.x = this.centerRef.x; this.center.y = this.centerRef.y; }
      if(this.state==='orbit'){
        this.timer -= dt;
        this.angle += this.orbitSpeed * dt;
        this.x = this.center.x + Math.cos(this.angle)*this.radius;
        this.y = this.center.y + Math.sin(this.angle)*Math.max(40, this.radius*0.65);
        if(this.timer<=0){
          this.state='dash';
          const target = player ? {x:player.x, y:player.y} : this.center;
          const dx = target.x - this.x;
          const dy = target.y - this.y;
          const len = Math.hypot(dx,dy)||1;
          this.vx = (dx/len) * this.dashSpeed;
          this.vy = (dy/len) * this.dashSpeed;
          spawnCircularEffect(this.x, this.y, this.r+8, {innerColor:'#ecfeff', midColor:this.color, outerColor:'#0ea5e9'});
        }
      } else {
        this.x += this.vx*dt;
        this.y += this.vy*dt;
        if(this.x<16||this.x>CONFIG.roomW-16||this.y<20||this.y>CONFIG.roomH-20){ this.alive=false; }
      }
    }
    checkHit(target){
      if(!this.alive) return false;
      if(dist(this,target) < this.r + target.r){
        target.hurt(this.damage);
        this.alive=false;
        return true;
      }
      return false;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      const radius = this.r;
      const gradient = ctx.createRadialGradient(0,0,radius*0.1,0,0,radius*1.1);
      gradient.addColorStop(0,'#faffff');
      gradient.addColorStop(1,this.color);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0,0,radius,0,Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = this.color;
      ctx.stroke();
      ctx.restore();
    }
  }

  class FallingShard{
    constructor(x,y,options={}){
      this.x=x; this.y=y;
      this.vx=options.vx ?? 0;
      this.vy=options.vy ?? 160;
      this.accel=options.accel ?? 220;
      this.ground=options.ground ?? (CONFIG.roomH - 40);
      this.life=options.life ?? 4;
      this.alive=true;
      this.r=options.r ?? 10;
      this.damage=Math.max(1, options.damage ?? 1);
      this.color=options.color || '#c084fc';
      this.impacted=false;
    }
    update(dt){
      if(!this.alive) return;
      this.vy += this.accel * dt;
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.life -= dt;
      if(this.y >= this.ground){
        this.triggerImpact();
      } else if(this.life<=0 || this.x<20 || this.x>CONFIG.roomW-20){
        this.alive=false;
      }
    }
    triggerImpact(){
      if(this.impacted) return;
      this.impacted=true;
      this.alive=false;
      spawnCircularEffect(this.x, this.ground, this.r+14, {innerColor:'#ede9fe', midColor:this.color, outerColor:'#7c3aed'});
      addScreenShake(3,0.2);
    }
    checkHit(target){
      if(!this.alive) return false;
      if(dist(this,target) < this.r + target.r){
        target.hurt(this.damage);
        this.triggerImpact();
        return true;
      }
      return false;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.moveTo(-this.r*0.6, -this.r*0.9);
      ctx.lineTo(this.r*0.6, -this.r*0.9);
      ctx.lineTo(this.r*0.3, this.r*0.9);
      ctx.lineTo(-this.r*0.3, this.r*0.9);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  class GroundShock{
    constructor(x,y,options={}){
      this.x=x; this.y=y;
      this.inner=Math.max(0, options.inner ?? 30);
      this.width=Math.max(4, options.width ?? 16);
      this.speed=options.speed ?? 180;
      this.life=options.life ?? 0.9;
      this.damage=Math.max(1, options.damage ?? 1);
      this.color=options.color || '#f97316';
      this.alive=true;
      this.hit=false;
    }
    update(dt){
      if(!this.alive) return;
      this.inner += this.speed * dt;
      this.life -= dt;
      if(this.life<=0){ this.alive=false; }
    }
    checkHit(target){
      if(!this.alive) return false;
      const d = dist(this, target);
      if(d >= this.inner && d <= this.inner + this.width){
        if(!this.hit){ target.hurt(this.damage); this.hit = true; }
      }
      return false;
    }
    draw(){
      if(!this.alive) return;
      ctx.save();
      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = this.width;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.inner + this.width/2, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  class LobbedRock{
    constructor(x,y,options={}){
      this.x=x; this.y=y;
      this.vx=options.vx ?? 0;
      this.vy=options.vy ?? -220;
      this.gravity=options.gravity ?? 520;
      this.ground=options.ground ?? (CONFIG.roomH - 54);
      this.life=options.life ?? 6;
      this.r=options.r ?? 12;
      this.damage=Math.max(1, options.damage ?? 2);
      this.color=options.color || '#fb923c';
      this.alive=true;
      this.exploded=false;
    }
    update(dt){
      if(!this.alive) return;
      this.life -= dt;
      if(this.life<=0){ this.explode(); return; }
      this.vy += this.gravity * dt;
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      if(this.y >= this.ground){
        this.y = this.ground;
        this.explode();
      } else if(this.x<30 || this.x>CONFIG.roomW-30){
        this.explode();
      }
    }
    explode(){
      if(this.exploded) return;
      this.exploded=true;
      this.alive=false;
      spawnCircularEffect(this.x, this.y, this.r+18, {innerColor:'#fee2e2', midColor:this.color, outerColor:'#f97316'});
      addScreenShake(5,0.3);
      const shards = 6;
      for(let i=0;i<shards;i++){
        const angle = (Math.PI*2/shards)*i + randRange(-0.1,0.1);
        const speed = 160 + rand()*50;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
      }
    }
    checkHit(target){
      if(!this.alive) return false;
      if(dist(this,target) < this.r + target.r){
        target.hurt(this.damage);
        this.explode();
        return true;
      }
      return false;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(0,0,this.r*1.1,this.r*0.85,0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#7c2d12';
      ctx.beginPath();
      ctx.ellipse(0,-this.r*0.3,this.r*0.6,this.r*0.4,0,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function getShadowConfigForEntity(entity){
    if(!entity || entity.shadow === false || entity.noShadow === true) return null;
    let cfg = undefined;
    if(typeof entity.getShadowConfig === 'function'){
      cfg = entity.getShadowConfig();
      if(cfg === false || (cfg && cfg.visible === false)){
        return null;
      }
    }
    cfg = cfg ? {...cfg} : {};
    const x = Number.isFinite(cfg.x) ? cfg.x : Number(entity.shadowX ?? entity.x);
    const y = Number.isFinite(cfg.y) ? cfg.y : Number(entity.shadowY ?? entity.y);
    const radius = Number.isFinite(cfg.radius) ? cfg.radius : Number(entity.shadowRadius ?? entity.r ?? 12);
    if(!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(radius) || radius<=0){
      return null;
    }
    const flying = cfg.flying ?? !!entity.flying;
    let altitude = cfg.altitude;
    if(!Number.isFinite(altitude)){
      if(typeof entity.getShadowAltitude === 'function'){
        altitude = Number(entity.getShadowAltitude());
      }
      if(!Number.isFinite(altitude) && typeof entity.getAltitude === 'function'){
        altitude = Number(entity.getAltitude());
      }
      if(!Number.isFinite(altitude) && Number.isFinite(entity.altitude)){
        altitude = Number(entity.altitude);
      }
      if(!Number.isFinite(altitude) && Number.isFinite(entity.shadowAltitude)){
        altitude = Number(entity.shadowAltitude);
      }
    }
    if(!Number.isFinite(altitude)){ altitude = 0; }
    altitude = clamp(altitude, 0, 1.6);
    if(flying && altitude<=0){
      const hover = Number.isFinite(cfg.hover) ? cfg.hover : Number(entity.shadowHover ?? 0.32);
      if(Number.isFinite(hover) && hover>0){
        altitude = clamp(hover, 0, 1.2);
      }
    }
    const hasCustomAlpha = Number.isFinite(cfg.alpha) || Number.isFinite(entity.shadowAlpha);
    const baseAlpha = Number.isFinite(cfg.alpha) ? cfg.alpha
      : Number.isFinite(entity.shadowAlpha) ? entity.shadowAlpha
      : (flying ? 0.3 : 0.45);
    const stretch = Number.isFinite(cfg.stretch) ? cfg.stretch
      : Number.isFinite(entity.shadowStretch) ? entity.shadowStretch
      : (flying ? 0.55 : 0.48);
    const scaleBase = Number.isFinite(cfg.scale) ? cfg.scale
      : Number.isFinite(entity.shadowScale) ? entity.shadowScale
      : (1 - altitude * (flying ? 0.55 : 0.38));
    const scale = clamp(scaleBase, flying ? 0.45 : 0.6, flying ? 1.05 : 1.15);
    let offsetY;
    if(Number.isFinite(cfg.offsetY)){
      offsetY = cfg.offsetY;
    } else if(Number.isFinite(entity.shadowOffsetY)){
      offsetY = entity.shadowOffsetY;
    } else {
      const factor = Number.isFinite(cfg.offsetFactor) ? cfg.offsetFactor
        : Number.isFinite(entity.shadowOffsetFactor) ? entity.shadowOffsetFactor
        : (flying ? 0.75 : 0.9);
      offsetY = radius * clamp(factor, 0.2, 1.4);
    }
    const color = cfg.color || entity.shadowColor || '#000000';
    const alpha = hasCustomAlpha
      ? clamp(baseAlpha, 0.05, 0.8)
      : clamp(baseAlpha - altitude * (flying ? 0.08 : 0.22), 0.05, 0.7);
    return {
      x,
      y,
      radius,
      altitude,
      flying,
      alpha,
      stretch: clamp(stretch, 0.15, 1.4),
      scale,
      offsetY,
      color,
    };
  }

  function drawShadowFromConfig(cfg){
    if(!cfg) return;
    const x = cfg.x;
    const y = cfg.y;
    const radius = cfg.radius;
    if(!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(radius) || radius<=0) return;
    ctx.save();
    ctx.globalAlpha = clamp(cfg.alpha ?? 0.4, 0.01, 0.8);
    ctx.fillStyle = cfg.color || '#000000';
    ctx.beginPath();
    ctx.ellipse(x, y + (cfg.offsetY ?? radius*0.85), radius * (cfg.scale ?? 1), radius * (cfg.stretch ?? 0.5) * (cfg.scale ?? 1), 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function getEntitySpawnFade(entity){
    if(!entity) return 1;
    const timer = Number(entity.spawnFadeTimer) || 0;
    if(timer<=0) return 1;
    const duration = Math.max(0.001, Number(entity.spawnFadeDuration) || ENEMY_SPAWN_FADE_DEFAULT);
    const ratio = clamp(timer / duration, 0, 1);
    return clamp(0.35 + 0.65 * (1 - ratio), 0.35, 1);
  }

  function drawEntityShadow(entity){
    if(!entity) return;
    const cfg = getShadowConfigForEntity(entity);
    if(!cfg) return;
    const fade = getEntitySpawnFade(entity);
    if(fade<1){
      cfg.alpha = (cfg.alpha ?? 0.4) * fade;
    }
    drawShadowFromConfig(cfg);
  }

  function drawBlob(x,y,r,base,edge){
    const outer = edge || base || '#9ca3af';
    const inner = base || outer;
    ctx.save();
    ctx.translate(x,y);
    const body = ctx.createRadialGradient(-r*0.32,-r*0.46,r*0.18,0,0,r*1.1);
    body.addColorStop(0, shadeColor(inner, 0.28));
    body.addColorStop(0.45, inner);
    body.addColorStop(1, shadeColor(outer, -0.22));
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.arc(0,0,r,0,Math.PI*2);
    ctx.fill();
    ctx.lineWidth = Math.max(1.4, r*0.14);
    ctx.strokeStyle = colorWithAlpha(shadeColor(outer, -0.45), 0.88);
    ctx.stroke();
    const core = ctx.createRadialGradient(0,r*0.12,r*0.08,0,0,r*0.78);
    core.addColorStop(0, colorWithAlpha(shadeColor(inner, 0.2), 0.82));
    core.addColorStop(0.9, colorWithAlpha(shadeColor(inner, -0.08), 0.18));
    core.addColorStop(1, colorWithAlpha(shadeColor(outer, -0.18), 0));
    ctx.fillStyle = core;
    ctx.beginPath();
    ctx.arc(0,0,r*0.78,0,Math.PI*2);
    ctx.fill();
    const highlight = ctx.createRadialGradient(-r*0.45,-r*0.52,0,-r*0.45,-r*0.52,r*0.68);
    highlight.addColorStop(0, colorWithAlpha('#ffffff',0.82));
    highlight.addColorStop(0.5, colorWithAlpha('#ffffff',0.15));
    highlight.addColorStop(1, colorWithAlpha('#ffffff',0));
    ctx.fillStyle = highlight;
    ctx.beginPath();
    ctx.ellipse(-r*0.28,-r*0.42,r*0.56,r*0.36,-0.35,0,Math.PI*2);
    ctx.fill();
    const belly = ctx.createLinearGradient(-r*0.5,r*0.35,r*0.5,r*0.92);
    belly.addColorStop(0, colorWithAlpha(shadeColor(outer,-0.3),0));
    belly.addColorStop(0.45, colorWithAlpha(shadeColor(outer,-0.32),0.38));
    belly.addColorStop(1, colorWithAlpha(shadeColor(outer,-0.45),0));
    ctx.fillStyle = belly;
    ctx.beginPath();
    ctx.ellipse(0,r*0.46,r*0.7,r*0.42,0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = colorWithAlpha('#000000',0.22);
    ctx.beginPath();
    ctx.ellipse(0,r*0.76,r*0.85,r*0.28,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  class EnemyShadowEcho{
    constructor(x,y,master){
      this.x=x; this.y=y; this.r=11;
      this.baseHp = 8;
      this.hp = this.baseHp;
      this.speed = 140;
      this.master = master || null;
      this.teleportTimer = randRange(1.4, 2.2);
      this.invuln = 0.25;
      this.tint = '#a855f7';
      this.tintLight = '#d8b4fe';
      this.flying = true;
      this.preventDrops = true;
      initializeEnemyStats(this, {hpBase:this.baseHp, speedFields:['speed']});
      ensureEnemyKnockState(this);
    }
    update(dt){
      if(this.invuln>0){ this.invuln = Math.max(0, this.invuln - dt); }
      this.teleportTimer -= dt * (this.master && this.master.enraged ? 1.3 : 1);
      if(this.teleportTimer<=0){ this.performTeleport(); }
      const anchor = (this.master && !this.master.dead) ? this.master : player;
      if(anchor){
        const dx = anchor.x - this.x;
        const dy = anchor.y - this.y;
        const len = Math.hypot(dx,dy)||1;
        const speed = this.speed * getEnemyGlobalSpeedMultiplier() * 0.9;
        this.x += (dx/len) * speed * dt;
        this.y += (dy/len) * speed * dt;
      }
      this.x = clamp(this.x, 50, CONFIG.roomW-50);
      this.y = clamp(this.y, 60, CONFIG.roomH-60);
      resolveEntityObstacles(this);
      if(player && dist(this, player) < this.r + player.r - 1){ player.hurt(1); }
    }
    performTeleport(){
      this.teleportTimer = randRange(1.6, 2.4);
      this.invuln = 0.28;
      const anchor = player || {x:CONFIG.roomW/2, y:CONFIG.roomH/2};
      const radius = randRange(80, 150);
      const angle = rand()*Math.PI*2;
      this.x = clamp(anchor.x + Math.cos(angle)*radius, 60, CONFIG.roomW-60);
      this.y = clamp(anchor.y + Math.sin(angle)*radius, 70, CONFIG.roomH-70);
      spawnCircularEffect(this.x, this.y, 36, {
        innerColor: colorWithAlpha('#ede9fe', 0.95),
        midColor: colorWithAlpha('#a855f7', 0.4),
        outerColor: colorWithAlpha('#1e1b4b', 0),
      });
    }
    damage(d){
      if(this.invuln>0) return false;
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      const px = player ? player.x : this.x;
      const py = player ? player.y : this.y;
      applyEnemyKnockback(this, this.x - px, this.y - py, {power:130, duration:0.16});
      return false;
    }
    onDeath(){
      if(this.master && typeof this.master.removeMinion === 'function'){ this.master.removeMinion(this); }
    }
    draw(){
      const outer = this.invuln>0 ? '#ede9fe' : this.tintLight;
      drawBlob(this.x, this.y, this.r, outer, this.tint);
    }
  }

  class EnemyParadoxShard{
    constructor(x,y,master){
      this.x=x; this.y=y; this.r=12;
      this.baseHp = 10;
      this.hp = this.baseHp;
      this.master = master || null;
      this.orbitRadius = randRange(90, 150);
      this.orbitAngle = rand()*Math.PI*2;
      this.orbitSpeed = randRange(0.55, 1.05);
      this.fireTimer = randRange(1.1, 1.9);
      this.speed = 80;
      this.flying = true;
      this.preventDrops = true;
      this.tint = '#f0abfc';
      this.tintEdge = '#a855f7';
      initializeEnemyStats(this, {hpBase:this.baseHp});
      ensureEnemyKnockState(this);
    }
    update(dt){
      const masterAlive = this.master && !this.master.dead;
      const aggression = masterAlive && this.master.enraged ? 1.4 : 1;
      if(masterAlive){
        this.orbitAngle += this.orbitSpeed * dt * aggression;
        const radius = this.orbitRadius * (this.master.phase===2 ? 0.85 : 1);
        this.x = clamp(this.master.x + Math.cos(this.orbitAngle)*radius, 60, CONFIG.roomW-60);
        this.y = clamp(this.master.y + Math.sin(this.orbitAngle)*radius, 70, CONFIG.roomH-70);
      } else if(player){
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const len = Math.hypot(dx,dy)||1;
        this.x += (dx/len) * this.speed * dt;
        this.y += (dy/len) * this.speed * dt;
      }
      this.fireTimer -= dt * aggression;
      if(this.fireTimer<=0){
        this.fireTimer = randRange(1.2, 1.8);
        this.shoot();
      }
      resolveEntityObstacles(this);
      if(player && dist(this, player) < this.r + player.r - 1){ player.hurt(1); }
    }
    shoot(){
      if(!player) return;
      const angle = Math.atan2(player.y - this.y, player.x - this.x);
      const speed = 170 + (this.master && this.master.enraged ? 50 : 0);
      runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 3.8, 'spark'));
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    onDeath(){
      if(this.master && typeof this.master.removeShard === 'function'){ this.master.removeShard(this); }
    }
    draw(){
      drawBlob(this.x, this.y, this.r, this.tint, this.tintEdge);
    }
  }

  class EnemyBossUmbra{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(30);
      this.hp=80; this.maxHp=this.hp;
      this.name=name;
      this.state='stalk';
      this.teleportTimer=scaleBossTempo(2.2);
      this.attackTimer=scaleBossTempo(1.6);
      this.teleportDuration=scaleBossTempo(0.45);
      this.teleportProgress=0;
      this.invulnerableTimer=0;
      this.enraged=false;
      this.hitFlash=0;
      this.minions=new Set();
      this.isBossEntity=true;
      this.scaling=getFloorScalingFactors();
      this.hp=Math.round(this.hp*this.scaling.hp);
      this.maxHp=this.hp;
      this.speedScale=this.scaling.speed;
      this.aggression=this.scaling.aggression;
      this.telegraphTimer=0;
      this.telegraphTotal=0;
      this.telegraphType='';
      this.attackPlan=null;
      this.recoverTimer=0;
      this.nextCooldown=0;
    }
    update(dt){
      this.hitFlash = Math.max(0, this.hitFlash - dt*3.4);
      if(this.invulnerableTimer>0){ this.invulnerableTimer = Math.max(0, this.invulnerableTimer - dt); }
      if(!this.enraged && this.hp <= this.maxHp*0.55){
        this.enraged = true;
        this.teleportTimer = Math.min(this.teleportTimer, scaleBossTempo(1.3));
      }
      if(this.state==='vanish'){
        this.teleportProgress += dt * this.aggression / this.teleportDuration;
        if(this.teleportProgress>=1){ this.performTeleport(); }
        return;
      }
      if(this.state==='reappear'){
        this.teleportProgress += dt * this.aggression / (this.teleportDuration*0.8);
        if(this.teleportProgress>=1){ this.state='stalk'; this.teleportProgress=0; }
      }
      const slow = this.state==='windup' ? 0.55 : (this.state==='recover' ? 0.65 : 1);
      this.floatMovement(dt, slow);
      if(this.state==='windup'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.telegraphTimer<=0){ this.executeAttackPlan(); }
        return;
      }
      if(this.state==='recover'){
        this.recoverTimer -= dt * this.aggression;
        if(this.recoverTimer<=0){
          this.state='stalk';
          this.attackTimer = this.nextCooldown || scaleBossTempo(this.enraged?1.2:1.7);
          this.nextCooldown = 0;
        }
        return;
      }
      if(this.state==='stalk'){
        this.teleportTimer -= dt * this.aggression;
        if(this.teleportTimer<=0){ this.beginTeleport(); }
        this.attackTimer -= dt * this.aggression;
        if(this.attackTimer<=0){ this.chooseAttack(); }
      }
    }
    floatMovement(dt, slowFactor=1){
      const baseSpeed = (this.enraged?125:100) * this.speedScale;
      if(player){
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const len = Math.hypot(dx,dy)||1;
        this.x += (dx/len) * baseSpeed * dt * 0.82 * slowFactor;
        this.y += (dy/len) * baseSpeed * dt * 0.82 * slowFactor;
      }
      this.x += Math.cos(performance.now()/420) * 18 * dt * slowFactor;
      this.y += Math.sin(performance.now()/360) * 16 * dt * slowFactor;
      this.x = clamp(this.x, 80, CONFIG.roomW-80);
      this.y = clamp(this.y, 90, CONFIG.roomH-90);
      resolveEntityObstacles(this);
      if(player && dist(this, player) < this.r + player.r - 2){ player.hurt(1); }
    }
    beginTeleport(){
      this.state='vanish';
      this.teleportProgress = 0;
      this.teleportTimer = scaleBossTempo(randRange(1.8, 2.4));
      this.invulnerableTimer = Math.max(this.invulnerableTimer, 0.6);
      spawnCircularEffect(this.x, this.y, this.r+24, {
        innerColor: colorWithAlpha('#ede9fe', 0.85),
        midColor: colorWithAlpha('#a855f7', 0.35),
        outerColor: colorWithAlpha('#312e81', 0),
      });
    }
    performTeleport(){
      const anchor = player || {x:CONFIG.roomW/2, y:CONFIG.roomH/2};
      const radius = randRange(120, 220);
      const angle = rand()*Math.PI*2;
      this.x = clamp(anchor.x + Math.cos(angle)*radius, 70, CONFIG.roomW-70);
      this.y = clamp(anchor.y + Math.sin(angle)*radius, 80, CONFIG.roomH-80);
      spawnCircularEffect(this.x, this.y, this.r+40, {
        innerColor: colorWithAlpha('#f0abfc', 0.95),
        midColor: colorWithAlpha('#6366f1', 0.45),
        outerColor: colorWithAlpha('#1e1b4b', 0),
      });
      this.state='reappear';
      this.teleportProgress = 0;
      this.invulnerableTimer = Math.max(this.invulnerableTimer, 0.25);
      this.launchShadowFan(true);
    }
    chooseAttack(){
      const roll = rand();
      const heavyThreshold = adjustBossHeavyThreshold(0.75);
      if(roll < 0.45){
        this.scheduleAttack('fan', {
          windup: this.enraged ? 0.6 : 0.8,
          recover: this.enraged ? 0.55 : 0.75,
          cooldown: this.enraged ? 1.2 : 1.7
        }, this.launchShadowFan);
      } else if(roll < heavyThreshold){
        this.scheduleAttack('summon', {
          windup: this.enraged ? 0.75 : 0.95,
          recover: this.enraged ? 0.7 : 0.9,
          cooldown: this.enraged ? 1.9 : 2.5
        }, this.spawnShadowMinions);
      } else {
        this.scheduleAttack('blades', {
          windup: this.enraged ? 0.65 : 0.85,
          recover: this.enraged ? 0.6 : 0.8,
          cooldown: this.enraged ? 1.4 : 2.1
        }, this.launchChasingBlades);
      }
    }
    scheduleAttack(type, config={}, execute){
      this.attackPlan = {
        type,
        execute,
        recover: scaleBossTempo(config.recover ?? 0.6),
        cooldown: scaleBossTempo(config.cooldown ?? (this.enraged?1.2:1.7)),
      };
      this.telegraphType = type;
      const windup = scaleBossTempo(config.windup ?? 0.6);
      this.telegraphTimer = Math.max(0.25, windup);
      this.telegraphTotal = this.telegraphTimer;
      this.state='windup';
    }
    executeAttackPlan(){
      const plan = this.attackPlan;
      if(!plan) return;
      this.attackPlan = null;
      this.telegraphTimer = 0;
      this.telegraphTotal = 0;
      plan.execute?.call(this);
      this.state='recover';
      this.recoverTimer = plan.recover;
      this.nextCooldown = plan.cooldown;
      this.telegraphType='';
    }
    launchShadowFan(forceLarge=false){
      const waves = forceLarge ? 2 : (this.enraged ? 2 : 1);
      const base = rand()*Math.PI*2;
      for(let w=0; w<waves; w++){
        const count = (this.enraged?18:14) + w*4;
        for(let i=0;i<count;i++){
          const angle = base + (Math.PI*2/count)*i + w*0.08;
          const speed = 150 + w*30 + (this.enraged?35:0);
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.6, 'needle'));
        }
      }
    }
    launchChasingBlades(){
      const shots = this.enraged ? 6 : 4;
      for(let i=0;i<shots;i++){
        if(!player) break;
        const angle = Math.atan2(player.y - this.y, player.x - this.x) + randRange(-0.22,0.22);
        const speed = 220 + (this.enraged?60:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 3.6, 'spark'));
      }
    }
    spawnShadowMinions(){
      const count = this.enraged ? 3 : 2;
      for(let i=0;i<count;i++){
        const angle = rand()*Math.PI*2;
        const radius = randRange(90, 160);
        const mx = clamp(this.x + Math.cos(angle)*radius, 70, CONFIG.roomW-70);
        const my = clamp(this.y + Math.sin(angle)*radius, 80, CONFIG.roomH-80);
        const minion = new EnemyShadowEcho(mx, my, this);
        if(queueEnemySpawn(minion, {bossSummon:true, summoner:this})){
          this.minions.add(minion);
        }
      }
    }
    removeMinion(minion){
      if(this.minions) this.minions.delete(minion);
    }
    damage(d){
      if(this.invulnerableTimer>0 && (this.state==='vanish' || this.state==='reappear')) return false;
      this.hp -= d;
      this.hitFlash = 0.25;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    onDeath(){
      if(this.minions){
        for(const minion of this.minions){ if(minion) minion.dead = true; }
        this.minions.clear();
      }
    }
    draw(){
      ctx.save();
      let alpha = 1;
      if(this.state==='vanish'){ alpha = Math.max(0.2, 1 - this.teleportProgress*0.85); }
      else if(this.state==='reappear'){ alpha = Math.max(0.35, this.teleportProgress); }
      if(this.invulnerableTimer>0){ alpha *= 0.8 + 0.2*Math.sin(performance.now()/90); }
      ctx.globalAlpha = alpha;
      let base = this.hitFlash>0 ? '#fdf2f8' : '#d8b4fe';
      let edge = this.hitFlash>0 ? '#fde68a' : '#a855f7';
      if(this.state==='windup' && this.telegraphType){
        const ratio = this.telegraphTotal>0 ? clamp(1 - this.telegraphTimer / this.telegraphTotal, 0, 1) : 1;
        if(this.telegraphType==='fan'){
          base = mixHexColor('#fef2ff', '#a855f7', 0.35 + ratio*0.5);
          edge = '#7c3aed';
        } else if(this.telegraphType==='summon'){
          base = mixHexColor('#ede9fe', '#60a5fa', 0.3 + ratio*0.45);
          edge = '#2563eb';
        } else if(this.telegraphType==='blades'){
          base = mixHexColor('#fdf4ff', '#fb7185', 0.3 + ratio*0.5);
          edge = '#e11d48';
        }
      }
      drawBlob(this.x, this.y, this.r, base, edge);
      ctx.restore();
      if(this.state==='windup' && this.telegraphType){
        ctx.save();
        const pulse = 0.6 + 0.25*Math.sin(performance.now()/100);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edge;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 12, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
      if(this.invulnerableTimer>0){
        ctx.save();
        ctx.globalAlpha = 0.25 + 0.15*Math.sin(performance.now()/120);
        ctx.strokeStyle = '#c084fc';
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r*1.45, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  class EnemyBossParadox{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=scaleBossRadius(34);
      this.hp=110; this.maxHp=this.hp;
      this.name=name;
      this.state='float';
      this.teleportTimer=scaleBossTempo(2.1);
      this.attackTimer=scaleBossTempo(1.5);
      this.warpProgress=0;
      this.warpDuration=scaleBossTempo(0.5);
      this.invulnerableTimer=0;
      this.hitFlash=0;
      this.phase=1;
      this.enraged=false;
      this.rotation=rand()*Math.PI*2;
      this.timeSlowTimer=0;
      this.minions=new Set();
      this.shards=new Set();
      this.isBossEntity=true;
      this.scaling=getFloorScalingFactors();
      this.hp=Math.round(this.hp*this.scaling.hp);
      this.maxHp=this.hp;
      this.speedScale=this.scaling.speed;
      this.aggression=this.scaling.aggression;
      this.telegraphTimer=0;
      this.telegraphTotal=0;
      this.telegraphType='';
      this.attackPlan=null;
      this.recoverTimer=0;
      this.nextCooldown=0;
    }
    update(dt){
      this.hitFlash = Math.max(0, this.hitFlash - dt*4);
      if(this.invulnerableTimer>0){ this.invulnerableTimer = Math.max(0, this.invulnerableTimer - dt); }
      if(this.timeSlowTimer>0){
        this.timeSlowTimer = Math.max(0, this.timeSlowTimer - dt);
        if(this.timeSlowTimer<=0 && player){ player.clearTimeScaleModifier('paradox'); }
      }
      this.cleanupSummons();
      if(!this.enraged && this.hp <= this.maxHp*0.52){ this.enterPhaseTwo(); }
      if(this.state==='warp-out'){
        this.warpProgress += dt * this.aggression / this.warpDuration;
        if(this.warpProgress>=1){ this.performWarp(); }
        return;
      }
      if(this.state==='warp-in'){
        this.warpProgress += dt * this.aggression / (this.warpDuration*0.75);
        if(this.warpProgress>=1){ this.state='float'; this.warpProgress=0; }
      }
      const slow = this.state==='windup' ? 0.6 : (this.state==='recover' ? 0.7 : 1);
      this.rotation += dt * (0.6 + 0.25*this.aggression);
      this.x += Math.cos(this.rotation) * 24 * dt * slow;
      this.y += Math.sin(this.rotation*0.85) * 20 * dt * slow;
      this.x = clamp(this.x, 90, CONFIG.roomW-90);
      this.y = clamp(this.y, 100, CONFIG.roomH-100);
      resolveEntityObstacles(this);
      if(player && dist(this, player) < this.r + player.r - 3){ player.hurt(1); }
      if(this.state==='windup'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.telegraphTimer<=0){ this.executeAttackPlan(); }
        return;
      }
      if(this.state==='recover'){
        this.recoverTimer -= dt * this.aggression;
        if(this.recoverTimer<=0){
          this.state='float';
          this.attackTimer = this.nextCooldown || scaleBossTempo(1.5);
          this.nextCooldown = 0;
        }
        return;
      }
      this.teleportTimer -= dt * this.aggression;
      if(this.teleportTimer<=0){ this.beginWarp(); }
      this.attackTimer -= dt * this.aggression;
      if(this.attackTimer<=0){ this.performAttack(); }
    }
    cleanupSummons(){
      if(this.minions){ for(const minion of Array.from(this.minions)){ if(!minion || minion.dead){ this.minions.delete(minion); } } }
      if(this.shards){ for(const shard of Array.from(this.shards)){ if(!shard || shard.dead){ this.shards.delete(shard); } } }
    }
    enterPhaseTwo(){
      this.phase = 2;
      this.enraged = true;
      this.teleportTimer = Math.min(this.teleportTimer, scaleBossTempo(1.4));
      const room = dungeon?.current;
      if(room){ room.sceneVariant = 'void'; }
      spawnCircularEffect(this.x, this.y, this.r+50, {
        innerColor: colorWithAlpha('#fef3c7',0.95),
        midColor: colorWithAlpha('#fb923c',0.45),
        outerColor: colorWithAlpha('#0f172a',0),
      });
      addScreenShake(6,0.4);
      runtime.itemPickupName = '终焉织主暴走';
      runtime.itemPickupDesc = '场景与时间全数扭曲。';
      runtime.itemPickupTimer = 2.8;
    }
    beginWarp(){
      this.state='warp-out';
      this.warpProgress=0;
      this.teleportTimer = scaleBossTempo(randRange(1.6, 2.2));
      this.invulnerableTimer = Math.max(this.invulnerableTimer, 0.55);
      spawnCircularEffect(this.x, this.y, this.r+28, {
        innerColor: colorWithAlpha('#bae6fd',0.8),
        midColor: colorWithAlpha('#38bdf8',0.4),
        outerColor: colorWithAlpha('#0f172a',0),
      });
    }
    performWarp(){
      const anchor = player || {x:CONFIG.roomW/2, y:CONFIG.roomH/2};
      const radius = randRange(100, 200);
      const angle = rand()*Math.PI*2;
      this.x = clamp(anchor.x + Math.cos(angle)*radius, 90, CONFIG.roomW-90);
      this.y = clamp(anchor.y + Math.sin(angle)*radius, 100, CONFIG.roomH-100);
      spawnCircularEffect(this.x, this.y, this.r+44, {
        innerColor: colorWithAlpha('#fee2e2',0.95),
        midColor: colorWithAlpha('#fb7185',0.5),
        outerColor: colorWithAlpha('#0f172a',0),
      });
      this.state='warp-in';
      this.warpProgress = 0;
      this.invulnerableTimer = Math.max(this.invulnerableTimer, 0.3);
      this.castSpiral(true);
    }
    performAttack(){
      if(this.phase===1){
        const roll = rand();
        const heavyThreshold = adjustBossHeavyThreshold(0.75);
        if(roll < 0.4){
          this.scheduleAttack('spiral', {
            windup: this.enraged ? 0.7 : 0.85,
            recover: this.enraged ? 0.6 : 0.75,
            cooldown: 1.6
          }, ()=>this.castSpiral());
        } else if(roll < heavyThreshold){
          this.scheduleAttack('crossfire', {
            windup: this.enraged ? 0.75 : 0.9,
            recover: this.enraged ? 0.65 : 0.8,
            cooldown: 1.8
          }, this.castCrossfire);
        } else {
          this.scheduleAttack('summon', {
            windup: this.enraged ? 0.85 : 1.05,
            recover: this.enraged ? 0.75 : 0.95,
            cooldown: 2.3
          }, this.summonEcho);
        }
      } else {
        const roll = rand();
        const heavyThreshold = adjustBossHeavyThreshold(0.66);
        if(roll < 0.33){
          this.scheduleAttack('shards', {
            windup: this.enraged ? 0.8 : 1.0,
            recover: this.enraged ? 0.7 : 0.85,
            cooldown: 1.7
          }, this.castShardStorm);
        } else if(roll < heavyThreshold){
          this.scheduleAttack('snare', {
            windup: this.enraged ? 0.9 : 1.1,
            recover: this.enraged ? 0.85 : 1.05,
            cooldown: 2.1
          }, this.castTimeSnare);
        } else {
          this.scheduleAttack('rewind', {
            windup: this.enraged ? 1.0 : 1.2,
            recover: this.enraged ? 0.9 : 1.1,
            cooldown: 2.4
          }, this.castRewind);
        }
      }
    }
    scheduleAttack(type, config={}, execute){
      this.attackPlan = {
        type,
        execute,
        recover: scaleBossTempo(config.recover ?? 0.7),
        cooldown: scaleBossTempo(config.cooldown ?? 1.6),
      };
      this.telegraphType = type;
      const windup = scaleBossTempo(config.windup ?? 0.6);
      this.telegraphTimer = Math.max(0.3, windup);
      this.telegraphTotal = this.telegraphTimer;
      this.state='windup';
    }
    executeAttackPlan(){
      const plan = this.attackPlan;
      if(!plan) return;
      this.attackPlan = null;
      this.telegraphTimer = 0;
      this.telegraphTotal = 0;
      plan.execute?.call(this);
      this.state='recover';
      this.recoverTimer = plan.recover;
      this.nextCooldown = plan.cooldown;
      this.telegraphType='';
    }
    castSpiral(extraDense=false){
      const waves = extraDense ? 3 : (this.enraged?3:2);
      const base = rand()*Math.PI*2;
      for(let w=0; w<waves; w++){
        const count = (this.enraged?18:14) + (extraDense?4:0) + w*2;
        for(let i=0;i<count;i++){
          const angle = base + (Math.PI*2/count)*i + w*0.12;
          const speed = 160 + w*25 + (this.enraged?40:0);
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5.2, 'tear'));
        }
      }
    }
    castCrossfire(){
      if(!player) return;
      const lanes = this.enraged ? 6 : 4;
      const base = Math.atan2(player.y - this.y, player.x - this.x);
      for(let i=0;i<lanes;i++){
        const offset = (i - (lanes-1)/2) * 0.22;
        const angle = base + offset;
        const speed = 240 + (this.enraged?60:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'needle'));
      }
    }
    summonEcho(){
      const count = this.enraged ? 2 : 1;
      for(let i=0;i<count;i++){
        const angle = rand()*Math.PI*2;
        const radius = randRange(100, 180);
        const ex = clamp(this.x + Math.cos(angle)*radius, 90, CONFIG.roomW-90);
        const ey = clamp(this.y + Math.sin(angle)*radius, 100, CONFIG.roomH-100);
        const minion = new EnemyShadowEcho(ex, ey, this);
        if(queueEnemySpawn(minion, {bossSummon:true, summoner:this})){
          this.minions.add(minion);
        }
      }
    }
    castShardStorm(){
      const count = this.enraged ? 3 : 2;
      for(let i=0;i<count;i++){
        const angle = rand()*Math.PI*2;
        const radius = randRange(90, 140);
        const sx = clamp(this.x + Math.cos(angle)*radius, 80, CONFIG.roomW-80);
        const sy = clamp(this.y + Math.sin(angle)*radius, 90, CONFIG.roomH-90);
        const shard = new EnemyParadoxShard(sx, sy, this);
        if(queueEnemySpawn(shard, {bossSummon:true, summoner:this})){
          this.shards.add(shard);
        }
      }
    }
    castTimeSnare(){
      this.timeSlowTimer = 3.4;
      if(player){ player.setTimeScaleModifier('paradox', 0.62); }
      spawnCircularEffect(this.x, this.y, this.r+54, {
        innerColor: colorWithAlpha('#bfdbfe',0.95),
        midColor: colorWithAlpha('#38bdf8',0.45),
        outerColor: colorWithAlpha('#0f172a',0),
      });
      const arcs = this.enraged ? 3 : 2;
      for(let a=0;a<arcs;a++){
        const count = 12 + a*3;
        const base = rand()*Math.PI*2;
        for(let i=0;i<count;i++){
          const angle = base + (Math.PI*2/count)*i;
          const speed = 110 + a*25;
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'spark'));
        }
      }
    }
    castRewind(){
      const rewind = this.enraged ? 4 : 3;
      if(player && typeof player.rewindRunTimer === 'function'){
        player.rewindRunTimer(rewind);
      } else if(runtime.runTimer){
        runtime.runTimer.rewind(rewind);
      }
      runtime.itemPickupName = '时间倒流';
      runtime.itemPickupDesc = `计时器被倒回了 ${rewind.toFixed(0)} 秒。`;
      runtime.itemPickupTimer = 2.6;
      spawnCircularEffect(this.x, this.y, this.r+46, {
        innerColor: colorWithAlpha('#fee2e2',0.95),
        midColor: colorWithAlpha('#f97316',0.45),
        outerColor: colorWithAlpha('#0f172a',0),
      });
      this.castCrossfire();
      addScreenShake(6,0.35);
    }
    removeMinion(minion){ if(this.minions) this.minions.delete(minion); }
    removeShard(shard){ if(this.shards) this.shards.delete(shard); }
    damage(d){
      if(this.invulnerableTimer>0 && (this.state==='warp-out' || this.state==='warp-in')) return false;
      this.hp -= d;
      this.hitFlash = 0.3;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    onDeath(room){
      if(player){ player.clearTimeScaleModifier('paradox'); }
      if(room && room.sceneVariant === 'void'){ delete room.sceneVariant; }
      for(const minion of this.minions){ if(minion) minion.dead = true; }
      for(const shard of this.shards){ if(shard) shard.dead = true; }
      this.minions.clear();
      this.shards.clear();
    }
    draw(){
      ctx.save();
      let alpha = 1;
      if(this.state==='warp-out'){ alpha = Math.max(0.2, 1 - this.warpProgress); }
      else if(this.state==='warp-in'){ alpha = Math.max(0.35, this.warpProgress); }
      if(this.invulnerableTimer>0){ alpha *= 0.85 + 0.15*Math.sin(performance.now()/80); }
      ctx.globalAlpha = alpha;
      let base = this.phase===2 ? '#fef9c3' : '#bae6fd';
      let edge = this.hitFlash>0 ? '#f97316' : (this.phase===2 ? '#fb7185' : '#60a5fa');
      if(this.state==='windup' && this.telegraphType){
        const ratio = this.telegraphTotal>0 ? clamp(1 - this.telegraphTimer / this.telegraphTotal, 0, 1) : 1;
        if(this.telegraphType==='spiral' || this.telegraphType==='crossfire'){
          base = mixHexColor('#f0f9ff', '#60a5fa', 0.35 + ratio*0.5);
          edge = '#2563eb';
        } else if(this.telegraphType==='summon' || this.telegraphType==='shards'){
          base = mixHexColor('#fefce8', '#facc15', 0.3 + ratio*0.5);
          edge = '#d97706';
        } else if(this.telegraphType==='snare' || this.telegraphType==='rewind'){
          base = mixHexColor('#fef2f2', '#fb7185', 0.3 + ratio*0.5);
          edge = '#e11d48';
        }
      }
      drawBlob(this.x, this.y, this.r, base, edge);
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = 0.25 + (this.phase===2 ? 0.15 : 0.1)*Math.sin(performance.now()/140);
      ctx.strokeStyle = this.phase===2 ? '#facc15' : '#93c5fd';
      ctx.lineWidth = this.phase===2 ? 3.2 : 2.4;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*1.55, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
      if(this.state==='windup' && this.telegraphType){
        ctx.save();
        const pulse = 0.58 + 0.25*Math.sin(performance.now()/100);
        ctx.globalAlpha = pulse;
        ctx.strokeStyle = edge;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 14, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function spawnCircularEffect(x,y,radius, options={}){
    if(!runtime?.effects) return;
    const duration = Math.max(0.05, options.duration ?? 0.35);
    runtime.effects.push({
      type:'burst',
      x, y,
      radius,
      life: duration,
      ttl: duration,
      innerColor: options.innerColor || '#fff6',
      midColor: options.midColor || '#fca5a5',
      outerColor: options.outerColor || '#fb7185',
    });
  }

  const ENEMY_SPAWN_FADE_DEFAULT = 0.45;

  function spawnEnemySmoke(x, y, options={}){
    if(!runtime?.effects) runtime.effects = [];
    const radius = Math.max(8, Number(options.radius) || 20);
    const ttl = Math.max(0.18, Number(options.ttl) || 0.52);
    const count = Math.max(6, Math.floor(options.count ?? 16));
    const particles = [];
    for(let i=0;i<count;i++){
      const angle = rand() * Math.PI * 2;
      const speed = randRange(30, 90);
      const drift = randRange(-20, 28);
      const life = ttl * randRange(0.45, 1.05);
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed * 0.6 + drift,
        life,
        ttl: life,
        size: radius * randRange(0.18, 0.32),
        alpha: randRange(0.25, 0.55),
      });
    }
    const effect = {
      type:'spawn-smoke',
      x,
      y,
      life: ttl,
      ttl,
      particles,
      update(self, dt){
        if(!Array.isArray(self.particles)) return;
        for(let i=self.particles.length-1;i>=0;i--){
          const p = self.particles[i];
          p.life -= dt;
          if(p.life<=0){
            self.particles.splice(i,1);
            continue;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.88;
          p.vy = p.vy * 0.88 - dt * 14;
        }
        self.life = Math.max(0, self.life - dt);
        if(self.particles.length===0){
          self.life = 0;
        }
      },
      draw(ctx){
        if(!ctx || !Array.isArray(this.particles)) return;
        ctx.save();
        for(const p of this.particles){
          if(p.life<=0) continue;
          const ratio = p.ttl>0 ? clamp(p.life / p.ttl, 0, 1) : 0;
          if(ratio<=0) continue;
          const alpha = p.alpha * ratio;
          if(alpha<=0.01) continue;
          const size = p.size * (1 + (1 - ratio) * 0.8);
          const gradient = ctx.createRadialGradient(p.x, p.y, size*0.2, p.x, p.y, size);
          gradient.addColorStop(0, 'rgba(209,213,219,0.68)');
          gradient.addColorStop(1, 'rgba(75,85,99,0)');
          ctx.globalAlpha = alpha;
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      },
    };
    runtime.effects.push(effect);
    return effect;
  }

  function triggerEnemySpawnEffects(enemies, options={}){
    if(!Array.isArray(enemies) || enemies.length===0) return 0;
    const fadeDuration = Math.max(0.18, Number(options.fadeDuration) || ENEMY_SPAWN_FADE_DEFAULT);
    let triggered = 0;
    for(const enemy of enemies){
      if(!enemy || enemy.spawnVisualized) continue;
      const ex = Number.isFinite(enemy.x) ? enemy.x : CONFIG.roomW/2;
      const ey = Number.isFinite(enemy.y) ? enemy.y : CONFIG.roomH/2;
      const radius = Math.max(10, (enemy.r || 12) * 1.35);
      spawnEnemySmoke(ex, ey, {radius, ttl: fadeDuration * 0.85});
      enemy.spawnVisualized = true;
      enemy.spawnFadeDuration = fadeDuration;
      enemy.spawnFadeTimer = fadeDuration;
      triggered++;
    }
    if(triggered>0 && options.playSound !== false){
      const volume = Number.isFinite(options.soundVolume) ? options.soundVolume : 0.52;
      audio.play('enemySpawn', {volume: clamp(volume, 0, 1)});
    }
    return triggered;
  }

  function spawnBulletDisperse(x, y, options={}){
    if(!runtime?.effects) return null;
    const baseColor = typeof options.color === 'string' ? options.color : '#a6e3ff';
    const accentColor = typeof options.accent === 'string' ? options.accent : shadeColor(baseColor, 0.18);
    const ttl = Math.max(0.18, options.life ?? 0.45);
    const particleCount = Math.max(4, Math.floor(options.count ?? 8));
    const radiusRef = Math.max(2, options.radius ?? 6);
    const sizeBase = Math.max(1.2, options.size ?? radiusRef * 0.38);
    const speed = Math.max(40, options.speed ?? (120 + radiusRef * 12));
    const scatter = Math.max(0.3, options.scatter ?? 0.9);
    const glowStrength = clamp(options.glowStrength ?? 0.6, 0, 1.5);
    const effect = {
      type: 'bullet-pop',
      x,
      y,
      life: ttl,
      ttl,
      particles: [],
      baseColor,
      accentColor,
      glowStrength,
      update(self, dt){
        for(let i=self.particles.length-1;i>=0;i--){
          const p = self.particles[i];
          p.life -= dt;
          if(p.life <= 0){
            self.particles.splice(i,1);
            continue;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.78;
          p.vy *= 0.78;
        }
      },
      draw(ctx){
        if(!ctx || !this.particles.length) return;
        ctx.save();
        for(const p of this.particles){
          const ratio = p.ttl>0 ? clamp(p.life / p.ttl, 0, 1) : 0;
          if(ratio<=0) continue;
          const alpha = (options.alpha ?? 0.9) * Math.pow(ratio, 0.7);
          if(alpha<=0.01) continue;
          ctx.globalAlpha = alpha;
          const size = p.size * (0.5 + 0.6 * ratio);
          ctx.fillStyle = colorWithAlpha(p.color, 1);
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI*2);
          ctx.fill();
        }
        const glowRatio = clamp(this.life / this.ttl, 0, 1);
        if(glowRatio>0){
          const glowRadius = radiusRef * (0.8 + glowRatio * 1.1);
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRadius);
          gradient.addColorStop(0, colorWithAlpha(baseColor, 0.55 * glowRatio * this.glowStrength));
          gradient.addColorStop(1, colorWithAlpha(baseColor, 0));
          ctx.globalAlpha = 1;
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, glowRadius, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }
    };
    for(let i=0;i<particleCount;i++){
      const angle = randRange(0, Math.PI*2);
      const speedScale = 0.4 + rand() * scatter;
      const life = ttl * (0.55 + rand()*0.35);
      const color = rand()<0.35 ? accentColor : baseColor;
      effect.particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed * speedScale,
        vy: Math.sin(angle) * speed * speedScale,
        life,
        ttl: life,
        size: sizeBase * (0.65 + rand()*0.55),
        color,
      });
    }
    runtime.effects.push(effect);
    return effect;
  }

  function spawnBeamSparkBurst(x, y, options={}){
    if(!runtime?.effects) return null;
    const baseColor = typeof options.color === 'string' ? options.color : '#fb923c';
    const accentColor = typeof options.accent === 'string' ? options.accent : '#fed7aa';
    const ttl = Math.max(0.16, options.life ?? 0.38);
    const particleCount = Math.max(3, Math.floor(options.count ?? 6));
    const speed = Math.max(60, options.speed ?? 200);
    const radiusRef = Math.max(4, options.radius ?? 10);
    const dir = options.dir || {x:0, y:-1};
    const dirLen = Math.hypot(dir.x, dir.y) || 1;
    const nx = dir.x / dirLen;
    const ny = dir.y / dirLen;
    const perpX = -ny;
    const perpY = nx;
    const flow = Number.isFinite(options.flow) ? options.flow : 1;
    const swirl = !!options.swirl;
    const effect = {
      type: 'beam-spark',
      x,
      y,
      life: ttl,
      ttl,
      particles: [],
      baseColor,
      accentColor,
      update(self, dt){
        for(let i=self.particles.length-1;i>=0;i--){
          const p = self.particles[i];
          p.life -= dt;
          if(p.life <= 0){
            self.particles.splice(i,1);
            continue;
          }
          if(swirl){
            const swirlStrength = p.swirlStrength;
            const vx = p.vx;
            const vy = p.vy;
            p.vx += (-vy) * swirlStrength * dt;
            p.vy += (vx) * swirlStrength * dt;
          }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.86;
          p.vy *= 0.86;
        }
      },
      draw(ctx){
        if(!ctx || !this.particles.length) return;
        ctx.save();
        for(const p of this.particles){
          const ratio = p.ttl>0 ? clamp(p.life / p.ttl, 0, 1) : 0;
          if(ratio<=0) continue;
          const alpha = (options.alpha ?? 0.95) * Math.pow(ratio, 0.6);
          if(alpha<=0.01) continue;
          const size = p.size * (0.45 + 0.7 * ratio);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = colorWithAlpha(p.color, 1);
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.restore();
      }
    };
    for(let i=0;i<particleCount;i++){
      const lateral = (rand() - 0.5) * 1.3;
      const forward = (0.35 + rand()*0.9) * flow;
      const px = nx * forward + perpX * lateral;
      const py = ny * forward + perpY * lateral;
      const len = Math.hypot(px, py) || 1;
      const vx = (px/len) * speed * (0.6 + rand()*0.6);
      const vy = (py/len) * speed * (0.6 + rand()*0.6);
      const life = ttl * (0.6 + rand()*0.35);
      const color = rand()<0.45 ? accentColor : baseColor;
      effect.particles.push({
        x: x + perpX * lateral * radiusRef * 0.25,
        y: y + perpY * lateral * radiusRef * 0.25,
        vx,
        vy,
        life,
        ttl: life,
        size: (options.size ?? (radiusRef*0.24)) * (0.8 + rand()*0.6),
        color,
        swirlStrength: swirl ? randRange(4, 9) : 0,
      });
    }
    runtime.effects.push(effect);
    return effect;
  }

  function updateEffects(dt){
    if(runtime.effects && runtime.effects.length){
      for(let i=runtime.effects.length-1;i>=0;i--){
        const effect = runtime.effects[i];
        if(typeof effect.update === 'function'){
          effect.update(effect, dt);
        } else {
          if(effect.follow && typeof effect.follow === 'object'){
            if(Number.isFinite(effect.follow.x)) effect.x = effect.follow.x;
            if(Number.isFinite(effect.follow.y)) effect.y = effect.follow.y;
          }
          if(Number.isFinite(effect.gravity)){ effect.vy = (effect.vy || 0) + effect.gravity * dt; }
          if(Number.isFinite(effect.vx)){ effect.x = (effect.x || 0) + effect.vx * dt; }
          if(Number.isFinite(effect.vy)){ effect.y = (effect.y || 0) + effect.vy * dt; }
          if(Number.isFinite(effect.rotationSpeed)){ effect.rotation = (effect.rotation || 0) + effect.rotationSpeed * dt; }
        }
        effect.life -= dt;
        if(effect.life<=0){ runtime.effects.splice(i,1); }
      }
    }
    if(runtime.decals && runtime.decals.length){
      for(let i=runtime.decals.length-1;i>=0;i--){
        const decal = runtime.decals[i];
        decal.life -= dt;
        const ttl = Math.max(0.001, decal.ttl || 1);
        const elapsed = clamp(ttl - decal.life, 0, ttl);
        const fadeIn = clamp(elapsed / Math.max(0.001, ttl * 0.18), 0, 1);
        const fadeOut = decal.life < ttl * 0.18 ? clamp(decal.life / Math.max(0.001, ttl * 0.18), 0, 1) : 1;
        decal.alpha = (decal.baseAlpha ?? 0.45) * fadeIn * fadeOut;
        if(decal.life<=0){ runtime.decals.splice(i,1); }
      }
    }
  }

  function drawEffects(){
    if(!runtime.effects || !runtime.effects.length) return;
    for(const effect of runtime.effects){
      if(effect.type==='burst'){
        drawBurstEffect(effect);
      } else if(effect.type==='gib'){
        drawGibEffect(effect);
      } else if(effect.type==='pickup-spark'){
        drawPickupSparkEffect(effect);
      } else if(effect.type==='active-aura'){
        drawActiveAuraEffect(effect);
      } else if(effect.type==='shockwave'){
        drawShockwaveEffect(effect);
      } else if(effect.type==='bomb-progenitor-reticle'){
        drawBombProgenitorReticle(effect);
      } else if(typeof effect.draw === 'function'){
        effect.draw(ctx, effect);
      }
    }
  }

  function drawBeams(){
    if(!runtime.beams || !runtime.beams.length) return;
    for(const beam of runtime.beams){
      if(beam && typeof beam.draw === 'function'){
        beam.draw(ctx);
        continue;
      }
      const geom = computeBeamGeometry(beam);
      if(!geom || geom.length<=0) continue;
      const owner = beam?.owner;
      const baseWidth = owner?.getBrimstoneWidth?.() ?? beam?.width ?? 24;
      const width = Math.max(6, baseWidth);
      if(typeof beam.visualSeed !== 'number'){ beam.visualSeed = rand(); }
      const palette = {...(beam?.palette || {})};
      const samples = buildCurvedBeamSamples(geom, width, {
        phase: beam.wobblePhase || 0,
        seed: beam.visualSeed,
        amplitudeFactor: Number.isFinite(beam.amplitudeFactor) ? beam.amplitudeFactor : undefined,
      });
      if(samples.length<2) continue;
      drawCurvedBeam(samples, geom, width, palette, {seed: beam.visualSeed});
    }
  }

  function drawBurstEffect(effect){
    const ttl = effect.ttl || 0.0001;
    const progress = clamp(1 - (effect.life/ttl), 0, 1);
    const radius = (effect.radius || 20) * (0.6 + progress*0.6);
    ctx.save();
    ctx.globalAlpha = Math.max(0, 1 - progress*0.85);
    const g = ctx.createRadialGradient(effect.x, effect.y, radius*0.15, effect.x, effect.y, radius);
    g.addColorStop(0, effect.innerColor || '#fff5');
    g.addColorStop(0.45, effect.midColor || '#fca5a5');
    g.addColorStop(1, effect.outerColor || '#fb7185');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(effect.x, effect.y, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawGibEffect(effect){
    const ttl = effect.ttl || 0.0001;
    const progress = clamp(1 - (effect.life/ttl), 0, 1);
    const size = (effect.size || 6) * (1 - progress*0.35);
    ctx.save();
    ctx.translate(effect.x || 0, effect.y || 0);
    if(effect.rotation){ ctx.rotate(effect.rotation); }
    ctx.globalAlpha = clamp(1 - progress*0.9, 0, 1);
    ctx.fillStyle = effect.color || '#b91c1c';
    ctx.fillRect(-size/2, -size*0.6, size, size*1.2);
    ctx.restore();
  }

  function drawPickupSparkEffect(effect){
    const ttl = effect.ttl || 0.0001;
    const progress = clamp(1 - (effect.life/ttl), 0, 1);
    const radius = (effect.radius || 26) * (0.7 + progress*0.5);
    ctx.save();
    ctx.globalAlpha = clamp(1 - progress*0.8, 0, 1);
    const gradient = ctx.createRadialGradient(effect.x, effect.y, radius*0.2, effect.x, effect.y, radius);
    gradient.addColorStop(0, effect.innerColor || 'rgba(255,255,255,0.95)');
    gradient.addColorStop(0.65, effect.midColor || 'rgba(129,140,248,0.55)');
    gradient.addColorStop(1, effect.outerColor || 'rgba(59,130,246,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(effect.x, effect.y, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawBombProgenitorReticle(effect){
    if(!effect) return;
    const radius = Math.max(12, effect.radius || 24);
    const progress = clamp(effect.progress ?? 0, 0, 1);
    const phase = effect.phase || 0;
    ctx.save();
    ctx.translate(effect.x || 0, effect.y || 0);
    const pulse = 0.55 + 0.35 * Math.sin(phase * 2.2);
    ctx.globalAlpha = clamp(0.6 + progress*0.4, 0, 1) * pulse;
    ctx.strokeStyle = colorWithAlpha('#fb923c', 0.85);
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(0,0,radius,0,Math.PI*2);
    ctx.stroke();
    ctx.strokeStyle = colorWithAlpha('#fde68a', 0.9);
    ctx.lineWidth = 1.6;
    ctx.beginPath();
    ctx.arc(0,0,radius*0.64,0,Math.PI*2);
    ctx.stroke();
    ctx.strokeStyle = colorWithAlpha('#f97316', 0.8);
    ctx.lineWidth = 2;
    const arm = radius * (0.95 - progress*0.35);
    ctx.beginPath();
    ctx.moveTo(-arm,0); ctx.lineTo(arm,0);
    ctx.moveTo(0,-arm); ctx.lineTo(0,arm);
    ctx.stroke();
    ctx.fillStyle = colorWithAlpha('#fde68a', 0.75 + 0.2*progress);
    ctx.beginPath();
    ctx.arc(0,0,radius*0.18*(1+0.6*progress),0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawActiveAuraEffect(effect){
    const ttl = effect.ttl || 0.0001;
    const progress = clamp(1 - (effect.life/ttl), 0, 1);
    const radius = (effect.radius || 48) * (0.85 + progress*0.4);
    ctx.save();
    ctx.globalAlpha = clamp(0.55 + Math.sin(progress*Math.PI)*0.25, 0, 1);
    const gradient = ctx.createRadialGradient(effect.x, effect.y, radius*0.3, effect.x, effect.y, radius);
    gradient.addColorStop(0, effect.innerColor || 'rgba(254,215,170,0.95)');
    gradient.addColorStop(0.7, effect.midColor || 'rgba(251,191,36,0.35)');
    gradient.addColorStop(1, effect.outerColor || 'rgba(252,211,77,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(effect.x, effect.y, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawShockwaveEffect(effect){
    const ttl = effect.ttl || 0.0001;
    const progress = clamp(1 - (effect.life/ttl), 0, 1);
    const radius = (effect.maxRadius || 110) * progress;
    const lineWidth = (effect.lineWidth || 6) * (1 - progress*0.6);
    ctx.save();
    ctx.globalAlpha = clamp(1 - progress, 0, 1) * 0.85;
    ctx.strokeStyle = effect.color || 'rgba(251,191,36,0.8)';
    ctx.lineWidth = Math.max(1.2, lineWidth);
    ctx.beginPath();
    ctx.arc(effect.x, effect.y, radius, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function spawnGibBurst(options={}){
    if(!runtime.effects) runtime.effects = [];
    const count = Math.max(2, Math.floor(options.count ?? 8));
    for(let i=0;i<count;i++){
      const angle = rand()*Math.PI*2;
      const speed = randRange(options.speedMin ?? 80, options.speedMax ?? 220);
      runtime.effects.push({
        type:'gib',
        x: options.x ?? player?.x ?? CONFIG.roomW/2,
        y: options.y ?? player?.y ?? CONFIG.roomH/2,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        gravity: options.gravity ?? 480,
        rotation: rand()*Math.PI*2,
        rotationSpeed: randRange(-8, 8),
        size: randRange(options.minSize ?? 4, options.maxSize ?? 10),
        color: options.color || '#f87171',
        life: options.life ?? 0.6,
        ttl: options.life ?? 0.6,
      });
    }
  }

  function getRoomKey(room = dungeon?.current){
    if(!room) return null;
    if(Number.isFinite(room.i) && Number.isFinite(room.j)){
      return `${room.i},${room.j}`;
    }
    return null;
  }

  function clearRoomDecals(){
    if(Array.isArray(runtime.decals)) runtime.decals.length = 0;
    else runtime.decals = [];
  }

  function addFloorStain(x, y, radius=32, color='#991b1b', options={}){
    if(!runtime.decals) runtime.decals = [];
    const ttl = Math.max(3, options.life ?? 24);
    runtime.decals.push({
      x, y,
      rx: radius * randRange(0.7, 1.2),
      ry: radius * randRange(0.45, 0.9),
      rotation: rand()*Math.PI,
      color,
      baseAlpha: options.alpha ?? 0.38,
      life: ttl,
      ttl,
      roomKey: getRoomKey(),
    });
  }

  function triggerEnemyDeathEffects(enemy){
    if(!enemy) return;
    const baseColor = enemy.tint || enemy.color || '#f87171';
    const accent = enemy.tintLight || shadeColor(baseColor, 0.25);
    spawnGibBurst({x: enemy.x, y: enemy.y, color: accent, minSize: 4, maxSize: Math.max(6, (enemy.r||12)*0.8)});
    spawnCircularEffect(enemy.x, enemy.y, Math.max(26, (enemy.r||12)*1.8), {
      duration: 0.45,
      innerColor: colorWithAlpha('#ffffff', 0.85),
      midColor: colorWithAlpha(accent, 0.55),
      outerColor: colorWithAlpha(baseColor, 0),
    });
    addFloorStain(enemy.x, enemy.y, Math.max(18, (enemy.r||12)*1.6), colorWithAlpha(baseColor, 0.68));
    audio.play('enemyDeath', {volume: enemy.isBossEntity ? 1 : 0.8});
    if(enemy.isBossEntity){
      const shake = BOSS_TUNING.deathShake || {};
      addScreenShake(Number.isFinite(shake.intensity) ? shake.intensity : 6.5, Number.isFinite(shake.duration) ? shake.duration : 0.48);
    } else {
      addScreenShake(2.4, 0.25);
    }
  }

  function triggerItemPickupAnimation({item, isActive=false, source=null}={}){
    if(!player) return;
    const center = {x: player.x, y: player.y};
    const origin = source ? {x: source.x, y: source.y} : center;
    const primary = isActive ? '#fbbf24' : '#93c5fd';
    const highlight = isActive ? '#fde68a' : '#bfdbfe';
    runtime.effects.push({
      type:'pickup-spark',
      x: origin.x,
      y: origin.y,
      radius: isActive ? 44 : 34,
      life: 0.5,
      ttl: 0.5,
      innerColor: colorWithAlpha('#ffffff', 0.95),
      midColor: colorWithAlpha(highlight, 0.55),
      outerColor: colorWithAlpha(primary, 0),
    });
    runtime.effects.push({
      type:'pickup-spark',
      x: center.x,
      y: center.y,
      radius: isActive ? 52 : 38,
      life: 0.65,
      ttl: 0.65,
      follow: player,
      innerColor: colorWithAlpha(highlight, 0.95),
      midColor: colorWithAlpha(primary, 0.45),
      outerColor: colorWithAlpha(primary, 0),
    });
    if(isActive){
      runtime.effects.push({
        type:'active-aura',
        x: center.x,
        y: center.y,
        radius: Math.max(48, player.r * 4),
        life: 0.6,
        ttl: 0.6,
        follow: player,
        innerColor: colorWithAlpha('#fde68a', 0.95),
        midColor: colorWithAlpha('#f59e0b', 0.45),
        outerColor: colorWithAlpha('#f97316', 0),
      });
      audio.play('pickupActive');
    } else {
      audio.play('pickupPassive');
    }
  }

  function triggerActiveUseAnimation(item){
    if(!player) return;
    const base = '#fbbf24';
    runtime.effects.push({
      type:'active-aura',
      x: player.x,
      y: player.y,
      radius: Math.max(60, player.r * 4.5),
      life: 0.55,
      ttl: 0.55,
      follow: player,
      innerColor: colorWithAlpha('#fde68a', 0.95),
      midColor: colorWithAlpha('#f97316', 0.45),
      outerColor: colorWithAlpha('#fb923c', 0),
    });
    runtime.effects.push({
      type:'shockwave',
      x: player.x,
      y: player.y,
      maxRadius: 140,
      lineWidth: 6,
      life: 0.45,
      ttl: 0.45,
      color: colorWithAlpha(base, 0.85),
    });
    addScreenShake(6, 0.3);
    audio.play('activeUse');
  }

  function roomPortals(room){
    if(!room) return [];
    const portals = [];
    if(room.portal) portals.push(room.portal);
    if(Array.isArray(room.extraPortals)){
      for(const p of room.extraPortals){
        if(p) portals.push(p);
      }
    }
    return portals;
  }

  function cleanupRoomPortals(room){
    if(!room) return;
    if(room.portal && room.portal.used){ room.portal = null; }
    if(Array.isArray(room.extraPortals)){
      room.extraPortals = room.extraPortals.filter(p=>p && !p.used);
      if(!room.extraPortals.length) room.extraPortals = [];
    }
  }

  function repelPickupsFromPortal(room, portal, options={}){
    if(!room || !portal) return;
    if(!Array.isArray(room.pickups) || !room.pickups.length) return;
    const power = Number.isFinite(options.forcePower) ? options.forcePower : 150;
    for(const drop of room.pickups){
      if(!isPhysicalPickup(drop)) continue;
      pushPickup(drop, portal, power, {force:true});
      ensurePickupMotion(drop);
    }
  }

  function spawnExchangePortal(room){
    if(!room) return null;
    const cfg = CONFIG.portal || {};
    const center = typeof room.center === 'function' ? room.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    const anchorX = Number.isFinite(cfg.exchangeAnchorX) ? cfg.exchangeAnchorX : 90;
    const anchorY = Number.isFinite(cfg.exchangeAnchorY) ? cfg.exchangeAnchorY : 120;
    const offsetX = Number.isFinite(cfg.exchangeOffsetX) ? cfg.exchangeOffsetX : (anchorX - center.x);
    const offsetY = Number.isFinite(cfg.exchangeOffsetY) ? cfg.exchangeOffsetY : (anchorY - center.y);
    const portal = {
      type: 'exchange',
      x: clamp(center.x + offsetX, 90, CONFIG.roomW-90),
      y: clamp(center.y + offsetY, 110, CONFIG.roomH-110),
      r: cfg.radius ?? 34,
      interactRadius: cfg.interactRadius ?? ((cfg.radius ?? 34) + 18),
      spawnDelay: Math.max(0, (cfg.spawnDelay ?? 0) + 0.35),
      phase: rand()*Math.PI*2,
      active: false,
      used: false,
      highlight: 0,
      originRoom: room,
    };
    if(!Array.isArray(room.extraPortals)) room.extraPortals = [];
    room.extraPortals.push(portal);
    repelPickupsFromPortal(room, portal, {forcePower: 170});
    return portal;
  }

  function spawnReturnPortal(exchangeRoom, sourceRoom){
    if(!exchangeRoom) return null;
    const cfg = CONFIG.portal || {};
    const center = typeof exchangeRoom.center === 'function' ? exchangeRoom.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    return {
      type: 'return',
      x: clamp(center.x + (cfg.returnOffsetX ?? 0), 90, CONFIG.roomW-90),
      y: clamp(center.y + (cfg.returnOffsetY ?? 120), 120, CONFIG.roomH-90),
      r: cfg.radius ?? 34,
      interactRadius: cfg.interactRadius ?? ((cfg.radius ?? 34) + 18),
      spawnDelay: Math.max(0, (cfg.spawnDelay ?? 0) * 0.5),
      phase: rand()*Math.PI*2,
      active: false,
      used: false,
      highlight: 0,
      hint: '按 F 返回 Boss 房',
      originRoom: sourceRoom || null,
    };
  }

  function createExchangeRoom(sourceRoom){
    const room = {
      i: -999,
      j: -999,
      doors: {up:false, down:false, left:false, right:false},
      isExchangeRoom: true,
      isSafeRoom: true,
      cleared: true,
      visited: true,
      discovered: true,
      enemies: [],
      pickups: [],
      obstacles: [],
      bombs: [],
      extraPortals: [],
      combatRoom: false,
      chargeGranted: true,
      originRoom: sourceRoom || null,
      center(){ return {x: CONFIG.roomW/2, y: CONFIG.roomH/2}; },
      ensureObstacles(){},
    };
    const center = room.center();
    const pedestalSlots = [
      {x: clamp(center.x - 90, 90, CONFIG.roomW-90), y: clamp(center.y - 40, 100, CONFIG.roomH-120)},
      {x: clamp(center.x + 90, 90, CONFIG.roomW-90), y: clamp(center.y - 40, 100, CONFIG.roomH-120)},
    ];
    const used = new Set();
    for(const slot of pedestalSlots){
      let item = null;
      let attempts = 0;
      while(attempts < 6){
        attempts++;
        const candidate = rollLifeTradeItem();
        if(!candidate) break;
        if(used.has(candidate.slug)) continue;
        item = candidate;
        break;
      }
      if(!item) continue;
      used.add(item.slug);
      const pickup = makeLifeTradePickup(slot.x, slot.y, item, {room, costConfig:{type:'flat', amount:1}});
      if(pickup){
        if(!pickup.label){ pickup.label = '献祭 1 点上限'; }
        room.pickups.push(pickup);
      }
    }
    const supply = makeExchangeSupplyPickup(center.x, clamp(center.y + 70, 120, CONFIG.roomH-90));
    if(supply){ room.pickups.push(supply); }
    room.portal = spawnReturnPortal(room, sourceRoom);
    return room;
  }

  function enterExchangeRoom(sourceRoom, portal){
    if(!dungeon || !player) return false;
    const entry = {
      room: sourceRoom,
      x: player.x,
      y: player.y,
      portal,
    };
    runtime.roomStack.push(entry);
    let exchange = runtime.exchangeRoom;
    if(!exchange){
      exchange = createExchangeRoom(sourceRoom);
      runtime.exchangeRoom = exchange;
    } else {
      exchange.originRoom = sourceRoom || exchange.originRoom;
      if(exchange.portal){ exchange.portal.originRoom = sourceRoom || exchange.portal.originRoom; }
    }
    if(!exchange.portal){ exchange.portal = spawnReturnPortal(exchange, sourceRoom); }
    dungeon.current = exchange;
    clearBossSummonTracker();
    clearRoomDecals();
    exchange.visited = true;
    exchange.cleared = true;
    exchange.combatRoom = false;
    exchange.chargeGranted = true;
    if(!Array.isArray(exchange.enemies)) exchange.enemies = [];
    if(!Array.isArray(exchange.bombs)) exchange.bombs = [];
    if(!Array.isArray(exchange.pickups)) exchange.pickups = [];
    if(!Array.isArray(exchange.extraPortals)) exchange.extraPortals = [];
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    player.handleRoomChange(exchange);
    player.knockVel.x = 0; player.knockVel.y = 0; player.knockTimer = 0;
    if(player.vel){ player.vel.x = 0; player.vel.y = 0; }
    player.moveDir.x = 0; player.moveDir.y = 0;
    player.lastDisplacement.x = 0; player.lastDisplacement.y = 0;
    if(player.lastVelocity){ player.lastVelocity.x = 0; player.lastVelocity.y = 0; }
    player.ifr = Math.max(player.ifr, 0.2);
    const center = exchange.center ? exchange.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    player.x = clamp(center.x, 80, CONFIG.roomW-80);
    player.y = clamp(center.y + 38, 100, CONFIG.roomH-80);
    player.snapFollowersToPlayer();
    handleRoomEntry(exchange, 'center', {spawnEffects:false});
    if(runtime.itemPickupTimer<=0){
      runtime.itemPickupName = '进入交换房';
      runtime.itemPickupDesc = '献祭红心换取强力道具。';
      runtime.itemPickupTimer = 2;
    }
    return true;
  }

  function leaveExchangeRoom(portal){
    if(!dungeon || !player) return false;
    const entry = runtime.roomStack.pop();
    const targetRoom = entry?.room || portal?.originRoom || dungeon.current || dungeon.start;
    if(!targetRoom){ return false; }
    dungeon.current = targetRoom;
    clearBossSummonTracker();
    clearRoomDecals();
    targetRoom.visited = true;
    player.handleRoomChange(targetRoom);
    const fallback = targetRoom.center ? targetRoom.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    const baseX = clamp(entry?.x ?? fallback.x, 70, CONFIG.roomW-70);
    const baseY = clamp(entry?.y ?? fallback.y, 80, CONFIG.roomH-80);
    const portalPos = entry?.portal;
    if(portalPos){
      player.x = clamp(portalPos.x + 46, 70, CONFIG.roomW-70);
      player.y = clamp(portalPos.y + 46, 80, CONFIG.roomH-80);
    } else {
      player.x = baseX;
      player.y = baseY;
    }
    player.snapFollowersToPlayer();
    player.knockVel.x = 0; player.knockVel.y = 0; player.knockTimer = 0;
    if(player.vel){ player.vel.x = 0; player.vel.y = 0; }
    player.moveDir.x = 0; player.moveDir.y = 0;
    player.lastDisplacement.x = 0; player.lastDisplacement.y = 0;
    if(player.lastVelocity){ player.lastVelocity.x = 0; player.lastVelocity.y = 0; }
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    handleRoomEntry(targetRoom, 'center', {spawnEffects:false});
    if(runtime.itemPickupTimer<=0){
      runtime.itemPickupName = '返回 Boss 房';
      runtime.itemPickupDesc = '交换房入口仍然敞开。';
      runtime.itemPickupTimer = 1.6;
    }
    return true;
  }

  function updateRoomPortal(room, dt){
    const portals = roomPortals(room);
    if(!portals.length) return;
    for(const portal of portals){
      if(!portal || portal.used) continue;
      portal.phase = (portal.phase || 0) + dt;
      if(!portal.active){
        const delay = portal.spawnDelay ?? 0;
        if(delay>0){
          portal.spawnDelay = Math.max(0, delay - dt);
          if(portal.spawnDelay<=0){ portal.active = true; }
        } else {
          portal.active = true;
        }
      }
      if(!portal.active){
        portal.interactable = false;
        portal.highlight = Math.max(0, (portal.highlight || 0) - dt*2.6);
        continue;
      }
      const interactRadius = portal.interactRadius ?? (portal.r + 18);
      const distance = player ? dist(player, portal) : Infinity;
      portal.interactable = distance <= interactRadius;
      const target = portal.interactable ? 1 : 0;
      const rate = portal.interactable ? 4 : 2.4;
      portal.highlight = portal.highlight || 0;
      if(portal.highlight < target){
        portal.highlight = Math.min(target, portal.highlight + dt * rate);
      } else if(portal.highlight > target){
        portal.highlight = Math.max(target, portal.highlight - dt * rate);
      }
    }
    cleanupRoomPortals(room);
  }

  function drawPortal(portal){
    if(!portal || portal.used) return;
    const cfg = CONFIG.portal || {};
    const radius = portal.r ?? (cfg.radius ?? 34);
    const wobble = 1 + 0.08*Math.sin((portal.phase || 0) * 4.2);
    const highlight = portal.highlight || 0;
    let hint = portal.hint;
    if(!hint){
      if(portal.type === 'exchange'){ hint = '按 F 进入交换房'; }
      else if(portal.type === 'return'){ hint = '按 F 返回'; }
      else { hint = cfg.hint || '按 F 进入下一层'; }
    }

    ctx.save();
    ctx.globalAlpha = 0.35 + highlight*0.15;
    const baseColor = portal.type === 'exchange' ? '#1e3a8a'
      : (portal.type === 'return' ? '#064e3b'
      : (portal.type === 'loop' ? '#1e1b4b'
      : (portal.type === 'ending' ? '#421010' : '#0f172a')));
    ctx.fillStyle = `${baseColor}cc`;
    ctx.beginPath();
    ctx.ellipse(portal.x, portal.y + radius*0.45, radius*0.9, radius*0.32, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(portal.x, portal.y);
    const outerR = radius * wobble;
    let gradient;
    if(portal.type === 'exchange'){
      gradient = ctx.createRadialGradient(0,0, outerR*0.18, 0,0, outerR);
      gradient.addColorStop(0, `rgba(147,197,253,${0.8 + 0.2*highlight})`);
      gradient.addColorStop(0.55, 'rgba(59,130,246,0.55)');
      gradient.addColorStop(1, 'rgba(37,99,235,0.2)');
    } else if(portal.type === 'return'){
      gradient = ctx.createRadialGradient(0,0, outerR*0.18, 0,0, outerR);
      gradient.addColorStop(0, `rgba(134,239,172,${0.8 + 0.2*highlight})`);
      gradient.addColorStop(0.55, 'rgba(74,222,128,0.5)');
      gradient.addColorStop(1, 'rgba(22,163,74,0.2)');
    } else if(portal.type === 'loop'){
      gradient = ctx.createRadialGradient(0,0, outerR*0.18, 0,0, outerR);
      gradient.addColorStop(0, `rgba(165,180,252,${0.85 + 0.2*highlight})`);
      gradient.addColorStop(0.55, 'rgba(99,102,241,0.55)');
      gradient.addColorStop(1, 'rgba(59,37,188,0.25)');
    } else if(portal.type === 'ending'){
      gradient = ctx.createRadialGradient(0,0, outerR*0.18, 0,0, outerR);
      gradient.addColorStop(0, `rgba(254,226,226,${0.85 + 0.2*highlight})`);
      gradient.addColorStop(0.55, 'rgba(248,113,113,0.55)');
      gradient.addColorStop(1, 'rgba(127,29,29,0.25)');
    } else {
      gradient = ctx.createRadialGradient(0,0, outerR*0.18, 0,0, outerR);
      gradient.addColorStop(0, `rgba(110,231,255,${0.8 + 0.2*highlight})`);
      gradient.addColorStop(0.55, 'rgba(167,139,250,0.55)');
      gradient.addColorStop(1, 'rgba(56,189,248,0.2)');
    }
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0,0, outerR, outerR*0.65, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.lineWidth = 2.5 + highlight*2.2;
    let strokeColor;
    if(portal.type === 'exchange'){ strokeColor = `rgba(96,165,250,${0.65 + 0.25*highlight})`; }
    else if(portal.type === 'return'){ strokeColor = `rgba(134,239,172,${0.65 + 0.25*highlight})`; }
    else if(portal.type === 'loop'){ strokeColor = `rgba(129,140,248,${0.65 + 0.25*highlight})`; }
    else if(portal.type === 'ending'){ strokeColor = `rgba(248,113,113,${0.65 + 0.25*highlight})`; }
    else { strokeColor = `rgba(125,211,252,${0.65 + 0.25*highlight})`; }
    ctx.strokeStyle = strokeColor;
    ctx.beginPath();
    ctx.ellipse(0,0, outerR*0.78, outerR*0.5, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.rotate((portal.phase || 0) * 1.8);
    const arcCount = 4;
    for(let i=0;i<arcCount;i++){
      ctx.beginPath();
      ctx.strokeStyle = `rgba(186,230,253,${0.4 + 0.3*highlight})`;
      ctx.lineWidth = 1.6 + highlight*1.2;
      const start = (Math.PI*2/arcCount)*i;
      ctx.arc(0,0, outerR*0.55, start, start + Math.PI*0.6);
      ctx.stroke();
    }
    ctx.restore();

    if(portal.interactable){
      ctx.save();
      ctx.font = '16px "Microsoft YaHei", system-ui';
      ctx.fillStyle = '#e0f2fe';
      ctx.textAlign = 'center';
      ctx.fillText(hint, portal.x, portal.y - radius*1.2 - 12);
      ctx.restore();
    }
  }

  // ======= 运行时上下文 =======
  const runtime = {
    bullets: [],
    enemyProjectiles: [],
    pendingEnemySpawns: [],
    beams: [],
    bossIntroTimer: 0,
    bossIntroText: '',
    itemPickupTimer: 0,
    itemPickupName: '',
    itemPickupDesc: '',
    floor: currentFloor,
    effects: [],
    decals: [],
    bossSummons: new Map(),
    screenShake: {intensity:0, duration:0, offsetX:0, offsetY:0},
    timeStopTimer: 0,
    timeStopDuration: 0,
    timeStopSource: null,
    timeStopFlash: 0,
    exchangePortalChance: 1,
    exchangePortalPity: 0,
    roomStack: [],
    exchangeRoom: null,
    runTimer: createRunTimer(),
    loopCount: 0,
    endingStats: null,
    weightedPity: Object.create(null),
    roomTransition: null,
    roomEntryLock: 0,
  };
  function resetScreenShake(){
    if(!runtime.screenShake) runtime.screenShake = {intensity:0, duration:0, offsetX:0, offsetY:0};
    else {
      runtime.screenShake.intensity = 0;
      runtime.screenShake.duration = 0;
      runtime.screenShake.offsetX = 0;
      runtime.screenShake.offsetY = 0;
    }
  }

  function getRoomTransitionDuration(){
    const cfg = CONFIG.roomTransition || {};
    const value = Number(cfg.duration);
    return Number.isFinite(value) ? Math.max(0.12, value) : 0.42;
  }

  function getRoomEntryLockDuration(targetRoom){
    if(targetRoom && (targetRoom.cleared || targetRoom.isSafeRoom)){
      return 0;
    }
    const cfg = CONFIG.roomTransition || {};
    const value = Number(cfg.lockDuration);
    return Number.isFinite(value) ? Math.max(0, value) : 0.3;
  }

  function setRoomEntryLock(duration){
    const target = Math.max(0, Number(duration) || 0);
    runtime.roomEntryLock = Math.max(runtime.roomEntryLock || 0, target);
    if(player){
      player.entryLockTimer = Math.max(player.entryLockTimer || 0, runtime.roomEntryLock);
      if(runtime.roomEntryLock<=0){
        player.entryLockActive = false;
      }
    }
  }

  function startRoomEntryTransition(direction, options={}){
    const duration = Math.max(0, Number(options.duration) || getRoomTransitionDuration());
    if(duration>0){
      runtime.roomTransition = {
        active: true,
        timer: duration,
        duration,
        progress: 0,
        direction: options.direction || direction || 'center',
      };
    } else {
      runtime.roomTransition = null;
    }
    const hasCustomLock = options.lock;
    let lockValue;
    if(hasCustomLock === undefined){
      lockValue = getRoomEntryLockDuration(options.room);
    } else {
      lockValue = Math.max(0, Number(hasCustomLock) || 0);
    }
    if(lockValue>0){
      setRoomEntryLock(lockValue);
    } else {
      runtime.roomEntryLock = 0;
      if(player){
        player.entryLockTimer = 0;
        player.entryLockActive = false;
      }
    }
    if(options.playSound !== false){
      const rawVolume = Number.isFinite(options.soundVolume) ? options.soundVolume : 0.45;
      audio.play('roomTransition', {volume: clamp(rawVolume, 0, 1)});
    }
  }

  function updateRoomTransition(dt){
    const trans = runtime.roomTransition;
    if(!trans) return;
    if(trans.active){
      const currentTimer = Number.isFinite(trans.timer) ? trans.timer : trans.duration;
      trans.timer = Math.max(0, currentTimer - dt);
      const denom = Math.max(0.0001, trans.duration || 0.0001);
      trans.progress = clamp(1 - (trans.timer / denom), 0, 1);
      if(trans.timer<=0){
        trans.active = false;
      }
    }
    if(!trans.active && (!Number.isFinite(trans.progress) || trans.progress>=1)){
      runtime.roomTransition = null;
    }
  }

  function drawRoomTransitionOverlay(){
    const trans = runtime.roomTransition;
    if(!trans) return;
    const progress = clamp(trans.progress ?? 0, 0, 1);
    const fade = Math.sin(progress * Math.PI);
    if(fade <= 0.001) return;
    ctx.save();
    ctx.globalAlpha = 0.45 * fade;
    ctx.fillStyle = '#080b12';
    ctx.fillRect(0,0,CONFIG.roomW, CONFIG.roomH);
    ctx.restore();

    ctx.save();
    const dir = trans.direction || 'center';
    let startX = 0, startY = 0, endX = 0, endY = 0;
    if(dir==='left'){
      startX = CONFIG.roomW;
      endX = 0;
    } else if(dir==='right'){
      startX = 0;
      endX = CONFIG.roomW;
    } else if(dir==='up'){
      startY = CONFIG.roomH;
      endY = 0;
    } else if(dir==='down'){
      startY = 0;
      endY = CONFIG.roomH;
    } else {
      startX = CONFIG.roomW/2;
      startY = CONFIG.roomH/2;
      endX = startX;
      endY = startY;
    }
    const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
    gradient.addColorStop(0, 'rgba(148,163,184,0)');
    gradient.addColorStop(0.4, 'rgba(148,163,184,0.28)');
    gradient.addColorStop(0.7, 'rgba(15,23,42,0.62)');
    gradient.addColorStop(1, 'rgba(8,11,17,0.9)');
    const slideBase = (dir==='left' || dir==='right') ? CONFIG.roomW : CONFIG.roomH;
    const offset = (1 - progress) * slideBase * 0.6;
    let tx = 0, ty = 0;
    if(dir==='left') tx = -offset;
    else if(dir==='right') tx = offset;
    else if(dir==='up') ty = -offset;
    else if(dir==='down') ty = offset;
    ctx.translate(tx, ty);
    ctx.globalAlpha = 0.7 * fade;
    ctx.fillStyle = gradient;
    ctx.fillRect(-CONFIG.roomW, -CONFIG.roomH, CONFIG.roomW*3, CONFIG.roomH*3);
    ctx.restore();
  }

  function handleRoomEntry(room, direction='center', options={}){
    if(!room) return;
    const spawnList = Array.isArray(options.enemies)
      ? options.enemies
      : Array.isArray(room.enemies)
        ? room.enemies
        : [];

    if(options.transition !== false){
      const transitionOptions = { direction, room };
      if(Number.isFinite(options.transitionDuration)){
        transitionOptions.duration = options.transitionDuration;
      }
      if(Number.isFinite(options.lockDuration)){
        transitionOptions.lock = options.lockDuration;
      }
      if(options.transitionSound === false){
        transitionOptions.playSound = false;
      }
      if(Number.isFinite(options.transitionVolume)){
        transitionOptions.soundVolume = options.transitionVolume;
      }
      startRoomEntryTransition(direction, transitionOptions);
    } else {
      let lockValue;
      if(Number.isFinite(options.lockDuration)){
        lockValue = Math.max(0, options.lockDuration);
      } else {
        lockValue = getRoomEntryLockDuration(room);
      }
      if(lockValue>0){
        setRoomEntryLock(lockValue);
      } else {
        runtime.roomEntryLock = 0;
        if(player){
          player.entryLockTimer = 0;
          player.entryLockActive = false;
        }
      }
    }

    if(options.spawnEffects !== false && spawnList.length){
      const spawnOptions = {};
      if(Number.isFinite(options.fadeDuration)){
        spawnOptions.fadeDuration = options.fadeDuration;
      }
      if(options.spawnSound === false){
        spawnOptions.playSound = false;
      }
      if(Number.isFinite(options.spawnSoundVolume)){
        spawnOptions.soundVolume = options.spawnSoundVolume;
      }
      triggerEnemySpawnEffects(spawnList, spawnOptions);
    }

    if(room.isBoss && !room.cleared && options.bossRumble !== false){
      const volume = Number.isFinite(options.bossRumbleVolume) ? options.bossRumbleVolume : 0.7;
      audio.play('bossRumble', {volume: clamp(volume, 0, 1)});
    }
  }

  function updateRunClock(dt, options={}){
    const timer = runtime.runTimer;
    if(!timer) return;
    const pausedByStop = !!options.timeStop;
    timer.setPauseSource('timeStop', pausedByStop);
    const scale = player?.getWorldTimeScale ? player.getWorldTimeScale() : 1;
    timer.setScaleSource('player', Number.isFinite(scale) ? scale : 1);
    timer.tick(dt);
  }
  function addScreenShake(power=4, duration=0.3){
    if(!runtime.screenShake) resetScreenShake();
    const shake = runtime.screenShake;
    shake.intensity = Math.max(shake.intensity, Math.max(0, power));
    shake.duration = Math.max(shake.duration, Math.max(0, duration));
  }
  function updateScreenShake(dt){
    const shake = runtime.screenShake;
    if(!shake) return;
    if(shake.duration>0){
      shake.duration = Math.max(0, shake.duration - dt);
      const decay = Math.exp(-dt*8);
      shake.intensity *= decay;
      if(shake.intensity < 0.05 || shake.duration<=0){
        shake.intensity = 0;
        shake.offsetX = 0;
        shake.offsetY = 0;
        return;
      }
      const angle = Math.random()*Math.PI*2;
      const magnitude = shake.intensity;
      shake.offsetX = Math.cos(angle) * magnitude;
      shake.offsetY = Math.sin(angle) * magnitude;
    } else {
      shake.intensity = 0;
      shake.offsetX = 0;
      shake.offsetY = 0;
    }
  }
  let dungeon, player;

  function startGame(){
    overlayManager.clear();
    recentItemHistory.length = 0;
    recentShopItemHistory.length = 0;
    recentCardHistory.length = 0;
    runtime.loopCount = 0;
    runtime.endingStats = null;
    if(runtime.runTimer){
      runtime.runTimer.reset();
      runtime.runTimer.start();
    }
    currentFloor = 1;
    runtime.floor = currentFloor;
    dungeon = new Dungeon();
    player = new Player(CONFIG.roomW/2, CONFIG.roomH/2);
    keys.clear();
    dungeon.current.visited=true;
    dungeon.revealRoom(dungeon.current);
    const initialEnemies = dungeon.current.spawnEnemies(dungeon.depth);
    state = STATE.PLAY;
    lastTime = performance.now();
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    runtime.beams = [];
    runtime.bossIntroTimer = 0;
    runtime.bossIntroText = '';
    runtime.itemPickupTimer = 0;
    runtime.itemPickupName = '';
    runtime.itemPickupDesc = '';
    runtime.exchangePortalChance = 1;
    runtime.exchangePortalPity = 0;
    runtime.roomStack.length = 0;
    runtime.exchangeRoom = null;
    runtime.effects.length = 0;
    clearRoomDecals();
    clearBossSummonTracker();
    runtime.timeStopTimer = 0;
    runtime.timeStopDuration = 0;
    runtime.timeStopSource = null;
    runtime.timeStopFlash = 0;
    runtime.weightedPity = Object.create(null);
    resetScreenShake();
    player.handleRoomChange(dungeon.current);
    player.snapFollowersToPlayer();
    handleRoomEntry(dungeon.current, 'center', {enemies: initialEnemies});
    syncCheatPanel();
  }

  function advanceToNextFloor(){
    if(!player || !dungeon) return;
    const prevDepth = dungeon.depth || 1;
    const portalRoom = dungeon.current;
    if(portalRoom?.portal){ portalRoom.portal.used = true; portalRoom.portal = null; }
    currentFloor = Math.max(1, currentFloor + 1);
    runtime.floor = currentFloor;
    const preservedKeys = new Set(keys);
    dungeon = new Dungeon();
    dungeon.depth = Math.max(prevDepth + 1, 1);
    dungeon.current.visited = true;
    dungeon.revealRoom(dungeon.current);
    if(player.fullMapVision){
      if(typeof player.enableFullMapVision === 'function'){
        player.enableFullMapVision(dungeon);
      } else if(typeof dungeon.revealAllRooms === 'function'){
        dungeon.revealAllRooms();
      }
    }
    const spawned = dungeon.current.spawnEnemies(dungeon.depth);
    player.handleRoomChange(dungeon.current);
    player.x = CONFIG.roomW/2;
    player.y = CONFIG.roomH/2;
    player.knockVel.x = 0;
    player.knockVel.y = 0;
    player.knockTimer = 0;
    if(player.vel){ player.vel.x = 0; player.vel.y = 0; }
    player.moveDir.x = 0;
    player.moveDir.y = 0;
    player.lastDisplacement.x = 0;
    player.lastDisplacement.y = 0;
    if(player.lastVelocity){ player.lastVelocity.x = 0; player.lastVelocity.y = 0; }
    player.ifr = 0;
    if(typeof player.interruptBrimstoneBeam === 'function'){ player.interruptBrimstoneBeam(); }
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    runtime.beams = [];
    runtime.bossIntroTimer = 0;
    runtime.bossIntroText = '';
    runtime.itemPickupName = `已抵达第 ${currentFloor} 层`;
    runtime.itemPickupDesc = '敌人变得更加愤怒。';
    runtime.itemPickupTimer = 2.6;
    runtime.exchangePortalChance = 1;
    runtime.exchangePortalPity = 0;
    runtime.roomStack.length = 0;
    runtime.exchangeRoom = null;
    runtime.effects.length = 0;
    clearRoomDecals();
    clearBossSummonTracker();
    runtime.timeStopTimer = 0;
    runtime.timeStopDuration = 0;
    runtime.timeStopSource = null;
    runtime.timeStopFlash = 0;
    runtime.weightedPity = Object.create(null);
    resetScreenShake();
    keys.clear();
    for(const code of preservedKeys){ keys.add(code); }
    player.snapFollowersToPlayer();
    handleRoomEntry(dungeon.current, 'center', {enemies: spawned});
    syncCheatPanel();
  }

  function startLoopRun(options={}){
    if(!player) return false;
    const preservedKeys = new Set(keys);
    runtime.loopCount = (runtime.loopCount || 0) + 1;
    runtime.endingStats = null;
    const hadVision = !!player.fullMapVision;
    currentFloor = 1;
    runtime.floor = currentFloor;
    dungeon = new Dungeon();
    dungeon.depth = 1;
    dungeon.current.visited = true;
    dungeon.revealRoom(dungeon.current);
    if(hadVision){
      if(typeof player.enableFullMapVision === 'function'){
        player.enableFullMapVision(dungeon);
      } else if(typeof dungeon.revealAllRooms === 'function'){
        dungeon.revealAllRooms();
      }
    }
    const loopEnemies = dungeon.current.spawnEnemies(dungeon.depth);
    player.handleRoomChange(dungeon.current);
    player.x = CONFIG.roomW/2;
    player.y = CONFIG.roomH/2;
    player.knockVel.x = 0; player.knockVel.y = 0; player.knockTimer = 0;
    if(player.vel){ player.vel.x = 0; player.vel.y = 0; }
    player.moveDir.x = 0; player.moveDir.y = 0;
    player.lastDisplacement.x = 0; player.lastDisplacement.y = 0;
    if(player.lastVelocity){ player.lastVelocity.x = 0; player.lastVelocity.y = 0; }
    player.ifr = 0;
    if(typeof player.interruptBrimstoneBeam === 'function'){ player.interruptBrimstoneBeam(); }
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    runtime.beams = [];
    runtime.bossIntroTimer = 0;
    runtime.bossIntroText = '';
    const cycleLabel = runtime.loopCount + 1;
    runtime.itemPickupName = `轮回 ${cycleLabel} 开启`;
    runtime.itemPickupDesc = '携带全部装备重返第一层。';
    runtime.itemPickupTimer = 2.4;
    runtime.exchangePortalChance = 1;
    runtime.exchangePortalPity = 0;
    runtime.roomStack.length = 0;
    runtime.exchangeRoom = null;
    runtime.effects.length = 0;
    clearRoomDecals();
    clearBossSummonTracker();
    runtime.timeStopTimer = 0;
    runtime.timeStopDuration = 0;
    runtime.timeStopSource = null;
    runtime.timeStopFlash = 0;
    runtime.weightedPity = Object.create(null);
    resetScreenShake();
    keys.clear();
    for(const code of preservedKeys){ keys.add(code); }
    player.snapFollowersToPlayer();
    handleRoomEntry(dungeon.current, 'center', {enemies: loopEnemies});
    syncCheatPanel();
    if(options.fromEnding){
      runtime.runTimer?.setPauseSource('gameover', false);
      runtime.runTimer?.setPauseSource('ending', false);
      runtime.runTimer?.setPauseSource('pause', false);
      runtime.runTimer?.start();
      lastTime = performance.now();
      overlayManager.clear();
      state = STATE.PLAY;
    }
    return true;
  }

  function triggerRunEnding(){
    const timer = runtime.runTimer;
    if(timer){ timer.setPauseSource('ending', true); }
    const timeText = timer ? timer.format() : '00:00.00';
    const loops = runtime.loopCount || 0;
    const cycleIndex = loops + 1;
    const summary = loops>0
      ? `你完成了第 ${cycleIndex} 次轮回，累计耗时 ${timeText}。`
      : `你用 ${timeText} 穿越了全部 ${FINAL_FLOOR} 层。`;
    const detail = loops>0
      ? '若还不满足，轮回之门仍在等待你的脚步。'
      : '带着力量迈入轮回，或留在此刻歇息片刻。';
    if(endingTitleNode){ endingTitleNode.textContent = loops>0 ? '轮回仍未终止' : '终局小憩'; }
    if(endingSummaryNode){ endingSummaryNode.textContent = summary; }
    if(endingDetailNode){ endingDetailNode.textContent = detail; }
    runtime.endingStats = {time: timeText, loops, floor: currentFloor};
    runtime.itemPickupTimer = 0;
    state = STATE.OVER;
    overlayManager.setActive('ending');
  }

  // ======= 门与换房 =======
  function roomDoors(r){
    if(!r) return [];
    const state = r.doors || {up:false, down:false, left:false, right:false};
    const doors = [];
    const w=CONFIG.roomW, h=CONFIG.roomH;
    const doorW=60, doorH=10, offset=22;
    if(state.up) doors.push({dir:'up',   x:w/2-doorW/2, y:offset,      w:doorW, h:doorH});
    if(state.down) doors.push({dir:'down', x:w/2-doorW/2, y:h-offset-doorH, w:doorW, h:doorH});
    if(state.left) doors.push({dir:'left', x:offset,      y:h/2-doorW/2, w:doorH, h:doorW});
    if(state.right) doors.push({dir:'right',x:w-offset-doorH, y:h/2-doorW/2, w:doorH, h:doorW});
    return doors;
  }
  function isRoomReadyForExit(room){
    if(!room) return false;
    if(room.isBoss && !room.cleared) return false;
    return !!room.cleared;
  }

  function enterRoom(nextRoom, direction, options={}){
    if(!nextRoom) return;
    dungeon.current = nextRoom;
    if(!nextRoom.visited){ dungeon.depth++; }
    nextRoom.visited = true;
    dungeon.revealRoom(nextRoom);
    clearBossSummonTracker();
    clearRoomDecals();
    player.handleRoomChange(nextRoom);

    const dir = direction || 'center';
    if(dir==='up'){ player.x=CONFIG.roomW/2; player.y=CONFIG.roomH-60; }
    else if(dir==='down'){ player.x=CONFIG.roomW/2; player.y=60; }
    else if(dir==='left'){ player.x=CONFIG.roomW-60; player.y=CONFIG.roomH/2; }
    else if(dir==='right'){ player.x=60; player.y=CONFIG.roomH/2; }
    else {
      player.x = CONFIG.roomW/2;
      player.y = CONFIG.roomH/2;
    }

    player.snapFollowersToPlayer(dir);

    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    runtime.beams = [];

    if(nextRoom.isBoss && !nextRoom.introPlayed){
      runtime.bossIntroText = nextRoom.bossName;
      runtime.bossIntroTimer = 3.2;
      nextRoom.introPlayed = true;
    }
    if(nextRoom.isItemRoom){ nextRoom.ensureItem(); }
    if(nextRoom.isShop){ nextRoom.prepareShop(); }

    let spawnSet = null;
    if(!nextRoom.cleared || nextRoom.isBoss){
      spawnSet = nextRoom.spawnEnemies(dungeon.depth);
    }
    const enemiesForEntry = Array.isArray(spawnSet) ? spawnSet : nextRoom.enemies;
    const entryOptions = Object.assign({}, options, {enemies: enemiesForEntry});
    handleRoomEntry(nextRoom, dir, entryOptions);
  }

  function tryRoomTransition(){
    const r = dungeon.current;
    const doors = roomDoors(r);
    for(const d of doors){
      const ni = r.i + (d.dir==='down') - (d.dir==='up');
      const nj = r.j + (d.dir==='right') - (d.dir==='left');
      const nr = dungeon.rooms[ni]?.[nj];
      if(!nr) continue;
      if(!rectCircleOverlap(d.x,d.y,d.w,d.h, player.x,player.y,player.r)) continue;
      if(!isRoomReadyForExit(r)){
        if(runtime.itemPickupTimer<=0){
          runtime.itemPickupName = '房门紧闭';
          runtime.itemPickupDesc = '先清理完本房间的敌人。';
          runtime.itemPickupTimer = 1.2;
        }
        continue;
      }
      if(nr.locked){
        if(player.keys>0){
          player.keys -= 1;
          player.recalculateDamage();
          nr.locked = false;
          if(runtime.itemPickupTimer<=0){
            runtime.itemPickupName = '钥匙冒着烟消失';
            runtime.itemPickupDesc = nr.isShop ? '商店老板：欢迎惠顾！' : '门锁：「勉强通过。」';
            runtime.itemPickupTimer = 1.4;
          }
        } else if(runtime.itemPickupTimer<=0){
          runtime.itemPickupName = '缺钥匙提示';
          runtime.itemPickupDesc = '门锁不吃嘴炮，只认金属';
          runtime.itemPickupTimer = 1.2;
        }
        continue;
      }
      const bossOptions = (nr.isBoss && !nr.cleared)
        ? {bossRumbleVolume: 0.85, transitionVolume: 0.58, spawnSoundVolume: 0.62}
        : {};
      enterRoom(nr, d.dir, bossOptions);
      break;
    }
  }
  function rectCircleOverlap(rx,ry,rw,rh, cx,cy,cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }
  function circleRectOverlap(circle, rect){
    return rectCircleOverlap(rect.x, rect.y, rect.w, rect.h, circle.x, circle.y, circle.r);
  }
  function pointSegmentDistance(px,py, ax,ay, bx,by){
    const dx = bx - ax;
    const dy = by - ay;
    const lenSq = dx*dx + dy*dy;
    let t = 0;
    if(lenSq > 1e-6){
      t = ((px - ax) * dx + (py - ay) * dy) / lenSq;
    }
    t = clamp(t, 0, 1);
    const cx = ax + dx * t;
    const cy = ay + dy * t;
    const distSq = (px - cx)*(px - cx) + (py - cy)*(py - cy);
    return {distance: Math.sqrt(Math.max(0, distSq)), t, cx, cy};
  }
  function resolveEntityObstacles(entity){
    if(!dungeon?.current) return;
    if(entity===player){
      if(player.flying) return;
    } else if(entity?.flying){
      return;
    }
    const playerSmash = entity===player
      && typeof player?.isImpactDashing === 'function'
      && player.isImpactDashing()
      && player.impactDash?.canBreakObstacles;
    for(const obs of dungeon.current.obstacles){
      if(obs.destroyed) continue;
      if(playerSmash && circleRectOverlap(entity, obs)){
        obs.destroyed = true;
        onObstacleDestroyed(dungeon.current, obs);
        continue;
      }
      const push = circleRectResolve(entity, obs);
      if(push){
        entity.x += push.x;
        entity.y += push.y;
        if(entity.knockVel){ entity.knockVel.x *= 0.5; entity.knockVel.y *= 0.5; }
      }
    }
  }

  function resolveEnemyBombBlocking(enemy){
    if(!enemy || !dungeon?.current) return;
    const bombs = dungeon.current.bombs;
    if(!Array.isArray(bombs) || !bombs.length) return;
    for(const bomb of bombs){
      if(!bomb || bomb.done || bomb.exploded) continue;
      if(bomb.spawnGrace>0) continue;
      const br = bomb.r || 0;
      const er = enemy.r || 0;
      if(er<=0 || br<=0) continue;
      const dx = enemy.x - bomb.x;
      const dy = enemy.y - bomb.y;
      const minDist = er + br;
      const distSq = dx*dx + dy*dy;
      if(distSq >= minDist*minDist) continue;
      const dist = Math.sqrt(distSq) || 0.0001;
      const overlap = minDist - dist;
      if(!(overlap>0)) continue;
      const nx = dx / dist;
      const ny = dy / dist;
      const push = overlap + 0.6;
      const prevX = enemy.x;
      const prevY = enemy.y;
      enemy.x += nx * push;
      enemy.y += ny * push;
      if(enemy.base && typeof enemy.base === 'object'){
        if(Number.isFinite(enemy.base.x)) enemy.base.x += enemy.x - prevX;
        if(Number.isFinite(enemy.base.y)) enemy.base.y += enemy.y - prevY;
      }
      if(enemy.knockVel){
        const dot = enemy.knockVel.x*nx + enemy.knockVel.y*ny;
        if(dot>0){
          enemy.knockVel.x -= dot*nx*0.85;
          enemy.knockVel.y -= dot*ny*0.85;
        }
      }
      if(typeof enemy.vx === 'number' && typeof enemy.vy === 'number'){
        const velDot = enemy.vx*nx + enemy.vy*ny;
        if(velDot>0){
          enemy.vx -= velDot*nx;
          enemy.vy -= velDot*ny;
        }
      }
      if(typeof enemy.onBombBlocked === 'function'){
        enemy.onBombBlocked(bomb, {nx, ny, overlap: push});
      }
    }
  }
  function circleRectResolve(circle, rect){
    if(!circle || !rect) return null;
    const closestX = clamp(circle.x, rect.x, rect.x + rect.w);
    const closestY = clamp(circle.y, rect.y, rect.y + rect.h);
    const dx = circle.x - closestX;
    const dy = circle.y - closestY;
    const r = circle.r || 0;
    const distSq = dx*dx + dy*dy;
    if(distSq >= r*r) return null;
    const insideX = closestX === circle.x;
    const insideY = closestY === circle.y;
    if(insideX && insideY){
      const centerX = rect.x + rect.w/2;
      const centerY = rect.y + rect.h/2;
      const diffX = circle.x - centerX;
      const diffY = circle.y - centerY;
      const absX = Math.abs(diffX);
      const absY = Math.abs(diffY);
      if(absX > absY){
        const sign = diffX>=0 ? 1 : -1;
        return {x: (rect.w/2 + r - absX) * sign, y:0};
      } else {
        const sign = diffY>=0 ? 1 : -1;
        return {x:0, y: (rect.h/2 + r - absY) * sign};
      }
    }
    if(insideX){
      const sign = dy>=0 ? 1 : -1;
      const overlap = r - Math.abs(dy);
      return {x:0, y: overlap * sign};
    }
    if(insideY){
      const sign = dx>=0 ? 1 : -1;
      const overlap = r - Math.abs(dx);
      return {x: overlap * sign, y:0};
    }
    const dist = Math.sqrt(distSq) || 0.0001;
    const overlap = r - dist;
    const ox = (dx/dist) * overlap;
    const oy = (dy/dist) * overlap;
    return {x:ox, y:oy};
  }

  // ======= 主循环 =======
  let lastTime = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now - lastTime) / 1000);
    if(state===STATE.PLAY){ update(dt); }
    draw();
    if(state===STATE.PLAY) lastTime = now; // 暂停时不要推进时间
  }
  requestAnimationFrame(loop);

  function update(dt){
    updateScreenShake(dt);
    if(runtime.timeStopFlash>0){
      runtime.timeStopFlash = Math.max(0, runtime.timeStopFlash - dt*2.4);
    }
    const timeStopActive = runtime.timeStopTimer>0;
    if(timeStopActive){
      runtime.timeStopTimer = Math.max(0, runtime.timeStopTimer - dt);
      if(runtime.timeStopTimer<=0){
        runtime.timeStopTimer = 0;
        runtime.timeStopSource = null;
        runtime.timeStopDuration = 0;
      }
    }
    updateRunClock(dt, {timeStop: timeStopActive});
    if(runtime.roomEntryLock>0){
      runtime.roomEntryLock = Math.max(0, runtime.roomEntryLock - dt);
    }
    updateRoomTransition(dt);
    const worldDt = timeStopActive ? 0 : dt;
    const entryLocked = runtime.roomEntryLock>0;
    player.update(dt, {entryLocked, entryLockTime: runtime.roomEntryLock});

    const bombs = dungeon.current.bombs;
    const bombDt = entryLocked ? 0 : worldDt;
    for(let i=bombs.length-1;i>=0;i--){
      const b = bombs[i];
      b.update(bombDt);
      if(b.done){ bombs.splice(i,1); }
    }
    updatePickups(worldDt);
    updateRoomPortal(dungeon.current, worldDt);
    if(!timeStopActive){
      for(const b of bombs){
        if(b.done || b.exploded || b.spawnGrace>0) continue;
        const d = dist(player, b);
        if(d < player.r + b.r){
          const dx = b.x - player.x;
          const dy = b.y - player.y;
          const len = Math.hypot(dx,dy) || 1;
          const overlap = player.r + b.r - d;
          if(overlap>0){
            b.x += (dx/len) * overlap;
            b.y += (dy/len) * overlap;
          }
          const moveImpulse = Math.hypot(player.lastDisplacement.x, player.lastDisplacement.y);
          const pushPower = 140 + moveImpulse * 420;
          b.applyImpulse(dx, dy, pushPower);
        }
      }
    }

    // 子弹
    const bulletDt = entryLocked ? 0 : dt;
    for(const b of runtime.bullets) b.update(bulletDt);
    runtime.bullets = runtime.bullets.filter(b=>b.alive);

    // 敌人
    const enemies = dungeon.current.enemies;
    const enemyDt = entryLocked ? 0 : worldDt;
    for(const e of enemies){
      e.update(enemyDt);
      resolveEnemyBombBlocking(e);
      if(typeof e.damageFlashTimer === 'number' && e.damageFlashTimer>0){
        e.damageFlashTimer = Math.max(0, e.damageFlashTimer - worldDt);
      }
      if(typeof e.spawnFadeTimer === 'number' && e.spawnFadeTimer>0){
        const duration = Math.max(0.001, Number(e.spawnFadeDuration) || ENEMY_SPAWN_FADE_DEFAULT);
        e.spawnFadeTimer = Math.max(0, e.spawnFadeTimer - dt);
        if(e.spawnFadeTimer<=0){
          e.spawnFadeTimer = 0;
        } else if(!Number.isFinite(e.spawnFadeDuration)){
          e.spawnFadeDuration = duration;
        }
      }
    }
    if(!timeStopActive && runtime.pendingEnemySpawns.length){
      while(runtime.pendingEnemySpawns.length){
        const spawn = prepareEnemy(runtime.pendingEnemySpawns.shift());
        if(spawn){
          if(spawn.isBossSummon && !spawn.bossSummoner && spawn.master && spawn.master.isBossEntity){
            spawn.bossSummoner = spawn.master;
          }
          if(spawn.isBossSummon){ registerBossSummon(spawn); }
          enemies.push(spawn);
          triggerEnemySpawnEffects([spawn], {playSound:false, fadeDuration: ENEMY_SPAWN_FADE_DEFAULT * 0.8});
        }
      }
    }
    updateBeams(dt);

    // 敌方弹幕
    const enemyProjectileDt = entryLocked ? 0 : worldDt;
    for(const eb of runtime.enemyProjectiles){ eb.update(enemyProjectileDt); }
    runtime.enemyProjectiles = runtime.enemyProjectiles.filter(p=>p.alive);

    // 碰撞：子弹-敌人
    for(const b of runtime.bullets){
      for(const e of enemies){
        if(e.dead) continue;
        if(b.pierceEnemies && typeof b.hasHitEnemy === 'function' && b.hasHitEnemy(e)) continue;
        const dd = dist(b, e);
        if(dd < (b.r + e.r)){
          const killed = e.damage(b.damage);
          if(!killed){
            applyEnemyKnockback(e, b.vx, b.vy, {power: 90 + b.damage*18, duration:0.2, slowFactor:0.7, slowDuration:0.3, maxSpeed:300});
          } else {
            handleEnemyDeath(e, dungeon.current);
          }
          if(b.pierceEnemies){
            if(b.markEnemyHit){ b.markEnemyHit(e); }
            continue;
          }
          b.destroy({glowStrength:0.5}); break;
        }
      }
    }
    // 清理死亡
    const survivors = [];
    for(const e of enemies){
      if(e.dead){
        if(e.isBossSummon){ unregisterBossSummon(e); }
        continue;
      }
      survivors.push(e);
    }
    dungeon.current.enemies = survivors;

    // 玩家被弹幕命中
    if(!timeStopActive){
      for(const eb of runtime.enemyProjectiles){ if(eb.checkHit(player)){ eb.destroy({glowStrength:0.45}); } }
    }

    // 房间是否清空
    if(!dungeon.current.cleared && dungeon.current.enemies.length===0){
      dungeon.current.cleared = true;
      const room = dungeon.current;
      if(room.combatRoom && !room.chargeGranted){
        const gained = player.gainActiveCharge(1);
        if(gained && runtime.itemPickupTimer<=0){
          const maxCharge = Math.max(0, player.activeMaxCharge ?? 0);
          const current = Math.min(player.activeCharge, maxCharge);
          runtime.itemPickupName = '主动道具充能 +1';
          runtime.itemPickupDesc = maxCharge>0 ? `当前充能：${current}/${maxCharge}` : '能量已存入电容槽。';
          runtime.itemPickupTimer = 1.4;
        }
        room.chargeGranted = true;
      }
      // 小概率掉红心
      if(rand()<CONFIG.drops.heartRoomClear){
        dungeon.current.pickups.push(makeHeartPickup(randRange(120,CONFIG.roomW-120), randRange(120,CONFIG.roomH-120), 1));
      }
      if(rand()<CONFIG.drops.roomClearResource){
        const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
        const amount = resType==='coin'?4:1;
        dungeon.current.pickups.push(makeResourcePickup(resType, randRange(120,CONFIG.roomW-120), randRange(120,CONFIG.roomH-120), amount));
      }
    }

    // 拾取
    const picks = dungeon.current.pickups;
    for(let i=picks.length-1;i>=0;i--){
      const p = picks[i];
      if((p.spawnGrace||0)>0) continue;
      const distance = dist(p,player);
      if(distance < p.r + player.r){
        const movement = Math.hypot(player.lastDisplacement.x, player.lastDisplacement.y);
        const shove = 170 + movement * 420;
        if(p.type==='heart'){
          const result = tryPlayerCollectHeart(p);
          if(result.collected){
            if(result.consumed){
              picks.splice(i,1);
            }
          } else {
            pushPickup(p, player, shove);
          }
        } else if(p.type==='life-trade'){
          if(attemptLifeTradePickup(p)){
            picks.splice(i,1);
          }
        } else if(p.type==='item'){
          pickupItem(p);
          picks.splice(i,1);
        } else if(p.type==='bomb' || p.type==='key' || p.type==='coin'){
          const amount = p.amount || 1;
          const gained = grantResource(p.type, amount);
          if(gained>0){
            if(typeof p.amount === 'number'){
              p.amount = Math.max(0, amount - gained);
            }
            if(!p.amount){ picks.splice(i,1); }
          } else {
            pushPickup(p, player, shove);
          }
        } else if(p.type==='card'){
          if(!p.card){
            picks.splice(i,1);
          } else if(givePlayerCard(p.card, {room: dungeon.current, x: p.x, y: p.y})){ 
            picks.splice(i,1);
          } else {
            pushPickup(p, player, shove);
          }
        }
      }
    }

    // 换房
    tryRoomTransition();

    updateEffects(worldDt);

    // 更新 HUD
    renderHUD();
    runtime.bossIntroTimer = Math.max(0, runtime.bossIntroTimer - dt);
    runtime.itemPickupTimer = Math.max(0, runtime.itemPickupTimer - dt / PICKUP_BANNER_TIME_SCALE);
    if(runtime.itemPickupTimer<=0){ runtime.itemPickupName=''; runtime.itemPickupDesc=''; }
  }

  function renderHUD(){
    const redHearts = '❤'.repeat(Math.max(0,player.hp));
    const emptyHearts = '·'.repeat(Math.max(0, player.maxHp - player.hp));
    const soulDisplay = player.soulHearts>0 ? `<span class="kbd" style="color:#60a5fa">💙 ${player.soulHearts}</span>` : '';
    const runClock = runtime.runTimer ? runtime.runTimer.format() : '00:00.00';
    HUDL.innerHTML = `生命：<span style="letter-spacing:1px">${redHearts}${emptyHearts}</span>${soulDisplay}<span class="kbd">💣 ${player.bombs}</span><span class="kbd">🔑 ${player.keys}</span><span class="kbd">🪙 ${player.coins}</span><span class="kbd">⏱ ${runClock}</span>`;
    const attackRate = typeof player.getAttackRatePerSecond === 'function'
      ? player.getAttackRatePerSecond()
      : (player.fireInterval>0 ? 1000/player.fireInterval : 0);
    const fireRate = attackRate>0 ? attackRate.toFixed(2) : '0.00';
    const damage = Number.isInteger(player.damage) ? player.damage : player.damage.toFixed(1);
    const moveSpeed = Math.round(player.speed);
    const tearSpeed = Math.round(player.tearSpeed);
    const range = Math.round(player.tearSpeed * player.tearLife);
    const statItems = [
      {label:'攻速', value: fireRate, unit:'次/秒'},
      {label:'伤害', value: damage},
      {label:'移动速度', value: moveSpeed},
      {label:'子弹速度', value: tearSpeed},
      {label:'射程', value: range},
      {label:'交换门', value: `${Math.round(getExchangePortalChance()*100)}%`}
    ];
    HUDS.innerHTML = statItems.map(({label,value,unit})=>`<span>${label}：<strong>${value}</strong>${unit?`<small>${unit}</small>`:''}</span>`).join('');
    const itemsText = player.items.length ? player.items.map(name => {
      const count = Math.max(1, Number(player.itemNameStacks?.[name]) || 1);
      return `${name} ×${count}`;
    }).join('、') : '空手上阵';
    const floorLevel = runtime.floor || currentFloor || 1;
    const loopCycle = (runtime.loopCount || 0) + 1;
    const cycleText = loopCycle>1 ? ` · 第${loopCycle}轮` : '';
    const maxCharge = Math.max(0, player.activeMaxCharge ?? 0);
    const chargeValue = clamp(Math.floor(player.activeCharge ?? 0), 0, maxCharge);
    const ready = maxCharge>0 && chargeValue >= maxCharge && player.activeItem && typeof player.activeItem.use === 'function';
    const activeName = player.activeItem?.name || '空槽';
    const chargeLabel = maxCharge>0 ? `${chargeValue}/${maxCharge}` : '--';
    const activeBadge = ready ? `<span class="kbd" style="color:var(--ok)">⚡ 就绪</span>` : `<span class="kbd">⚡ ${chargeLabel}</span>`;
    const singleUseItem = player.singleUseItem;
    const singleUseName = singleUseItem?.name || '空槽';
    const singleUseReady = !!(singleUseItem && typeof singleUseItem.use === 'function');
    const singleUseBadge = singleUseReady ? `<span class="kbd" style="color:var(--accent)">Q 就绪</span>` : `<span class="kbd">Q --</span>`;
    if(dungeon.current.isBoss && dungeon.current.bossEntity && !dungeon.current.bossEntity.dead){
      HUDR.innerHTML = `<span style="display:flex;flex-direction:column;gap:2px;align-items:flex-end"><span>楼层：${floorLevel}${cycleText} / <span style="color:#ffb4c8">BOSS：${dungeon.current.bossEntity.name}</span></span><span>道具：${itemsText}</span><span>主动：${activeName} ${activeBadge}</span><span>卡牌：${singleUseName} ${singleUseBadge}</span></span>`;
    } else {
      HUDR.innerHTML = `<span style="display:flex;flex-direction:column;gap:2px;align-items:flex-end"><span>楼层：${floorLevel}${cycleText} / 已探索：${exploredRooms()} 间</span><span>道具：${itemsText}</span><span>主动：${activeName} ${activeBadge}</span><span>卡牌：${singleUseName} ${singleUseBadge}</span></span>`;
    }
    if(cheatPanelNode?.classList.contains('show')){ syncCheatPanel(); }
  }
  function exploredRooms(){
    let n=0; for(let i=0;i<dungeon.gridN;i++){for(let j=0;j<dungeon.gridN;j++){if(dungeon.rooms[i][j]?.visited) n++;}} return n;
  }

  // ======= 渲染 =======
  function draw(){
    ctx.clearRect(0,0,CONFIG.roomW, CONFIG.roomH);
    ctx.save();
    const shake = runtime.screenShake;
    if(shake && (Math.abs(shake.offsetX)>1e-3 || Math.abs(shake.offsetY)>1e-3)){
      ctx.translate(shake.offsetX, shake.offsetY);
    }
    drawRoomBackdrop();
    drawFloorDecals();
    drawDoors();
    drawObstacles();

    for(const p of dungeon.current.pickups){ drawPickup(p); }

    if(dungeon.current.portal){ drawPortal(dungeon.current.portal); }
    if(Array.isArray(dungeon.current.extraPortals)){
      for(const extraPortal of dungeon.current.extraPortals){
        drawPortal(extraPortal);
      }
    }

    for(const bomb of dungeon.current.bombs){ bomb.draw(); }

    for(const e of dungeon.current.enemies){
      drawEntityShadow(e);
      const fade = getEntitySpawnFade(e);
      ctx.save();
      if(fade<1){ ctx.globalAlpha *= fade; }
      e.draw();
      ctx.restore();
      if(e.damageFlashTimer>0){
        const ratio = clamp(e.damageFlashTimer / ENEMY_DAMAGE_FLASH_DURATION, 0, 1);
        const radius = (e.r || 12) * 1.15;
        ctx.save();
        ctx.globalAlpha = (0.3 + ratio * 0.35) * fade;
        ctx.fillStyle = '#ff4d4f';
        ctx.beginPath();
        ctx.arc(e.x, e.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    drawEffects();
    drawBeams();

    for(const eb of runtime.enemyProjectiles){ eb.draw(); }

    for(const b of runtime.bullets){ b.draw(); }

    drawFollowers();
    drawPlayer();
    ctx.restore();

    if(runtime.timeStopTimer>0 || runtime.timeStopFlash>0){
      ctx.save();
      const timer = Math.max(0, runtime.timeStopTimer || 0);
      const duration = Math.max(0.001, runtime.timeStopDuration || 0.001);
      const ratio = clamp(timer / duration, 0, 1);
      const flash = Math.max(0, runtime.timeStopFlash || 0);
      const baseAlpha = timer>0 ? (0.18 + 0.2 * ratio) : 0;
      const flashAlpha = flash>0 ? Math.min(0.35, flash * 0.35) : 0;
      const overlayAlpha = Math.min(0.55, baseAlpha + flashAlpha);
      if(overlayAlpha>0.01){
        ctx.fillStyle = `rgba(164,198,255,${overlayAlpha})`;
        ctx.fillRect(0,0,CONFIG.roomW,CONFIG.roomH);
        if(timer>0){
          const ringAlpha = Math.min(0.45, 0.25 + ratio * 0.35);
          if(ringAlpha>0.01){
            ctx.strokeStyle = `rgba(206,237,255,${ringAlpha})`;
            ctx.lineWidth = 6;
            ctx.strokeRect(18,18,CONFIG.roomW-36,CONFIG.roomH-36);
          }
        }
      }
      ctx.restore();
    }

    drawRoomTransitionOverlay();

    drawBossHealth();
    drawMiniMap();
    drawItemPickupBanner();

  }

  function drawFloorDecals(){
    if(!runtime.decals || runtime.decals.length===0) return;
    ctx.save();
    for(const decal of runtime.decals){
      const alpha = decal.alpha ?? 0;
      if(alpha<=0) continue;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = decal.color || 'rgba(148,0,30,0.55)';
      ctx.beginPath();
      ctx.ellipse(decal.x, decal.y, decal.rx || 28, decal.ry || 18, decal.rotation || 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawRoomBackdrop(){
    const w=CONFIG.roomW, h=CONFIG.roomH;
    const isBoss = dungeon.current.isBoss && !dungeon.current.cleared;
    const variant = dungeon.current.sceneVariant || null;
    const g = ctx.createLinearGradient(0,0,0,h);
    if(variant === 'void'){
      g.addColorStop(0,'#0b1120');
      g.addColorStop(1,'#020617');
    } else if(isBoss){
      g.addColorStop(0,'#1b0f19');
      g.addColorStop(1,'#120913');
    } else {
      g.addColorStop(0,'#10141d');
      g.addColorStop(1,'#0d121a');
    }
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    // 边框
    let borderColor = isBoss ? '#663355' : '#2a3142';
    if(variant === 'void'){ borderColor = '#f97316aa'; }
    ctx.strokeStyle = borderColor; ctx.lineWidth=14; ctx.strokeRect(10,10,w-20,h-20);
    // 裂纹/污渍
    if(variant === 'void'){
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = '#fbbf24';
      for(let i=0;i<26;i++){
        const x = randRange(24, w-24);
        const y = randRange(28, h-28);
        const r = randRange(6, 32);
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#0f172a';
      for(let i=0;i<10;i++){
        ctx.beginPath();
        ctx.ellipse(randRange(40,w-40), randRange(40,h-40), randRange(40,160), randRange(12,42), randRange(0,Math.PI), 0, Math.PI*2);
        ctx.fill();
      }
    } else {
      ctx.globalAlpha = isBoss ? 0.12 : 0.06; ctx.fillStyle=isBoss ? '#ff88b1' : '#bcd';
      for(let i=0;i<22;i++){ const x=randRange(30,w-30), y=randRange(30,h-30), r=randRange(8,38); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
    }
    ctx.globalAlpha = 1;
  }
  function drawDoors(){
    const r = dungeon.current; const doors = roomDoors(r);
    for(const d of doors){
      const ni = r.i + (d.dir==='down') - (d.dir==='up');
      const nj = r.j + (d.dir==='right') - (d.dir==='left');
      const nr = dungeon.rooms[ni]?.[nj];
      const leadsBoss = !!(nr && nr.isBoss && !nr.bossDefeated);
      const leadsItem = !!(nr && nr.isItemRoom && !nr.itemClaimed);
      const locked = !!(nr && nr.locked);
      const doorReady = isRoomReadyForExit(r);
      const doorUnlocked = doorReady && !locked;
      let frame = '#2a3142';
      let fill = '#1e2330';
      if(leadsBoss){
        frame = doorUnlocked ? '#ff6b6b55' : '#2f1b28';
        fill = doorUnlocked ? '#ff6b6b' : '#371822';
      } else if(leadsItem){
        frame = doorUnlocked ? '#facc1555' : '#3a3318';
        fill = doorUnlocked ? '#facc15' : '#3b3414';
      } else if(nr?.isShop){
        frame = doorUnlocked ? '#fbbf2455' : '#3a2f1a';
        fill = doorUnlocked ? '#fbbf24' : '#3b2f18';
      } else if(doorUnlocked){
        frame = '#6ee7ff55';
        fill = '#6ee7ff';
      }
      if(locked){
        frame = '#b4530955';
        fill = '#7c2d12';
      }
      ctx.save();
      // 门框
      ctx.fillStyle = frame;
      ctx.fillRect(d.x-4,d.y-4,d.w+8,d.h+8);
      // 门
      ctx.fillStyle = fill;
      ctx.fillRect(d.x,d.y,d.w,d.h);
      ctx.restore();
    }
  }
  function drawObstacles(){
    const room = dungeon.current;
    ctx.save();
    for(const obs of room.obstacles){
      if(obs.destroyed) continue;
      if(obs.hidden) continue;
      const shadowW = Math.max(6, obs.w * 0.65);
      const shadowH = Math.max(4, obs.h * 0.28);
      ctx.fillStyle = colorWithAlpha('#000000', 0.28);
      ctx.beginPath();
      ctx.ellipse(obs.x + obs.w/2, obs.y + obs.h + 6, shadowW/2, shadowH, 0, 0, Math.PI*2);
      ctx.fill();
      const radius = Math.min(obs.w, obs.h) * 0.22;
      const base = '#2e364b';
      const grad = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y + obs.h);
      grad.addColorStop(0, shadeColor(base, 0.22));
      grad.addColorStop(0.55, base);
      grad.addColorStop(1, shadeColor(base, -0.28));
      ctx.save();
      ctx.beginPath();
      if(typeof ctx.roundRect === 'function') ctx.roundRect(obs.x, obs.y, obs.w, obs.h, radius);
      else ctx.rect(obs.x, obs.y, obs.w, obs.h);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = colorWithAlpha('#05070d', 0.65);
      ctx.stroke();
      ctx.clip();
      const topSheen = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y + obs.h*0.6);
      topSheen.addColorStop(0, colorWithAlpha('#ffffff',0.18));
      topSheen.addColorStop(0.3, colorWithAlpha('#ffffff',0.08));
      topSheen.addColorStop(1, colorWithAlpha('#ffffff',0));
      ctx.fillStyle = topSheen;
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h*0.65);
      const crackColor = colorWithAlpha('#cdd5f6', 0.16);
      ctx.strokeStyle = crackColor;
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(obs.x + obs.w*0.2, obs.y + obs.h*0.35);
      ctx.lineTo(obs.x + obs.w*0.38, obs.y + obs.h*0.48);
      ctx.lineTo(obs.x + obs.w*0.3, obs.y + obs.h*0.65);
      ctx.moveTo(obs.x + obs.w*0.68, obs.y + obs.h*0.22);
      ctx.lineTo(obs.x + obs.w*0.78, obs.y + obs.h*0.42);
      ctx.lineTo(obs.x + obs.w*0.62, obs.y + obs.h*0.58);
      ctx.stroke();
      ctx.strokeStyle = colorWithAlpha('#0b0f18', 0.55);
      ctx.lineWidth = 1.3;
      ctx.beginPath();
      ctx.moveTo(obs.x + obs.w*0.15, obs.y + obs.h*0.82);
      ctx.quadraticCurveTo(obs.x + obs.w*0.32, obs.y + obs.h*0.72, obs.x + obs.w*0.5, obs.y + obs.h*0.86);
      ctx.moveTo(obs.x + obs.w*0.58, obs.y + obs.h*0.78);
      ctx.quadraticCurveTo(obs.x + obs.w*0.74, obs.y + obs.h*0.68, obs.x + obs.w*0.86, obs.y + obs.h*0.82);
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  }
  function drawPickup(p){
    if(p.type==='heart'){
      drawHeartPickup(p);
    } else if((p.type==='bomb' || p.type==='key' || p.type==='coin') && !p.entry){
      drawResourcePickup(p);
    } else if(p.type==='life-trade' && p.item){
      drawLifeTradePickup(p);
    } else if(p.type==='item' && p.item){
      drawItemPickup(p);
    } else if(p.type==='card' && p.card){
      drawCardPickup(p);
    } else if(p.type==='shop'){
      drawShopPickup(p);
    }
  }

  function drawHeartPickup(p){
    const t = performance.now()/360;
    const wobble = Math.sin(t) * 0.08;
    const pulse = 1 + Math.sin(t*2.4) * 0.08;
    const r = (p.r + 2) * pulse;
    const soul = p.kind === 'soul';
    ctx.save();
    ctx.translate(p.x, p.y - 4);
    ctx.rotate(wobble);
    const baseColor = soul ? (p.amount>1 ? '#7dd3fc' : '#60a5fa') : (p.heal>1 ? '#ff95b1' : '#ff7a91');
    const glow = ctx.createRadialGradient(0, -r*0.1, r*0.25, 0, 0, r*1.45);
    glow.addColorStop(0, colorWithAlpha(shadeColor(baseColor, 0.3), soul ? 0.9 : 0.95));
    glow.addColorStop(0.55, colorWithAlpha(baseColor, soul ? 0.32 : 0.28));
    glow.addColorStop(1, colorWithAlpha(baseColor, 0));
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, 0, r*1.25, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    const body = ctx.createLinearGradient(0, -r, 0, r*0.9);
    body.addColorStop(0, shadeColor(baseColor, soul ? 0.15 : 0.22));
    body.addColorStop(0.5, baseColor);
    body.addColorStop(1, shadeColor(baseColor, soul ? -0.15 : -0.2));
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.moveTo(0, r*0.55);
    ctx.bezierCurveTo(r*0.95, -r*0.55, r*1.18, r*0.55, 0, r);
    ctx.bezierCurveTo(-r*1.18, r*0.55, -r*0.95, -r*0.55, 0, r*0.55);
    ctx.fill();
    ctx.strokeStyle = soul ? colorWithAlpha('#e0f2fe', 0.6) : colorWithAlpha('#ffffff', 0.38);
    ctx.lineWidth = 1.4;
    ctx.stroke();
    const highlight = ctx.createRadialGradient(-r*0.35, -r*0.2, r*0.05, -r*0.35, -r*0.2, r*0.45);
    highlight.addColorStop(0, colorWithAlpha('#ffffff', soul ? 0.55 : 0.7));
    highlight.addColorStop(1, colorWithAlpha('#ffffff', 0));
    ctx.fillStyle = highlight;
    ctx.beginPath();
    ctx.ellipse(-r*0.2, -r*0.18, r*0.42, r*0.28, -0.1, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawResourcePickup(p){
    const bob = Math.sin(performance.now()/480)*4;
    ctx.save();
    ctx.translate(p.x, p.y + bob);
    ctx.shadowColor = colorWithAlpha('#6ee7ff',0.45);
    ctx.shadowBlur = 12;
    drawResourceIcon(p.type, p.r);
    ctx.shadowBlur = 0;
    ctx.restore();
    if(p.amount>1){
      ctx.save();
      ctx.fillStyle = '#e0f2fe';
      ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
      ctx.textAlign='center';
      ctx.fillText(`x${p.amount}`, p.x, p.y + 30);
      ctx.restore();
    }
  }

  function drawFollowers(){
    if(!player || !Array.isArray(player.followers) || !player.followers.length) return;
    for(const follower of player.followers){
      if(!follower || typeof follower.draw !== 'function') continue;
      follower.draw(ctx);
    }
  }

  function drawItemPickup(p){
    const bob = Math.sin(performance.now()/480)*4;
    ctx.save();
    ctx.translate(p.x,p.y);
    const aura = ctx.createRadialGradient(0, bob-12, 6, 0, bob-12, p.r*1.8);
    aura.addColorStop(0, colorWithAlpha('#f4f8ff',0.85));
    aura.addColorStop(0.6, colorWithAlpha('#a78bfa',0.28));
    aura.addColorStop(1, colorWithAlpha('#6ee7ff',0));
    ctx.fillStyle = aura;
    ctx.beginPath();
    ctx.arc(0, bob-12, p.r*2.2, 0, Math.PI*2);
    ctx.fill();
    const pedestalTop = ctx.createLinearGradient(-18,6,18,6);
    pedestalTop.addColorStop(0, '#242a3c');
    pedestalTop.addColorStop(0.5, '#3b435c');
    pedestalTop.addColorStop(1, '#242a3c');
    ctx.fillStyle = colorWithAlpha('#0f172a',0.45);
    ctx.beginPath();
    ctx.ellipse(0,20,22,6,0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#23293b';
    ctx.fillRect(-20,12,40,11);
    ctx.fillStyle = pedestalTop;
    ctx.fillRect(-16,6,32,7);
    ctx.translate(0, bob-6);
    ctx.save();
    ctx.shadowColor = colorWithAlpha('#c7d2fe',0.55);
    ctx.shadowBlur = 18;
    drawItemIcon(p.item.slug, p.r);
    ctx.shadowBlur = 0;
    ctx.restore();
    ctx.restore();
    ctx.save();
    ctx.fillStyle = '#e5e9ff';
    ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(p.item.name, p.x, p.y - 32);
    ctx.restore();
  }

  function drawLifeTradePickup(p){
    const bob = Math.sin(performance.now()/520)*4;
    ctx.save();
    ctx.translate(p.x, p.y);
    const base = ctx.createRadialGradient(0, -12, 8, 0, -12, p.r*2.2);
    base.addColorStop(0, colorWithAlpha('#fca5a5', 0.85));
    base.addColorStop(0.6, colorWithAlpha('#f87171', 0.35));
    base.addColorStop(1, colorWithAlpha('#7f1d1d', 0));
    ctx.fillStyle = base;
    ctx.beginPath();
    ctx.arc(0, -12, p.r*2.2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = colorWithAlpha('#111827',0.55);
    ctx.beginPath();
    ctx.ellipse(0, 20, 20, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = colorWithAlpha('#1f2937',0.75);
    ctx.beginPath();
    ctx.ellipse(0, 18, 28, 9, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.save();
    ctx.translate(0, bob-6);
    ctx.shadowColor = colorWithAlpha('#f97316',0.65);
    ctx.shadowBlur = 20;
    drawItemIcon(p.item.slug, p.r*0.95);
    ctx.shadowBlur = 0;
    ctx.restore();
    ctx.restore();
    ctx.save();
    ctx.fillStyle = '#fecaca';
    ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(p.item?.name || '生命交易', p.x, p.y - 36);
    if(p.costLabel){
      ctx.fillStyle = '#fca5a5';
      ctx.fillText(p.costLabel, p.x, p.y - 20);
    }
    ctx.restore();
  }

  function drawCardPickup(p){
    const phase = p.anglePhase || 0;
    const bob = Math.sin(performance.now()/520 + phase)*5;
    const angle = Math.sin(performance.now()/680 + phase)*0.18;
    ctx.save();
    ctx.translate(p.x, p.y + bob - 6);
    const glow = ctx.createRadialGradient(0, -6, 6, 0, -6, p.r*1.9);
    glow.addColorStop(0, colorWithAlpha('#bae6fd',0.65));
    glow.addColorStop(0.7, colorWithAlpha('#60a5fa',0.2));
    glow.addColorStop(1, colorWithAlpha('#60a5fa',0));
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(0, -6, p.r*2, 0, Math.PI*2);
    ctx.fill();
    ctx.rotate(angle);
    ctx.shadowColor = colorWithAlpha('#60a5fa',0.45);
    ctx.shadowBlur = 16;
    drawCardIcon(p.card, p.r*1.1);
    ctx.shadowBlur = 0;
    ctx.restore();
    ctx.save();
    ctx.fillStyle = '#dbeafe';
    ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(p.card?.name || '神秘卡牌', p.x, p.y - 30);
    ctx.restore();
  }

  function drawShopPickup(p){
    const bob = Math.sin(performance.now()/520)*4;
    const near = player ? dist(p, player) < p.r + player.r + 16 : false;
    ctx.save();
    ctx.translate(p.x,p.y);
    const entry = p.entry || {};
    const entryType = entry.type || (p.item ? 'item' : 'resource');
    const baseGlow = ctx.createRadialGradient(0, 10, 6, 0, 10, 36);
    const glowBaseColor = entryType==='item' ? '#fbbf24' : (entryType==='card' ? '#60a5fa' : '#6ee7ff');
    baseGlow.addColorStop(0, colorWithAlpha(glowBaseColor, near ? 0.58 : 0.32));
    baseGlow.addColorStop(1, colorWithAlpha('#111827',0));
    ctx.fillStyle = baseGlow;
    ctx.beginPath();
    ctx.arc(0, 10, 34, 0, Math.PI*2);
    ctx.fill();
    const baseColor = near ? '#363f5c' : '#2a3146';
    const topColor = near ? '#4b5774' : '#39415c';
    ctx.fillStyle = colorWithAlpha('#0f172a',0.45);
    ctx.beginPath();
    ctx.ellipse(0,24,24,7,0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = baseColor;
    ctx.fillRect(-22,14,44,12);
    const topGrad = ctx.createLinearGradient(-16,8,16,8);
    topGrad.addColorStop(0, shadeColor(topColor,-0.08));
    topGrad.addColorStop(0.5, topColor);
    topGrad.addColorStop(1, shadeColor(topColor,-0.08));
    ctx.fillStyle = topGrad;
    ctx.fillRect(-18,8,36,7);
    ctx.translate(0,bob-6);
    let haloColor = glowBaseColor;
    if(entry.type==='resource') haloColor = '#6ee7ff';
    ctx.shadowColor = colorWithAlpha(haloColor, near ? 0.68 : 0.42);
    ctx.shadowBlur = 18;
    if(entry.type==='item' && entry.item){
      drawItemIcon(entry.item.slug, p.r);
    } else if(entry.type==='card' && entry.card){
      drawCardIcon(entry.card, p.r*0.96);
    } else if(entry.type==='resource' && entry.resource){
      drawResourceIcon(entry.resource, p.r*0.95);
    } else if(p.item){
      drawItemIcon(p.item.slug, p.r);
    }
    ctx.shadowBlur = 0;
    ctx.restore();
    let title = '';
    if(entry.type==='item' && entry.item){
      title = entry.item.name;
    } else if(entry.type==='card' && entry.card){
      title = entry.card.name;
    } else if(entry.type==='resource' && entry.resource){
      const label = RESOURCE_LABELS?.[entry.resource] || '资源';
      title = `${label} x${entry.amount ?? 1}`;
    } else if(p.item){
      title = p.item.name;
    } else {
      title = '神秘货物';
    }
    ctx.save();
    ctx.fillStyle = '#e0e7ff';
    ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(title, p.x, p.y - 34);
    const priceDisplay = resolveShopPrice(p, player);
    ctx.fillStyle = near ? '#fde68a' : '#cbd5f5';
    ctx.fillText(`${priceDisplay}🪙`, p.x, p.y - 16);
    ctx.restore();
  }

  function drawItemIcon(id, radius, ctxRef = ctx){
    const g = ctxRef;
    if(!g) return;
    const r = radius;
    if(id==='onion'){
      g.fillStyle = '#facc15';
      g.strokeStyle = '#fff5';
      g.lineWidth = 1.5;
      g.beginPath();
      g.moveTo(0,-r*0.7);
      g.bezierCurveTo(r*0.75,-r*0.3, r*0.55, r*0.45, 0, r*0.85);
      g.bezierCurveTo(-r*0.55, r*0.45, -r*0.75, -r*0.3, 0, -r*0.7);
      g.fill();
      g.stroke();
      g.strokeStyle = '#7c5b0f';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(0,-r*0.9);
      g.lineTo(0,-r*1.2);
      g.stroke();
    } else if(id==='tar'){
      const grad = g.createRadialGradient(0,-2,2,0,0,r*0.75);
      grad.addColorStop(0,'#5f6cff');
      grad.addColorStop(1,'#2d2f59');
      g.fillStyle = grad;
      g.beginPath();
      g.ellipse(0,0,r*0.9,r*0.7,0,0,Math.PI*2);
      g.fill();
    } else if(id==='sneaker'){
      g.fillStyle = '#9ae6b4';
      g.beginPath();
      g.moveTo(-r*0.8, r*0.2);
      g.quadraticCurveTo(-r*0.2, -r*0.7, r*0.8, -r*0.1);
      g.lineTo(r*0.5, r*0.5);
      g.quadraticCurveTo(-r*0.1, r*0.3, -r*0.8, r*0.2);
      g.fill();
      g.fillStyle='#2f855a';
      g.fillRect(-r*0.2, -r*0.1, r*0.8, r*0.15);
    } else if(id==='pepper-steak'){
      g.fillStyle = '#b45309';
      g.beginPath(); g.ellipse(0,0,r*0.95,r*0.65,0,0,Math.PI*2); g.fill();
      g.fillStyle = '#f59e0b';
      g.beginPath(); g.ellipse(0,0,r*0.6,r*0.35,0,0,Math.PI*2); g.fill();
    } else if(id==='rope'){
      g.strokeStyle = '#fde68a';
      g.lineWidth = 4;
      g.beginPath();
      g.moveTo(-r*0.6, -r*0.8);
      g.quadraticCurveTo(0, r*0.4, r*0.6, -r*0.8);
      g.stroke();
    } else if(id==='spirit-date'){
      g.fillStyle = '#92400e';
      g.beginPath(); g.ellipse(0,0,r*0.6,r*0.85,0,0,Math.PI*2); g.fill();
      g.fillStyle='#f97316';
      g.beginPath(); g.arc(0,-r*0.25,r*0.25,0,Math.PI*2); g.fill();
    } else if(id==='betrayal-hound'){
      g.fillStyle='#4c1d95';
      g.beginPath(); g.arc(-r*0.3,-r*0.2,r*0.3,0,Math.PI*2); g.fill();
      g.beginPath(); g.arc(r*0.3,-r*0.2,r*0.3,0,Math.PI*2); g.fill();
      g.fillStyle='#a855f7';
      g.beginPath(); g.arc(0,r*0.2,r*0.5,0,Math.PI*2); g.fill();
    } else if(id==='despair-shout'){
      g.fillStyle='#cbd5f5';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#7c3aed';
      g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.fill();
    } else if(id==='bad-thing'){
      g.fillStyle='#1f2937';
      g.beginPath(); g.arc(0,0,r*0.9,0,Math.PI*2); g.fill();
      g.strokeStyle='#f97316'; g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*0.6,0,Math.PI*2); g.stroke();
    } else if(id==='good-thing'){
      g.fillStyle='#fbcfe8';
      g.beginPath(); g.arc(0,0,r*0.9,0,Math.PI*2); g.fill();
      g.strokeStyle='#f472b6'; g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.stroke();
    } else if(id==='double-gaze'){
      g.save();
      const eyeR = r*0.38;
      const offsets = [-r*0.55, r*0.55];
      for(const ox of offsets){
        const grad = g.createRadialGradient(ox,0,eyeR*0.2, ox,0,eyeR);
        grad.addColorStop(0,'#f8fafc');
        grad.addColorStop(1,'#38bdf8');
        g.fillStyle = grad;
        g.beginPath(); g.arc(ox,0,eyeR,0,Math.PI*2); g.fill();
        g.fillStyle = '#0f172a';
        g.beginPath(); g.arc(ox,0,eyeR*0.45,0,Math.PI*2); g.fill();
        g.fillStyle = '#e0f2fe';
        g.beginPath(); g.arc(ox - eyeR*0.25, -eyeR*0.15, eyeR*0.22, 0, Math.PI*2); g.fill();
      }
      g.strokeStyle = colorWithAlpha('#38bdf8',0.6);
      g.lineWidth = Math.max(1.2, r*0.12);
      g.beginPath(); g.moveTo(-r*0.25, -r*0.45); g.lineTo(r*0.25, -r*0.45); g.stroke();
      g.restore();
    } else if(id==='triple-gaze'){
      g.save();
      const eyeR = r*0.32;
      const centers = [
        {x:0, y:-r*0.42},
        {x:-r*0.55, y:r*0.25},
        {x:r*0.55, y:r*0.25},
      ];
      for(const c of centers){
        const grad = g.createRadialGradient(c.x,c.y,eyeR*0.2,c.x,c.y,eyeR);
        grad.addColorStop(0,'#f8fafc');
        grad.addColorStop(1,'#a855f7');
        g.fillStyle = grad;
        g.beginPath(); g.arc(c.x,c.y,eyeR,0,Math.PI*2); g.fill();
        g.fillStyle = '#1f1036';
        g.beginPath(); g.arc(c.x,c.y,eyeR*0.45,0,Math.PI*2); g.fill();
        g.fillStyle = '#ede9fe';
        g.beginPath(); g.arc(c.x - eyeR*0.2, c.y - eyeR*0.12, eyeR*0.2, 0, Math.PI*2); g.fill();
      }
      g.strokeStyle = colorWithAlpha('#c084fc',0.7);
      g.lineWidth = Math.max(1.1, r*0.1);
      g.beginPath();
      g.moveTo(-r*0.2, -r*0.65);
      g.lineTo(0, -r*0.82);
      g.lineTo(r*0.2, -r*0.65);
      g.stroke();
      g.restore();
    } else if(id==='quad-gaze'){
      g.save();
      const eyeR = r*0.28;
      const centers = [
        {x:-r*0.55, y:-r*0.3},
        {x:r*0.55, y:-r*0.3},
        {x:-r*0.55, y:r*0.3},
        {x:r*0.55, y:r*0.3},
      ];
      for(const c of centers){
        const grad = g.createRadialGradient(c.x,c.y,eyeR*0.18,c.x,c.y,eyeR);
        grad.addColorStop(0,'#fef3c7');
        grad.addColorStop(1,'#f59e0b');
        g.fillStyle = grad;
        g.beginPath(); g.arc(c.x,c.y,eyeR,0,Math.PI*2); g.fill();
        g.fillStyle = '#422006';
        g.beginPath(); g.arc(c.x,c.y,eyeR*0.48,0,Math.PI*2); g.fill();
        g.fillStyle = '#fff7ed';
        g.beginPath(); g.arc(c.x - eyeR*0.18, c.y - eyeR*0.12, eyeR*0.18, 0, Math.PI*2); g.fill();
      }
      g.strokeStyle = colorWithAlpha('#f59e0b',0.7);
      g.lineWidth = Math.max(1.2, r*0.12);
      g.strokeRect(-r*0.7, -r*0.5, r*1.4, r*1.0);
      g.restore();
    } else if(id==='blood-power'){
      g.fillStyle='#ef4444';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#fee2e2';
      g.beginPath(); g.arc(0,0,r*0.4,0,Math.PI*2); g.fill();
    } else if(id==='money-power'){
      g.fillStyle='#fbbf24';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#fde68a';
      g.beginPath(); g.arc(0,0,r*0.4,0,Math.PI*2); g.fill();
    } else if(id==='despair-power'){
      g.fillStyle='#1f2937';
      g.beginPath(); g.arc(0,0,r*0.9,0,Math.PI*2); g.fill();
      g.fillStyle='#f9a8d4';
      g.beginPath(); g.arc(0,0,r*0.35,0,Math.PI*2); g.fill();
    } else if(id==='outdoor-pouch'){
      g.fillStyle='#4b5563';
      g.beginPath(); g.roundRect?.(-r*0.7,-r*0.5,r*1.4,r*1.0,r*0.25);
      if(!g.roundRect){ g.fillRect(-r*0.7,-r*0.5,r*1.4,r*1.0); }
      else { g.fill(); }
      if(!g.roundRect){ g.fillStyle='#6b7280'; g.fillRect(-r*0.7,-r*0.1,r*1.4,r*0.25); }
      else {
        g.fillStyle='#6b7280';
        g.beginPath(); g.roundRect(-r*0.7,-r*0.1,r*1.4,r*0.25,r*0.12); g.fill();
      }
      g.strokeStyle='#9ca3af';
      g.lineWidth=2;
      g.beginPath(); g.arc(0,-r*0.65,r*0.55,Math.PI,0); g.stroke();
      g.fillStyle='#facc15';
      g.beginPath(); g.arc(-r*0.3,0,r*0.18,0,Math.PI*2); g.fill();
      g.fillStyle='#f97316';
      g.beginPath(); g.arc(r*0.25,0,r*0.2,0,Math.PI*2); g.fill();
    } else if(id==='adrenaline'){
      g.save();
      g.rotate(-Math.PI/6);
      g.fillStyle='#f87171';
      g.fillRect(-r*0.4,-r*0.1,r*0.8,r*0.2);
      g.fillStyle='#fef3c7';
      g.fillRect(-r*0.4,-r*0.38,r*0.8,r*0.28);
      g.fillStyle='#ef4444';
      g.fillRect(r*0.1,-r*0.1,r*0.28,r*0.2);
      g.restore();
      g.fillStyle='#f97316';
      g.beginPath(); g.arc(0,r*0.35,r*0.22,0,Math.PI*2); g.fill();
    } else if(id==='bomb-cousin'){
      g.fillStyle='#1f2937';
      g.beginPath(); g.arc(0,0,r*0.75,0,Math.PI*2); g.fill();
      g.fillStyle='#f87171';
      g.beginPath(); g.arc(0,0,r*0.45,0,Math.PI*2); g.fill();
      g.strokeStyle='#fde68a';
      g.lineWidth=2;
      g.beginPath(); g.moveTo(-r*0.3,-r*0.3); g.lineTo(-r*0.1,-r*0.5); g.lineTo(r*0.3,-r*0.3); g.stroke();
      g.fillStyle='#fde68a';
      g.font = `${Math.round(r*0.7)}px sans-serif`;
      g.textAlign='center';
      g.fillText('+',0,r*0.3);
    } else if(id==='bomb-uncle'){
      g.fillStyle='#111827';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#ef4444';
      g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.fill();
      g.strokeStyle='#facc15';
      g.lineWidth=3;
      g.beginPath(); g.arc(0,0,r*0.95,0,Math.PI*2); g.stroke();
      g.globalAlpha=0.7;
      g.strokeStyle='#fde68a';
      g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*1.15,0,Math.PI*2); g.stroke();
      g.globalAlpha=1;
    } else if(id==='bomb-grandpa'){
      g.fillStyle='#1f2937';
      g.beginPath(); g.arc(0,0,r*0.6,0,Math.PI*2); g.fill();
      g.strokeStyle='#34d399';
      g.lineWidth=3;
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.stroke();
      g.strokeStyle='#bbf7d0';
      g.lineWidth=1.5;
      g.beginPath(); g.arc(0,0,r*0.95,0,Math.PI*2); g.stroke();
      g.fillStyle='#34d399';
      g.beginPath(); g.arc(0,r*0.05,r*0.18,0,Math.PI*2); g.fill();
    } else if(id==='bomb-elder'){
      g.fillStyle='#111827';
      g.beginPath(); g.arc(0,0,r*0.8,0,Math.PI*2); g.fill();
      g.strokeStyle='#facc15';
      g.lineWidth=2.5;
      g.beginPath(); g.arc(0,0,r*0.92,0,Math.PI*2); g.stroke();
      g.fillStyle='#f97316';
      g.beginPath(); g.arc(0,0,r*0.48,0,Math.PI*2); g.fill();
      g.fillStyle='#fde68a';
      g.beginPath();
      g.moveTo(-r*0.22, -r*0.85);
      g.quadraticCurveTo(0, -r*1.2, r*0.22, -r*0.85);
      g.lineTo(0, -r*0.45);
      g.closePath();
      g.fill();
      g.fillStyle='#fbbf24';
      g.beginPath(); g.arc(-r*0.32, -r*0.2, r*0.12, 0, Math.PI*2); g.fill();
      g.beginPath(); g.arc(r*0.28, -r*0.15, r*0.1, 0, Math.PI*2); g.fill();
    } else if(id==='bomb-progenitor'){
      g.strokeStyle='#fde68a';
      g.lineWidth=2.5;
      g.beginPath(); g.arc(0,0,r*0.88,0,Math.PI*2); g.stroke();
      g.strokeStyle='#fb923c';
      g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*0.6,0,Math.PI*2); g.stroke();
      g.strokeStyle='#f97316';
      g.lineWidth=2;
      g.beginPath(); g.moveTo(-r*0.88,0); g.lineTo(r*0.88,0); g.stroke();
      g.beginPath(); g.moveTo(0,-r*0.88); g.lineTo(0,r*0.88); g.stroke();
      g.fillStyle='#fb923c';
      g.beginPath(); g.arc(0,0,r*0.18,0,Math.PI*2); g.fill();
      g.fillStyle='#fef3c7';
      g.beginPath(); g.arc(0,0,r*0.08,0,Math.PI*2); g.fill();
    } else if(id==='brother'){
      g.fillStyle = '#fde68a';
      g.beginPath(); g.arc(-r*0.35,0,r*0.35,0,Math.PI*2); g.fill();
      g.beginPath(); g.arc(r*0.35,0,r*0.35,0,Math.PI*2); g.fill();
      g.fillStyle = '#f97316';
      g.fillRect(-r*0.45,-r*0.15,r*0.9,r*0.3);
    } else if(id==='sister'){
      g.fillStyle = '#fda4af';
      g.beginPath(); g.arc(-r*0.45,0,r*0.3,0,Math.PI*2); g.fill();
      g.fillStyle = '#bfdbfe';
      g.beginPath(); g.arc(r*0.45,0,r*0.3,0,Math.PI*2); g.fill();
      g.strokeStyle = '#fef3c7';
      g.lineWidth = 2;
      g.beginPath(); g.moveTo(-r*0.15,-r*0.35); g.lineTo(r*0.15,-r*0.35); g.stroke();
    } else if(id==='cousin' || id==='younger-cousin'){
      const baseColor = id==='cousin' ? '#93c5fd' : '#86efac';
      g.fillStyle = baseColor;
      g.beginPath(); g.arc(0,0,r*0.5,0,Math.PI*2); g.fill();
      g.strokeStyle = shadeColor(baseColor,-0.2);
      g.lineWidth = 2;
      g.beginPath(); g.arc(0,0,r*0.65,0,Math.PI*2); g.stroke();
      g.fillStyle = '#0f172a';
      g.beginPath(); g.arc(0,0,r*0.2,0,Math.PI*2); g.fill();
    } else if(id==='aunt-brimstone'){
      const grad = g.createLinearGradient(-r,r,r,-r);
      grad.addColorStop(0,'#fee2e2');
      grad.addColorStop(1,'#f87171');
      g.fillStyle = grad;
      g.beginPath(); g.roundRect?.(-r*0.4,-r*0.8,r*0.8,r*1.6,r*0.2);
      if(!g.roundRect){ g.fillRect(-r*0.4,-r*0.8,r*0.8,r*1.6); }
      else { g.fill(); }
      g.fillStyle = '#7f1d1d';
      g.fillRect(-r*0.18,-r*0.75,r*0.36,r*1.5);
    } else if(id==='black-buddy'){
      g.fillStyle = '#111827';
      g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.fill();
      g.strokeStyle = '#fbbf24';
      g.lineWidth = 2;
      g.beginPath(); g.arc(0,0,r*0.7,0,Math.PI*2); g.stroke();
      g.fillStyle = '#f97316';
      g.beginPath(); g.arc(0,r*0.2,r*0.2,0,Math.PI*2); g.fill();
    } else if(id==='brimstone'){
      g.save();
      const glow = g.createRadialGradient(0,0,r*0.15,0,0,r*0.9);
      glow.addColorStop(0, '#f97316');
      glow.addColorStop(0.5, '#ef4444');
      glow.addColorStop(1, '#7f1d1d');
      g.fillStyle = glow;
      g.beginPath();
      g.arc(0,0,r*0.92,0,Math.PI*2);
      g.fill();
      g.strokeStyle = colorWithAlpha('#fee2e2',0.85);
      g.lineWidth = Math.max(2, r*0.22);
      g.beginPath();
      g.moveTo(-r*0.7,0);
      g.lineTo(r*0.7,0);
      g.stroke();
      g.strokeStyle = colorWithAlpha('#fecaca',0.7);
      g.lineWidth = Math.max(1.5, r*0.16);
      g.beginPath();
      g.moveTo(-r*0.58,-r*0.28);
      g.lineTo(r*0.58,-r*0.28);
      g.stroke();
      g.beginPath();
      g.moveTo(-r*0.58,r*0.28);
      g.lineTo(r*0.58,r*0.28);
      g.stroke();
      g.restore();
    } else if(id==='abaddon'){
      g.save();
      g.fillStyle = '#111827';
      g.beginPath();
      g.arc(0,0,r*0.8,0,Math.PI*2);
      g.fill();
      g.fillStyle = '#f87171';
      g.beginPath();
      g.arc(-r*0.28,-r*0.05,r*0.18,0,Math.PI*2);
      g.fill();
      g.beginPath();
      g.arc(r*0.28,-r*0.05,r*0.18,0,Math.PI*2);
      g.fill();
      g.fillStyle = '#facc15';
      g.beginPath();
      g.moveTo(-r*0.45,-r*0.55);
      g.lineTo(-r*0.2,-r*1.0);
      g.lineTo(-r*0.05,-r*0.45);
      g.closePath();
      g.fill();
      g.beginPath();
      g.moveTo(r*0.45,-r*0.55);
      g.lineTo(r*0.2,-r*1.0);
      g.lineTo(r*0.05,-r*0.45);
      g.closePath();
      g.fill();
      g.fillStyle = '#1f2937';
      g.beginPath();
      g.arc(0, r*0.25, r*0.28, 0, Math.PI);
      g.fill();
      g.strokeStyle = colorWithAlpha('#fcd34d',0.7);
      g.lineWidth = Math.max(1.5, r*0.12);
      g.beginPath();
      g.arc(0,0,r*0.82,Math.PI*0.25,Math.PI*0.75);
      g.stroke();
      g.restore();
    } else if(id==='escape-tool'){
      g.save();
      const body = g.createLinearGradient(-r, -r, r, r);
      body.addColorStop(0, '#38bdf8');
      body.addColorStop(1, '#34d399');
      g.fillStyle = body;
      g.beginPath();
      g.moveTo(-r*0.75, r*0.5);
      g.lineTo(-r*0.25, -r*0.65);
      g.lineTo(r*0.5, -r*0.35);
      g.lineTo(r*0.2, r*0.75);
      g.closePath();
      g.fill();
      g.strokeStyle = '#ecfeff';
      g.lineWidth = Math.max(1.4, r*0.12);
      g.beginPath();
      g.moveTo(-r*0.5, r*0.45);
      g.lineTo(r*0.35, -r*0.25);
      g.stroke();
      g.fillStyle = '#e0f2fe';
      g.beginPath();
      g.arc(r*0.45, -r*0.45, r*0.2, 0, Math.PI*2);
      g.fill();
      g.strokeStyle = '#bae6fd';
      g.lineWidth = Math.max(1, r*0.08);
      g.beginPath();
      g.moveTo(r*0.45, -r*0.65);
      g.lineTo(r*0.65, -r*0.4);
      g.lineTo(r*0.35, -r*0.2);
      g.stroke();
      g.restore();
    } else if(id==='holy-heart'){
      g.save();
      const glow = g.createRadialGradient(0,0,r*0.25,0,0,r*1.05);
      glow.addColorStop(0,colorWithAlpha('#fef3c7',0.95));
      glow.addColorStop(1,colorWithAlpha('#fde68a',0));
      g.fillStyle = glow;
      g.beginPath(); g.arc(0,0,r*1.05,0,Math.PI*2); g.fill();
      g.globalAlpha = 1;
      g.fillStyle = '#fcd34d';
      g.beginPath();
      g.moveTo(0, r*0.7);
      g.bezierCurveTo(r*0.95, r*0.1, r*0.7, -r*0.95, 0, -r*0.35);
      g.bezierCurveTo(-r*0.7, -r*0.95, -r*0.95, r*0.1, 0, r*0.7);
      g.closePath();
      g.fill();
      g.strokeStyle = '#fbbf24';
      g.lineWidth = Math.max(2, r*0.16);
      g.stroke();
      g.strokeStyle = colorWithAlpha('#fef3c7',0.9);
      g.lineWidth = Math.max(1.2, r*0.12);
      g.beginPath();
      g.moveTo(-r*0.1, -r*0.6);
      g.lineTo(-r*0.1, -r*1.05);
      g.moveTo(-r*0.45, -r*0.85);
      g.lineTo(-r*0.1, -r*0.6);
      g.moveTo(r*0.1, -r*0.6);
      g.lineTo(r*0.45, -r*0.85);
      g.moveTo(r*0.1, -r*0.6);
      g.lineTo(r*0.1, -r*1.05);
      g.stroke();
      g.restore();
    } else if(id==='magic-bullet'){
      g.fillStyle='#a855f7';
      g.beginPath(); g.arc(0,0,r*0.75,0,Math.PI*2); g.fill();
      g.fillStyle='#c4b5fd';
      g.beginPath(); g.arc(-r*0.15,-r*0.1,r*0.3,0,Math.PI*2); g.fill();
      g.strokeStyle='#f9a8d4';
      g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*0.9,Math.PI*0.2,Math.PI*1.6); g.stroke();
      g.strokeStyle='#f472b6';
      g.beginPath(); g.moveTo(r*0.4,0); g.quadraticCurveTo(r*0.7,r*0.4,r*0.2,r*0.7); g.stroke();
    } else if(id==='seer-map'){
      g.fillStyle='#0f172a';
      g.fillRect(-r*0.9,-r*0.7,r*1.8,r*1.4);
      g.strokeStyle='#38bdf8';
      g.lineWidth=2.5;
      g.strokeRect(-r*0.85,-r*0.65,r*1.7,r*1.3);
      g.strokeStyle='#94a3b8';
      g.lineWidth=1.2;
      g.beginPath();
      g.moveTo(-r*0.85,0);
      g.lineTo(r*0.85,0);
      g.moveTo(0,-r*0.65);
      g.lineTo(0,r*0.65);
      g.moveTo(-r*0.4,-r*0.65);
      g.lineTo(-r*0.2,r*0.65);
      g.moveTo(r*0.4,-r*0.65);
      g.lineTo(r*0.2,r*0.65);
      g.stroke();
      g.fillStyle='#facc15';
      g.beginPath(); g.arc(r*0.35,-r*0.25,r*0.18,0,Math.PI*2); g.fill();
      g.fillStyle='#fb7185';
      g.beginPath(); g.arc(-r*0.45,r*0.25,r*0.16,0,Math.PI*2); g.fill();
    } else if(id==='dog-food'){
      g.fillStyle='#92400e';
      g.fillRect(-r*0.7,-r*0.5,r*1.4,r*0.9);
      g.fillStyle='#fde68a';
      g.fillRect(-r*0.7,-r*0.9,r*1.4,r*0.4);
    } else if(id==='ending-note'){
      g.fillStyle='#f8fafc';
      g.fillRect(-r*0.5,-r*0.8,r,r*1.4);
      g.fillStyle='#6366f1';
      g.fillRect(-r*0.5,-r*0.2,r,r*0.12);
    } else if(id==='kettle'){
      g.fillStyle='#94a3b8';
      g.beginPath(); g.arc(0,0,r*0.75,0,Math.PI*2); g.fill();
      g.fillRect(-r*0.2,-r*0.95,r*0.4,r*0.4);
    } else {
      g.fillStyle = '#b0c9ff';
      g.beginPath();
      g.arc(0,0,r*0.8,0,Math.PI*2);
      g.fill();
    }
  }

  function drawCardIcon(card, radius, ctxRef = ctx){
    const g = ctxRef;
    if(!g) return;
    const r = Math.max(8, radius || 12);
    const w = r * 1.4;
    const h = r * 1.9;
    g.save();
    g.fillStyle = '#1f2536';
    g.strokeStyle = '#60a5fa';
    g.lineWidth = Math.max(1.6, r * 0.16);
    g.beginPath();
    g.moveTo(-w/2, -h/2);
    g.lineTo(w/2, -h/2);
    g.lineTo(w/2, h/2);
    g.lineTo(-w/2, h/2);
    g.closePath();
    g.fill();
    g.stroke();
    g.fillStyle = '#bae6fd';
    g.font = `${Math.max(12, r*0.85)}px "HYWenHei", "PingFang SC", sans-serif`;
    g.textAlign='center';
    g.textBaseline='middle';
    const label = card?.name ? card.name.charAt(0) : '卡';
    g.fillText(label, 0, -h*0.18);
    g.fillStyle = '#38bdf8';
    g.font = `${Math.max(10, r*0.6)}px "HYWenHei", "PingFang SC", sans-serif`;
    g.fillText('Q', 0, h*0.28);
    g.restore();
  }

  function drawResourceIcon(type, radius){
    const r = radius;
    ctx.save();
    if(type==='bomb'){
      const shell = ctx.createRadialGradient(-r*0.3,-r*0.3,r*0.15,0,0,r*0.95);
      shell.addColorStop(0, '#4b5563');
      shell.addColorStop(0.5, '#1f2937');
      shell.addColorStop(1, '#0f172a');
      ctx.fillStyle = shell;
      ctx.beginPath();
      ctx.arc(0,0,r*0.92,0,Math.PI*2);
      ctx.fill();
      ctx.lineWidth = Math.max(1.2, r*0.12);
      ctx.strokeStyle = colorWithAlpha('#0b0f18',0.85);
      ctx.stroke();
      const glow = ctx.createRadialGradient(-r*0.35,-r*0.4,r*0.1,0,0,r*0.7);
      glow.addColorStop(0, colorWithAlpha('#ff8a8a',0.65));
      glow.addColorStop(1, colorWithAlpha('#ff6b6b',0));
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0,0,r*0.65,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = colorWithAlpha('#ffffff',0.18);
      ctx.lineWidth = Math.max(1, r*0.08);
      ctx.beginPath();
      ctx.arc(0,0,r*0.62,0,Math.PI*2);
      ctx.stroke();
      ctx.strokeStyle = '#fca5a5';
      ctx.lineWidth = Math.max(1.2, r*0.1);
      ctx.beginPath();
      ctx.moveTo(0,-r*0.95);
      ctx.lineTo(0,-r*1.25);
      ctx.stroke();
      ctx.fillStyle = '#fde68a';
      ctx.beginPath();
      ctx.arc(0,-r*1.32,r*0.18,0,Math.PI*2);
      ctx.fill();
    } else if(type==='key'){
      const ringGrad = ctx.createLinearGradient(-r, -r, r, r);
      ringGrad.addColorStop(0, '#fde68a');
      ringGrad.addColorStop(0.5, '#facc15');
      ringGrad.addColorStop(1, '#d97706');
      ctx.fillStyle = ringGrad;
      ctx.beginPath();
      ctx.arc(-r*0.25,0,r*0.55,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = colorWithAlpha('#1f2937',0.45);
      ctx.beginPath();
      ctx.arc(-r*0.25,0,r*0.34,0,Math.PI*2);
      ctx.fill();
      const shaftGrad = ctx.createLinearGradient(-r*0.1, -r*0.15, r*1.2, r*0.25);
      shaftGrad.addColorStop(0, '#fde68a');
      shaftGrad.addColorStop(1, '#b45309');
      ctx.fillStyle = shaftGrad;
      ctx.beginPath();
      ctx.roundRect?.(-r*0.1,-r*0.18,r*1.25,r*0.36,r*0.18);
      if(typeof ctx.roundRect !== 'function') ctx.fillRect(-r*0.1,-r*0.18,r*1.25,r*0.36);
      else ctx.fill();
      ctx.fillStyle = shadeColor('#b45309', -0.1);
      ctx.fillRect(r*0.68,-r*0.18,r*0.18,r*0.36);
      ctx.fillRect(r*0.9,-r*0.18,r*0.18,r*0.36);
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(-r*0.25,0,r*0.2,0,Math.PI*2);
      ctx.fill();
    } else if(type==='coin'){
      const coin = ctx.createRadialGradient(-r*0.25,-r*0.35,r*0.18,0,0,r*0.95);
      coin.addColorStop(0, '#fff7cc');
      coin.addColorStop(0.4, '#facc15');
      coin.addColorStop(1, '#d97706');
      ctx.fillStyle = coin;
      ctx.beginPath();
      ctx.ellipse(0,0,r*0.95,r*0.82,0,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = colorWithAlpha('#7c2d12',0.6);
      ctx.lineWidth = Math.max(1.1, r*0.1);
      ctx.stroke();
      const rim = ctx.createLinearGradient(-r,0,r,0);
      rim.addColorStop(0, colorWithAlpha('#fde68a',0.65));
      rim.addColorStop(0.5, colorWithAlpha('#fff8dc',0.35));
      rim.addColorStop(1, colorWithAlpha('#fde68a',0.65));
      ctx.fillStyle = rim;
      ctx.beginPath();
      ctx.ellipse(0,0,r*0.72,r*0.62,0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = colorWithAlpha('#7c2d12',0.7);
      ctx.fillRect(-r*0.18,-r*0.7,r*0.36,r*1.4);
      ctx.fillStyle = colorWithAlpha('#fef3c7',0.8);
      ctx.fillRect(-r*0.08,-r*0.68,r*0.16,r*1.36);
    }
    ctx.restore();
  }
  function drawPlayer(){
    // 身体
    let baseColor = '#e1e7ff';
    let edgeColor = '#a78bfa';
    const dashState = player.impactDash;
    const dashActive = typeof player.isImpactDashing === 'function' ? player.isImpactDashing() : false;
    const dashInvulnRemaining = typeof player.getImpactDashInvulnTime === 'function'
      ? player.getImpactDashInvulnTime()
      : Math.max(0, dashState?.invulnTimer ?? 0);
    const dashInvulnTotal = dashState?.invulnTotal ?? 0;
    let dashInvulnRatio = 0;
    if(typeof player.getImpactDashInvulnRatio === 'function'){
      dashInvulnRatio = player.getImpactDashInvulnRatio();
    } else if(dashActive){
      dashInvulnRatio = 1;
    } else if(dashInvulnRemaining>0 && dashInvulnTotal>0){
      dashInvulnRatio = clamp(dashInvulnRemaining / dashInvulnTotal, 0, 1);
    }
    dashInvulnRatio = clamp(dashInvulnRatio, 0, 1);
    const dashInvulnActive = dashActive || dashInvulnRemaining>0;
    const dashFlashThreshold = typeof player.getImpactDashFlashThreshold === 'function'
      ? player.getImpactDashFlashThreshold()
      : Math.max(0, dashState?.flashThreshold ?? 0.25);
    if(player.attackMode === 'brimstone'){
      const ratio = typeof player.getBrimstoneChargeRatio === 'function' ? player.getBrimstoneChargeRatio() : 0;
      if(player.brimstoneBeam || player.brimstoneFiring){
        baseColor = '#f87171';
        edgeColor = '#b91c1c';
      } else if(player.brimstoneCharged){
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const wave = (Math.sin(now / 90) + 1) / 2; // 0~1 红色闪动节奏
        const eased = Math.pow(wave, 1.2);
        baseColor = mixHexColor('#fca5a5', '#f87171', eased);
        edgeColor = mixHexColor('#dc2626', '#7f1d1d', eased);
      } else if(ratio>0){
        baseColor = mixHexColor('#e1e7ff', '#fca5a5', ratio);
        edgeColor = mixHexColor('#a78bfa', '#ef4444', ratio);
      }
    }
    if(dashInvulnActive){
      const bodyMix = dashActive ? 0.85 : (0.45 + 0.4 * dashInvulnRatio);
      const edgeMix = dashActive ? 0.85 : (0.35 + 0.35 * dashInvulnRatio);
      baseColor = mixHexColor(baseColor, '#38bdf8', clamp(bodyMix, 0, 1));
      edgeColor = mixHexColor(edgeColor, '#0ea5e9', clamp(edgeMix, 0, 1));
    } else if(dashState?.unlocked){
      const ready = (dashState.cooldown ?? 0) <= 0;
      const pulseHint = Math.max(0, Math.min(1, dashState.readyPulse ?? 0));
      if(ready || pulseHint>0){
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const wave = (Math.sin(now / 200) + 1) / 2;
        const strength = clamp(0.22 + wave * 0.18 + pulseHint * 0.45, 0, 0.75);
        baseColor = mixHexColor(baseColor, '#bae6fd', strength);
        edgeColor = mixHexColor(edgeColor, '#38bdf8', strength);
      }
    }
    drawEntityShadow(player);
    ctx.save();
    if(player.ifr>0){
      const phase = Math.floor((performance.now()/70)) % 2;
      const alpha = phase===0 ? 1 : 0.25;
      ctx.globalAlpha *= alpha;
    }
    if(dashInvulnActive && !dashActive){
      const flashThreshold = Math.max(0.05, dashFlashThreshold);
      if(dashInvulnRemaining>0 && dashInvulnRemaining <= flashThreshold){
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        const blink = Math.sin(now / 80);
        const alpha = blink > 0 ? 1 : 0.25;
        ctx.globalAlpha *= alpha;
      }
    }
    drawBlob(player.x, player.y, player.r, baseColor, edgeColor);
    if(dashInvulnActive){
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const wave = (Math.sin(now / 140) + 1) / 2;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      if(dashActive){
        const glowRadius = player.r * (1.6 + wave * 0.35);
        ctx.globalAlpha *= 0.55 + wave * 0.25;
        const glow = ctx.createRadialGradient(player.x, player.y, glowRadius * 0.25, player.x, player.y, glowRadius);
        glow.addColorStop(0, colorWithAlpha('#e0f2fe', 0.9));
        glow.addColorStop(0.55, colorWithAlpha('#38bdf8', 0.35));
        glow.addColorStop(1, colorWithAlpha('#0ea5e9', 0));
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(player.x, player.y, glowRadius, 0, Math.PI*2);
        ctx.fill();
      } else {
        const ratio = dashInvulnRatio;
        const glowRadius = player.r * (1.35 + ratio * 0.35 + wave * 0.2);
        const alphaBase = clamp(0.28 + ratio * 0.32 + wave * 0.15, 0.18, 0.8);
        ctx.globalAlpha *= alphaBase;
        const glow = ctx.createRadialGradient(player.x, player.y, glowRadius * 0.25, player.x, player.y, glowRadius);
        const ease = 0.6 + 0.4 * ratio;
        glow.addColorStop(0, colorWithAlpha('#e0f2fe', 0.75 * ease));
        glow.addColorStop(0.55, colorWithAlpha('#38bdf8', 0.4 * ease));
        glow.addColorStop(1, colorWithAlpha('#0ea5e9', 0));
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(player.x, player.y, glowRadius, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    } else if(dashState?.unlocked && (dashState.cooldown ?? 0) <= 0){
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const wave = (Math.sin(now / 220) + 1) / 2;
      const haloRadius = player.r * (1.2 + wave * 0.25);
      ctx.save();
      ctx.globalAlpha *= 0.35 + wave * 0.2;
      const halo = ctx.createRadialGradient(player.x, player.y, haloRadius * 0.3, player.x, player.y, haloRadius);
      halo.addColorStop(0, colorWithAlpha('#bae6fd', 0.6));
      halo.addColorStop(1, colorWithAlpha('#38bdf8', 0));
      ctx.fillStyle = halo;
      ctx.beginPath();
      ctx.arc(player.x, player.y, haloRadius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    if(player.attackMode === 'brimstone' && player.brimstoneCharged && !player.brimstoneBeam && !player.brimstoneFiring){
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const wave = (Math.sin(now / 90) + 1) / 2;
      const flashAlpha = 0.3 + wave * 0.5;
      const flashRadius = player.r * (1.15 + wave * 0.4);
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha *= flashAlpha;
      const flash = ctx.createRadialGradient(player.x, player.y, flashRadius * 0.25, player.x, player.y, flashRadius);
      flash.addColorStop(0, colorWithAlpha('#fca5a5', 0.95));
      flash.addColorStop(0.6, colorWithAlpha('#f97316', 0.35));
      flash.addColorStop(1, colorWithAlpha('#7f1d1d', 0));
      ctx.fillStyle = flash;
      ctx.beginPath();
      ctx.arc(player.x, player.y, flashRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    if(player.attackMode === 'brimstone' && (player.brimstoneBeam || player.brimstoneCharged)){
      const pulse = player.brimstoneBeam ? 1 : clamp(player.getBrimstoneChargeRatio?.() ?? 0, 0, 1);
      const radius = player.r * (1.25 + pulse * 0.35);
      ctx.save();
      const haloAlpha = ctx.globalAlpha * (0.35 + pulse * 0.25);
      ctx.globalAlpha = haloAlpha;
      const halo = ctx.createRadialGradient(player.x, player.y, radius*0.35, player.x, player.y, radius);
      halo.addColorStop(0, colorWithAlpha('#fca5a5', 0.9));
      halo.addColorStop(1, colorWithAlpha('#b91c1c', 0));
      ctx.fillStyle = halo;
      ctx.beginPath();
      ctx.arc(player.x, player.y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  }
  function drawMiniMap(){
    const cell=12, pad=8, left=16, top=16;
    const discovered=[];
    for(let i=0;i<dungeon.gridN;i++){
      for(let j=0;j<dungeon.gridN;j++){
        const r = dungeon.rooms[i][j];
        if(r?.discovered) discovered.push(r);
      }
    }
    if(!discovered.length) return;
    const width = (dungeon.bounds.maxJ - dungeon.bounds.minJ + 1) * cell;
    const height = (dungeon.bounds.maxI - dungeon.bounds.minI + 1) * cell;
    ctx.save();
    ctx.translate(left, top);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = '#141a25';
    ctx.fillRect(-pad,-pad,width+pad*2,height+pad*2);
    for(const r of discovered){
      const x = (r.j - dungeon.bounds.minJ) * cell;
      const y = (r.i - dungeon.bounds.minI) * cell;
      if(r===dungeon.current){ ctx.fillStyle='#6ee7ff'; }
      else if(r.isBoss && !r.bossDefeated){ ctx.fillStyle='#ff6b6b'; }
      else if(r.isItemRoom && !r.itemClaimed){ ctx.fillStyle='#facc15'; }
      else if(r.isShop){ ctx.fillStyle='#fbbf24'; }
      else { ctx.fillStyle='#2c3a54'; }
      ctx.fillRect(x,y,cell-1,cell-1);
    }
    ctx.restore();
    if(runtime.bossIntroTimer>0){ drawBossIntro(); }
  }

  function drawBossHealth(){
    const room = dungeon.current;
    const boss = room.isBoss ? room.bossEntity : null;
    if(!boss || boss.dead) return;
    const ratio = Math.max(0, boss.hp / boss.maxHp);
    const barW = 360, barH = 16;
    const x = CONFIG.roomW/2 - barW/2;
    const y = 52;
    ctx.save();
    ctx.fillStyle = '#0b0912aa';
    ctx.fillRect(x-6,y-10,barW+12,barH+24);
    ctx.fillStyle = '#24152e';
    ctx.fillRect(x,y,barW,barH);
    const grad = ctx.createLinearGradient(x,0,x+barW,0);
    grad.addColorStop(0,'#ff6b9a');
    grad.addColorStop(1,'#f472b6');
    ctx.fillStyle = grad;
    ctx.fillRect(x,y,barW*ratio,barH);
    ctx.strokeStyle='#fff3'; ctx.strokeRect(x,y,barW,barH);
    ctx.fillStyle='#ffcfdf';
    ctx.font='16px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(boss.name, CONFIG.roomW/2, y-12);
    ctx.restore();
  }

  function drawBossIntro(){
    const alpha = Math.min(1, runtime.bossIntroTimer / 1.2);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle='#0b0912aa';
    ctx.fillRect(0, CONFIG.roomH/2 - 60, CONFIG.roomW, 120);
    ctx.fillStyle='#ffb4c8';
    ctx.font='38px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(runtime.bossIntroText, CONFIG.roomW/2, CONFIG.roomH/2 - 6);
    ctx.fillStyle='#ffd6e6';
    ctx.font='18px "HYWenHei", "PingFang SC", sans-serif';
    ctx.fillText('地窖打工仔：又是背锅的加班日。', CONFIG.roomW/2, CONFIG.roomH/2 + 28);
    ctx.restore();
  }

  function drawItemPickupBanner(){
    if(runtime.itemPickupTimer<=0 || !runtime.itemPickupName) return;
    const baseText = `${runtime.itemPickupName}`;
    const desc = runtime.itemPickupDesc;
    ctx.save();
    const lifeRatio = Math.min(1, runtime.itemPickupTimer / 1.2);
    ctx.globalAlpha = 0.85 + 0.15*lifeRatio;
    ctx.textAlign='center';
    const mainFont='20px "HYWenHei", "PingFang SC", sans-serif';
    const subFont='14px "HYWenHei", "PingFang SC", sans-serif';
    ctx.font = mainFont;
    const mainWidth = ctx.measureText(baseText).width;
    ctx.font = subFont;
    const subWidth = desc ? ctx.measureText(desc).width : 0;
    const paddingX = 22;
    const w = Math.max(mainWidth, subWidth) + paddingX*2;
    const h = desc ? 70 : 50;
    const x = CONFIG.roomW/2 - w/2;
    const y = CONFIG.roomH - h - 36;
    ctx.fillStyle = '#0b101dcc';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = '#2f3755';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1, y+1, w-2, h-2);
    ctx.font = mainFont;
    ctx.fillStyle = '#facc15';
    ctx.fillText(baseText, CONFIG.roomW/2, y + 28);
    if(desc){
      ctx.font = subFont;
      ctx.fillStyle = '#d6dcff';
      ctx.fillText(desc, CONFIG.roomW/2, y + 52);
    }
    ctx.restore();
  }

  class EnemyProjectile{
    constructor(x,y,vx,vy,life,type){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.alive=true; this.r= type==='needle'?6:(type==='spark'?5:7);
      this.type=type;
      if(type==='needle') this.color='#f973a6';
      else if(type==='spark') this.color='#fbbf24';
      else this.color='#ff7aa9';
    }
    destroy(options={}){
      if(!this.alive) return;
      this.alive=false;
      spawnBulletDisperse(this.x, this.y, {
        color: this.color,
        accent: this.type==='spark'? '#fef3c7' : undefined,
        radius: this.r,
        count: Math.max(4, Math.round(3 + this.r)),
        speed: 140 + this.r * 12,
        glowStrength: options.glowStrength ?? 0.55,
      });
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
      if(this.life<=0){ this.destroy(); return; }
      if(this.x<20||this.x>CONFIG.roomW-20||this.y<20||this.y>CONFIG.roomH-20){ this.destroy(); return; }
      if(this.alive){
        for(const obs of dungeon.current.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(this, obs)){ this.destroy({glowStrength:0.4}); break; }
        }
      }
    }
    checkHit(target){
      if(!this.alive) return false;
      if(dist(this,target) < this.r + target.r){ target.hurt(this.type==='needle'?2:1); return true; }
      return false;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.rotate(Math.atan2(this.vy,this.vx));
      if(this.type==='needle'){
        ctx.fillStyle=this.color || '#f973a6';
        ctx.fillRect(-8,-2,16,4);
        ctx.fillStyle='#ffe4f0';
        ctx.fillRect(4,-1.2,6,2.4);
      } else if(this.type==='spark'){
        const g = ctx.createRadialGradient(0,0,1,0,0,this.r*2);
        g.addColorStop(0,colorWithAlpha('#fef9c3',0.95));
        g.addColorStop(1,colorWithAlpha(this.color || '#fbbf24',0.9));
        ctx.fillStyle=g;
        ctx.beginPath();
        ctx.arc(0,0,this.r*1.3,0,Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#fde04788';
        ctx.lineWidth = 1.4;
        ctx.beginPath();
        ctx.arc(0,0,this.r*1.6,0,Math.PI*2);
        ctx.stroke();
      } else {
        const g = ctx.createRadialGradient(0,0,1,0,0,this.r*1.4);
        g.addColorStop(0,colorWithAlpha('#ffe6f3',0.92));
        g.addColorStop(1,colorWithAlpha(this.color || '#ff7aa9',0.85));
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }

  function handleEnemyDeath(enemy, room){
    if(!enemy) return;
    if(enemy._dropHandled) return;
    enemy._dropHandled = true;
    if(enemy.isBossSummon){ unregisterBossSummon(enemy); }
    triggerEnemyDeathEffects(enemy);
    if(typeof enemy.onDeath === 'function'){
      enemy.onDeath(room);
    }
    if(enemy.preventDrops) return;
    if(enemy.isBossEntity){
      room.bossDefeated = true;
      room.cleared = true;
      spawnBossRewards(room, enemy.x, enemy.y);
      spawnBossPortal(room);
      if(runtime.bossSummons){ runtime.bossSummons.delete(enemy); }
    } else {
      if(rand() < CONFIG.drops.heartPerEnemy){
        const heal = rand() < CONFIG.drops.doubleHeartChance ? 2 : 1;
        room.pickups.push(makeHeartPickup(enemy.x + randRange(-12,12), enemy.y + randRange(-12,12), heal));
      }
      const soulChance = CONFIG.drops.soulHeartChance ?? 0;
      if(soulChance>0 && rand() < soulChance){
        room.pickups.push(makeSoulHeartPickup(enemy.x + randRange(-12,12), enemy.y + randRange(-12,12), 1));
      }
      if(rand() < CONFIG.drops.resourcePerEnemy){
        const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
        const amount = resType==='coin'?3:1;
        room.pickups.push(makeResourcePickup(resType, enemy.x + randRange(-18,18), enemy.y + randRange(-18,18), amount));
      }
    }
  }

  function spawnHeartBundle(room,x,y){
    room.pickups.push(makeHeartPickup(x+randRange(-18,18), y, 2));
    room.pickups.push(makeHeartPickup(x+randRange(-24,24), y+randRange(-20,20), 1));
    room.pickups.push(makeHeartPickup(x+randRange(-24,24), y+randRange(-20,20), 1));
  }

  function spawnBossRewards(room,x,y){
    spawnHeartBundle(room,x,y);
    const item = rollBossItem();
    room.pickups.push({type:'item', x:clamp(x,90,CONFIG.roomW-90), y:clamp(y-40,120,CONFIG.roomH-120), r:18, item, vx:0, vy:0, solid:false});
  }

  function spawnBossPortal(room){
    if(!room) return null;
    if(currentFloor >= FINAL_FLOOR){
      return spawnFinalPortals(room);
    }
    const cfg = CONFIG.portal || {};
    const center = typeof room.center === 'function' ? room.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    const offsetY = cfg.offsetY ?? 60;
    const portal = {
      x: clamp(center.x, 90, CONFIG.roomW-90),
      y: clamp(center.y + offsetY, 120, CONFIG.roomH-100),
      r: cfg.radius ?? 34,
      interactRadius: cfg.interactRadius ?? ((cfg.radius ?? 34) + 18),
      spawnDelay: Math.max(0, cfg.spawnDelay ?? 0),
      phase: rand()*Math.PI*2,
      active: false,
      used: false,
      highlight: 0,
      type: 'next',
    };
    room.portal = portal;
    repelPickupsFromPortal(room, portal, {forcePower: 140});
    let spawnedExchange = false;
    const chance = getExchangePortalChance();
    const pity = Math.max(0, runtime?.exchangePortalPity ?? 0);
    const threshold = clamp(chance + pity, 0, 1);
    const roll = rand();
    if(roll < threshold){
      const exchangePortal = spawnExchangePortal(room);
      if(exchangePortal){
        spawnedExchange = true;
        runtime.exchangePortalChance = 1;
        if(runtime){ runtime.exchangePortalPity = 0; }
        if(!runtime.exchangeRoom){
          runtime.exchangeRoom = createExchangeRoom(room);
        } else {
          runtime.exchangeRoom.originRoom = room;
          if(runtime.exchangeRoom.portal){
            runtime.exchangeRoom.portal.originRoom = room;
          }
        }
        if(runtime.itemPickupTimer<=0){
          runtime.itemPickupName = '交换门已开启';
          runtime.itemPickupDesc = '献祭 1 点生命上限可获取强力道具。';
          runtime.itemPickupTimer = 2.2;
        }
      }
      if(!spawnedExchange){
        const pityStep = Math.max(0, cfg.exchangePityStep ?? 0.18);
        const maxPity = Math.max(0, 1 - chance);
        if(runtime){ runtime.exchangePortalPity = Math.min(maxPity, pity + pityStep); }
        runtime.exchangePortalChance = chance;
      }
    } else {
      const pityStep = Math.max(0, cfg.exchangePityStep ?? 0.18);
      const maxPity = Math.max(0, 1 - chance);
      if(runtime){ runtime.exchangePortalPity = Math.min(maxPity, pity + pityStep); }
      runtime.exchangePortalChance = chance;
    }
    return portal;
  }

  function spawnFinalPortals(room){
    if(!room) return null;
    const cfg = CONFIG.portal || {};
    const center = typeof room.center === 'function' ? room.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    const offset = Math.max(120, cfg.finalOffset ?? 150);
    const baseY = clamp(center.y + (cfg.offsetY ?? 60), 120, CONFIG.roomH-110);
    const radius = cfg.radius ?? 34;
    const interactRadius = cfg.interactRadius ?? (radius + 18);
    const spawnDelay = Math.max(0, cfg.spawnDelay ?? 0);
    const endingPortal = {
      type:'ending',
      x: clamp(center.x - offset, 90, CONFIG.roomW-90),
      y: baseY,
      r: radius,
      interactRadius,
      spawnDelay,
      phase: rand()*Math.PI*2,
      active: false,
      used: false,
      highlight: 0,
      hint: '按 F 踏入终点',
    };
    const loopPortal = {
      type:'loop',
      x: clamp(center.x + offset, 90, CONFIG.roomW-90),
      y: baseY,
      r: radius,
      interactRadius,
      spawnDelay,
      phase: rand()*Math.PI*2,
      active: false,
      used: false,
      highlight: 0,
      hint: '按 F 再次轮回',
    };
    room.portal = endingPortal;
    if(!Array.isArray(room.extraPortals)) room.extraPortals = [];
    room.extraPortals.push(loopPortal);
    repelPickupsFromPortal(room, endingPortal, {forcePower: 160});
    repelPickupsFromPortal(room, loopPortal, {forcePower: 160});
    runtime.exchangePortalChance = 0;
    runtime.exchangePortalPity = 0;
    runtime.itemPickupName = '命运双门敞开';
    runtime.itemPickupDesc = '左侧归于终章，右侧再入轮回。';
    runtime.itemPickupTimer = 3.2;
    return endingPortal;
  }

  function makeHeartPickup(x,y,heal){
    return {type:'heart', x:clamp(x,60,CONFIG.roomW-60), y:clamp(y,60,CONFIG.roomH-60), r: heal>1?14:10, heal, vx:0, vy:0, solid:true, spawnGrace:CONFIG.pickupSpawnGrace};
  }

  function makeSoulHeartPickup(x,y,amount){
    const value = Math.max(1, Math.floor(amount || 1));
    return {
      type:'heart',
      kind:'soul',
      x:clamp(x,60,CONFIG.roomW-60),
      y:clamp(y,60,CONFIG.roomH-60),
      r: value>1 ? 14 : 11,
      amount:value,
      vx:0,
      vy:0,
      solid:true,
      spawnGrace:CONFIG.pickupSpawnGrace,
    };
  }

  function tryPlayerCollectHeart(pickup, options={}){
    const playerRef = options.player || player;
    const allowWaste = !!options.allowWaste;
    const result = {
      collected:false,
      gained:false,
      consumed:false,
      amount:0,
    };
    if(!playerRef || !pickup) return result;
    if(pickup.kind === 'soul'){
      const amount = pickup.amount || pickup.heal || 1;
      const gained = typeof playerRef.addSoulHearts === 'function'
        ? playerRef.addSoulHearts(amount)
        : 0;
      if(gained>0){
        result.collected = true;
        result.gained = true;
        result.amount = gained;
        if(typeof pickup.amount === 'number'){
          pickup.amount = Math.max(0, amount - gained);
          pickup.r = pickup.amount>1 ? 14 : 11;
        }
        result.consumed = !pickup.amount;
        return result;
      }
      if(allowWaste){
        result.collected = true;
        result.gained = false;
        result.amount = amount;
        result.consumed = true;
        if(typeof pickup.amount === 'number'){
          pickup.amount = 0;
          pickup.r = 11;
        }
      }
      return result;
    }
    const healValue = pickup.heal || 1;
    const maxHp = Number.isFinite(playerRef.maxHp)
      ? playerRef.maxHp
      : (playerRef.maxHpCap ?? 0);
    const missing = Math.max(0, maxHp - playerRef.hp);
    let applied = Math.min(missing, healValue);
    if(applied>0){
      const clampMax = maxHp>0 ? maxHp : playerRef.hp + applied;
      playerRef.hp = Math.min(clampMax, playerRef.hp + applied);
      if(typeof pickup.heal === 'number'){
        pickup.heal = Math.max(0, healValue - applied);
        pickup.r = pickup.heal>1 ? 14 : 10;
      }
      if(typeof playerRef.recalculateDamage === 'function'){
        playerRef.recalculateDamage();
      }
      if(typeof playerRef.updateHolyHeartBlessing === 'function'){
        playerRef.updateHolyHeartBlessing();
      }
      result.collected = true;
      result.gained = true;
      result.amount = applied;
      result.consumed = !pickup.heal || pickup.heal<=0;
      return result;
    }
    if(allowWaste){
      result.collected = true;
      result.gained = false;
      result.amount = healValue;
      result.consumed = true;
      if(typeof pickup.heal === 'number'){
        pickup.heal = 0;
        pickup.r = 10;
      }
    }
    return result;
  }

  function makeExchangeSupplyPickup(x,y){
    const cx = clamp(x, 60, CONFIG.roomW-60);
    const cy = clamp(y, 60, CONFIG.roomH-60);
    if(rand() < 0.5){
      const soul = makeSoulHeartPickup(cx, cy, 1);
      soul.spawnGrace = CONFIG.pickupSpawnGrace;
      return soul;
    }
    const resourceTypes = Array.isArray(CONFIG.drops?.resourceTypes) && CONFIG.drops.resourceTypes.length
      ? CONFIG.drops.resourceTypes
      : ['coin','key','bomb'];
    const res = resourceTypes[Math.floor(rand()*resourceTypes.length)] || 'coin';
    const amount = res === 'coin' ? 5 : 1;
    const pickup = makeResourcePickup(res, cx, cy, amount);
    pickup.spawnGrace = CONFIG.pickupSpawnGrace;
    return pickup;
  }

  function ensureBossSummonTracker(){
    if(!runtime.bossSummons || typeof runtime.bossSummons.clear !== 'function'){
      runtime.bossSummons = new Map();
    }
    return runtime.bossSummons;
  }

  function clearBossSummonTracker(){
    if(runtime.bossSummons && typeof runtime.bossSummons.clear === 'function'){
      runtime.bossSummons.clear();
    } else {
      runtime.bossSummons = new Map();
    }
  }

  function getBossSummonKey(summoner){
    return summoner || GLOBAL_BOSS_SUMMON_KEY;
  }

  function countActiveBossSummons(summoner){
    const tracker = ensureBossSummonTracker();
    const key = getBossSummonKey(summoner);
    const set = tracker.get(key);
    if(!set) return 0;
    let count = 0;
    for(const entry of Array.from(set)){
      if(entry && !entry.dead){
        count++;
      } else {
        set.delete(entry);
      }
    }
    if(set.size===0){ tracker.delete(key); }
    return count;
  }

  function countPendingBossSummons(summoner){
    const pending = runtime.pendingEnemySpawns;
    if(!Array.isArray(pending) || pending.length===0) return 0;
    const key = getBossSummonKey(summoner);
    let total = 0;
    for(const spawn of pending){
      if(!spawn?.isBossSummon) continue;
      const spawnKey = getBossSummonKey(spawn.bossSummoner);
      if(spawnKey !== key) continue;
      total++;
    }
    return total;
  }

  function registerBossSummon(enemy){
    if(!enemy?.isBossSummon) return;
    const tracker = ensureBossSummonTracker();
    const key = getBossSummonKey(enemy.bossSummoner);
    let set = tracker.get(key);
    if(!set){
      set = new Set();
      tracker.set(key, set);
    }
    set.add(enemy);
  }

  function unregisterBossSummon(enemy){
    if(!enemy?.isBossSummon) return;
    const tracker = runtime.bossSummons;
    if(!tracker) return;
    const key = getBossSummonKey(enemy.bossSummoner);
    const set = tracker.get(key);
    if(!set) return;
    set.delete(enemy);
    if(set.size===0){ tracker.delete(key); }
  }

  function queueEnemySpawn(enemy, options={}){
    if(!enemy) return false;
    const opts = options || {};
    const flagged = !!(opts.bossSummon || enemy.isBossSummon);
    let summoner = opts.summoner || enemy.bossSummoner;
    if(!summoner && enemy?.master && enemy.master.isBossEntity){
      summoner = enemy.master;
    }
    if(flagged){
      const totalActive = countActiveBossSummons(summoner);
      const totalPending = countPendingBossSummons(summoner);
      if(totalActive + totalPending >= MAX_BOSS_SUMMONS){
        return false;
      }
      enemy.isBossSummon = true;
      enemy.bossSummoner = summoner || null;
    }
    runtime.pendingEnemySpawns.push(prepareEnemy(enemy));
    return true;
  }

  function placeBomb(){
    if(!player || !dungeon?.current) return;
    if(player.bombs<=0 || player.bombCooldown>0) return;
    const bomb = new Bomb(player.x, player.y, {
      owner: 'player',
      radiusMultiplier: player?.bombRadiusMultiplier ?? 1,
      damageMultiplier: player?.bombDamageMultiplier ?? 1,
      shakeStrength: player?.bombShakeStrength ?? 0,
    });
    dungeon.current.bombs.push(bomb);
    player.bombs = Math.max(0, player.bombs-1);
    player.bombCooldown = 0.3;
  }

  function attemptActiveUse(){
    if(state!==STATE.PLAY) return;
    if(!player) return;
    const item = player.activeItem;
    if(!item){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = '未装备主动道具';
        runtime.itemPickupDesc = '清理道具房或商店，寻找主动道具。';
        runtime.itemPickupTimer = 1.6;
      }
      return;
    }
    const maxCharge = Math.max(0, player.activeMaxCharge ?? 0);
    if(maxCharge<=0){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = `${item.name || '主动道具'} 无充能槽`;
        runtime.itemPickupDesc = '请为主动道具设定最大充能值。';
        runtime.itemPickupTimer = 1.4;
      }
      return;
    }
    if(typeof item.use !== 'function'){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = `${item.name || '主动道具'} 暂无效果`;
        runtime.itemPickupDesc = '为主动道具编写 use() 函数后即可释放。';
        runtime.itemPickupTimer = 1.6;
      }
      return;
    }
    if(!player.canUseActiveItem()){
      if(runtime.itemPickupTimer<=0){
        const remain = Math.max(0, maxCharge - player.activeCharge);
        runtime.itemPickupName = `${item.name || '主动道具'} 充能中`;
        runtime.itemPickupDesc = remain>0 ? `还需 ${remain} 点充能` : '再等等能量汇聚。';
        runtime.itemPickupTimer = 1.3;
      }
      return;
    }
    const context = {runtime, dungeon, config: CONFIG};
    const outcome = player.useActiveItem(context);
    if(outcome === false) return;
    triggerActiveUseAnimation(item);
    if(runtime.itemPickupTimer<=0){
      let name = `${item.name || '主动道具'} 已释放`;
      let desc = item.description || '主动效果发动。';
      if(outcome && typeof outcome === 'object'){
        if(outcome.message) name = outcome.message;
        if(outcome.detail) desc = outcome.detail;
      }
      runtime.itemPickupName = name;
      runtime.itemPickupDesc = desc;
      runtime.itemPickupTimer = 1.6;
    }
  }

  function attemptSingleUse(){
    if(state!==STATE.PLAY) return;
    if(!player) return;
    const item = player.singleUseItem;
    if(!item){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = '卡牌槽为空';
        runtime.itemPickupDesc = '探索或购物以获取卡牌。';
        runtime.itemPickupTimer = 1.4;
      }
      return;
    }
    if(typeof item.use !== 'function'){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = `${item.name || '卡牌'} 暂无效果`;
        runtime.itemPickupDesc = '为卡牌编写 use() 函数即可释放。';
        runtime.itemPickupTimer = 1.4;
      }
      return;
    }
    const context = {runtime, dungeon, config: CONFIG};
    const outcome = player.useSingleUseItem(context);
    if(outcome === false) return;
    if(runtime.itemPickupTimer<=0){
      let name = `${item.name || '卡牌'} 已使用`;
      let desc = item.description ? `${item.description} · 已触发。` : '卡牌效果发动。';
      if(outcome && typeof outcome === 'object'){
        if(outcome.message) name = outcome.message;
        if(outcome.detail) desc = outcome.detail;
      }
      runtime.itemPickupName = name;
      runtime.itemPickupDesc = desc;
      runtime.itemPickupTimer = 1.4;
    }
  }

  function handlePortalInteraction(room, portal){
    if(!portal) return null;
    if(portal.type === 'exchange'){
      if(enterExchangeRoom(room, portal)){ return {consume:false}; }
      return null;
    }
    if(portal.type === 'return'){
      if(leaveExchangeRoom(portal)){ return {consume:false}; }
      return null;
    }
    if(portal.type === 'ending'){
      triggerRunEnding();
      return {consume:true};
    }
    if(portal.type === 'loop'){
      const looped = startLoopRun();
      return looped ? {consume:true} : null;
    }
    if(currentFloor >= FINAL_FLOOR){
      triggerRunEnding();
      return {consume:true};
    }
    advanceToNextFloor();
    return {consume:true};
  }

  function tryPortalInteract(room){
    if(!player || !room) return false;
    const portals = roomPortals(room);
    if(!portals.length) return false;
    for(const portal of portals){
      if(!portal || portal.used || !portal.active) continue;
      const interactRadius = portal.interactRadius ?? (portal.r + 18);
      if(dist(player, portal) > interactRadius) continue;
      const outcome = handlePortalInteraction(room, portal);
      if(outcome){
        if(outcome.consume){ portal.used = true; }
        return true;
      }
    }
    return false;
  }

  function attemptPurchase(){
    const room = dungeon?.current;
    if(!player || !room) return;
    if(tryPortalInteract(room)) return;
    let targetIndex=-1;
    let nearest=Infinity;
    for(let i=0;i<room.pickups.length;i++){
      const p = room.pickups[i];
      if(p.type!=='shop' || p.purchased) continue;
      const d = dist(p, player);
      if(d < p.r + player.r + 16 && d < nearest){ nearest=d; targetIndex=i; }
    }
    if(targetIndex===-1) return;
    const pickup = room.pickups[targetIndex];
    const finalPrice = resolveShopPrice(pickup, player);
    if(player.coins < finalPrice){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = '钱包在抗议';
        runtime.itemPickupDesc = `还差 ${finalPrice - player.coins} 枚金币才买得起`;
        runtime.itemPickupTimer = 1.2;
      }
      return;
    }
    player.coins = Math.max(0, player.coins - finalPrice);
    player.recalculateDamage();
    pickup.purchased = true;
    room.pickups.splice(targetIndex,1);
    if(pickup.entry.type==='item'){
      const item = pickup.entry.item;
      if(typeof item.apply === 'function'){ item.apply(player); }
      recordItemAcquired(player, item);
      runtime.itemPickupName = item.name;
      runtime.itemPickupDesc = item.description || '';
      runtime.itemPickupTimer = 2.4;
      maybeSpawnCardDrop(dungeon.current, {x: pickup.x, y: pickup.y});
    } else if(pickup.entry.type==='card'){
      givePlayerCard(pickup.entry.card, {room: dungeon.current, x: pickup.x, y: pickup.y});
    } else if(pickup.entry.type==='resource'){
      const gained = grantResource(pickup.entry.resource, pickup.entry.amount);
      const label = RESOURCE_LABELS[pickup.entry.resource] || '资源';
      if(gained>0){
        runtime.itemPickupName = `${label} +${gained}`;
        runtime.itemPickupDesc = '来自商店柜台的友情价';
        runtime.itemPickupTimer = 1.5;
      } else {
        runtime.itemPickupName = `${label} 背包已满`;
        runtime.itemPickupDesc = '再整理一下口袋吧';
        runtime.itemPickupTimer = 1.2;
      }
    }
  }

  // ======= 入口 =======
  function showStart(){ showMenu(); lastTime = performance.now(); }
  showStart();

})();
</script>
</body>
</html>
