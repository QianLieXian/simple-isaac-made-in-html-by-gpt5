<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>简易以撒-like</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#151923; --ink:#e6e6e6; --muted:#9aa4b2; --accent:#6ee7ff; --accent2:#a78bfa; --danger:#ff6b6b; --ok:#86efac;
    }
    html,body{height:100%;}
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 600px at 50% -10%,#1a2030 0%,#0f1115 55%,#0b0d12 100%);color:var(--ink);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;}
    .wrap{max-width:960px;margin:24px auto;padding:16px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-weight:700;letter-spacing:.5px}
    .badge{padding:4px 8px;border:1px solid #2a3142;border-radius:999px;color:var(--muted)}
    .panel{background:linear-gradient(180deg,#121623,#0f131e);border:1px solid #202736;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .canvas-wrap{position:relative;aspect-ratio:4/3}
    canvas{width:100%;height:100%;display:block;border-radius:16px}
    .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;margin-top:10px;flex-wrap:wrap}
    .hud-section{display:flex;align-items:center;gap:6px}
    .hud-stats{flex:1 1 100%;display:flex;flex-wrap:wrap;gap:10px;font-size:13px;color:var(--muted);letter-spacing:.2px}
    .hud-stats span{display:flex;align-items:center;gap:4px;padding:2px 6px;border:1px solid #222a38;border-radius:8px;background:rgba(17,21,29,.65);color:var(--muted)}
    .hud-stats span strong{color:var(--ink);font-weight:600;min-width:36px;text-align:right;font-variant-numeric:tabular-nums}
    .hud-tools{display:flex;gap:10px;margin-left:auto;align-items:flex-start;position:relative}
    .hud-tools>div{position:relative}
    .hud-tools button{background:rgba(31,36,52,.9);color:var(--ink);border:1px solid #2c3448;border-radius:8px;padding:6px 10px;cursor:pointer;font-size:13px;letter-spacing:.4px;transition:all .2s ease}
    .hud-tools button:hover,.hud-tools button.active{border-color:#3a4c6f;background:rgba(45,52,72,.95)}
    .hud-virtual{display:flex;flex-direction:column;gap:8px;align-items:flex-end}
    .hud-cheat{position:relative;display:flex;align-items:flex-start}
    .cheat-toggle{background:rgba(31,36,52,.9);color:var(--ink);border:1px solid #2c3448;border-radius:8px;padding:6px 10px;cursor:pointer;font-size:13px;letter-spacing:.4px;transition:all .2s ease}
    .cheat-toggle:hover{border-color:#3a4c6f;background:rgba(45,52,72,.95)}
    .cheat-panel{display:none;position:absolute;top:110%;right:0;z-index:20;min-width:240px;max-width:280px;padding:12px 14px;border-radius:12px;background:rgba(15,19,28,.95);border:1px solid #273146;box-shadow:0 16px 32px rgba(0,0,0,.45);gap:14px;flex-direction:column}
    .cheat-panel.show{display:flex}
    .cheat-panel h4{margin:0 0 6px 0;font-size:13px;color:var(--accent2);letter-spacing:.3px}
    .cheat-section{display:flex;flex-direction:column;gap:6px}
    .cheat-section label{display:flex;flex-direction:column;gap:4px;font-size:12px;color:var(--muted)}
    .cheat-section input{background:#111521;border:1px solid #2c3448;border-radius:6px;color:var(--ink);padding:5px 6px;font-size:12px}
    .cheat-section input:focus{outline:none;border-color:var(--accent)}
    .cheat-section button{align-self:flex-end;background:linear-gradient(180deg,#2c3348,#222735);border:1px solid #2f3a52;border-radius:8px;color:var(--ink);padding:6px 10px;font-size:12px;cursor:pointer;transition:all .2s ease}
    .cheat-section button:hover{border-color:#3c4c6a;background:linear-gradient(180deg,#34405a,#273044)}
    .hud-stats span small{font-size:12px;color:var(--muted);opacity:.8}
    .kbd{padding:2px 6px;border:1px solid #2a3142;border-radius:6px;color:var(--muted)}
    .virtual-kb{display:none;position:absolute;top:110%;right:0;z-index:19;min-width:260px;background:rgba(15,19,28,.95);border:1px solid #273146;border-radius:12px;padding:10px;box-shadow:0 16px 28px rgba(0,0,0,.45);gap:8px}
    .virtual-kb.show{display:grid}
    .virtual-kb-row{display:grid;gap:8px}
    .virtual-kb-row[data-type="movement"]{grid-template-columns:repeat(3,1fr)}
    .virtual-kb-row[data-type="arrows"]{grid-template-columns:repeat(3,1fr)}
    .virtual-kb-row[data-type="actions"]{grid-template-columns:repeat(4,1fr)}
    .virtual-kb-row[data-type="system"]{grid-template-columns:repeat(3,1fr)}
    .virtual-kb button{padding:10px 8px;border-radius:10px;border:1px solid #2f3a52;background:linear-gradient(180deg,#2c3348,#222735);color:var(--ink);font-weight:600;font-size:13px;min-width:0;transition:all .15s ease;user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;touch-action:none}
    .virtual-kb button:active,.virtual-kb button.active{transform:translateY(1px);border-color:#3c4c6a;background:linear-gradient(180deg,#34405a,#273044)}
    .virtual-kb button.small{font-size:12px;font-weight:500}
    .virtual-kb-spacer{visibility:hidden}
    .item-codex{margin-top:14px;padding:16px 18px;display:flex;flex-direction:column;gap:14px}
    .codex-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .codex-title{font-size:15px;font-weight:600;letter-spacing:.3px}
    .codex-progress{font-size:12px;color:var(--muted);letter-spacing:.3px}
    .codex-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr))}
    .codex-entry{display:grid;grid-template-columns:48px 1fr;gap:12px;padding:12px 14px;border:1px solid #222a38;border-radius:12px;background:rgba(17,21,29,.7);box-shadow:inset 0 0 0 1px rgba(65,76,104,.18)}
    .codex-icon{width:48px;height:48px;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 35% 30%,rgba(110,231,255,.18),rgba(167,139,250,.12) 55%,transparent 100%);border-radius:12px}
    .codex-icon canvas{width:42px;height:42px}
    .codex-info{display:flex;flex-direction:column}
    .codex-name{font-size:13px;font-weight:600;color:var(--ink);letter-spacing:.2px}
    .codex-desc{margin-top:4px;font-size:12px;color:var(--muted);line-height:1.5}
    .codex-empty{grid-column:1/-1;text-align:center;padding:28px 18px;border:1px dashed #293347;border-radius:12px;color:var(--muted);font-size:13px;background:rgba(12,15,22,.65)}
    .cheat-feedback{margin-top:6px;font-size:12px;color:var(--muted);min-height:18px}
    @media (max-width:720px){
      .hud{flex-direction:column;align-items:stretch}
      .hud-tools{align-self:flex-end}
      .virtual-kb{position:fixed;left:50%;bottom:16px;top:auto;right:auto;transform:translateX(-50%);z-index:30;display:none;grid-template-columns:repeat(1,minmax(240px,1fr));width:min(92vw,400px)}
      .virtual-kb.show{display:grid}
      .virtual-kb-row{grid-template-columns:repeat(4,1fr)}
      .virtual-kb-row[data-type="movement"]{grid-template-columns:repeat(3,1fr)}
      .virtual-kb-row[data-type="arrows"]{grid-template-columns:repeat(3,1fr)}
      .virtual-kb-row[data-type="system"]{grid-template-columns:repeat(3,1fr)}
    }
    footer{margin-top:16px;color:var(--muted);text-align:center}
    /* overlays */
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;padding:24px}
    .overlay.show{display:flex}
    .card{max-width:520px;padding:18px 18px;border-radius:14px;background:rgba(15,17,21,.85);backdrop-filter: blur(6px);border:1px solid #202736}
    .card h2{margin:0 0 8px 0}
    .card p{margin:8px 0;color:var(--muted)}
    .card ul{margin:10px 0 0 1.2em;color:var(--muted)}
    .card li{margin:4px 0}
    a.btn{display:inline-block;margin-top:10px;padding:8px 12px;border-radius:10px;border:1px solid #273044;color:var(--ink);text-decoration:none}
    a.btn:hover{border-color:#3a4764}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">地窖速通实验室 · HTML5 Canvas</div>
      <div class="badge">WASD 移动 · 方向键射击 · E 放置炸弹 · F 购买 · 回车开始 · P 暂停 · R 重开 · 记得深呼吸</div>
    </header>
    <div class="panel canvas-wrap">
      <canvas id="game" width="800" height="600"></canvas>
      <div class="overlay" id="menu">
        <div class="card">
          <h2>地窖暖场中…</h2>
          <p>这是款极简的房间制顶视角射击。先伸个懒腰再闯关——清空房间敌人，门才会知趣地打开。</p>
          <ul>
            <li><b>W/A/S/D</b> 移动，<b>↑/↓/←/→</b> 射击</li>
            <li><b>Enter</b> 开始 · <b>P</b> 暂停/继续 · <b>R</b> 重开</li>
          </ul>
          <a class="btn" href="#" id="startBtn">我要出发！</a>
        </div>
      </div>
      <div class="overlay" id="paused">
        <div class="card">
          <h2>暂时打个盹</h2>
          <p>按 <b>P</b> 继续。关卡在原地等你，敌人也在发呆。</p>
        </div>
      </div>
      <div class="overlay" id="gameover">
        <div class="card">
          <h2>勇者累趴了</h2>
          <p>按 <b>R</b> 重开，或者 <b>Enter</b> 回到主菜单准备再战。</p>
        </div>
      </div>
    </div>
    <div class="panel hud">
      <div id="hud-left" class="hud-section"></div>
      <div id="hud-stats" class="hud-stats"></div>
      <div id="hud-right" class="hud-section"></div>
      <div class="hud-tools">
        <div class="hud-virtual">
          <button id="vk-toggle" type="button" aria-controls="virtual-kb" aria-expanded="false">屏幕键盘</button>
          <div id="virtual-kb" class="virtual-kb" aria-hidden="true"></div>
        </div>
        <div class="hud-cheat">
          <button id="cheat-toggle" class="cheat-toggle" type="button" aria-controls="cheat-panel" aria-expanded="false">作弊台</button>
          <div id="cheat-panel" class="cheat-panel">
          <div class="cheat-section">
            <h4>状态</h4>
            <label>当前血量 <input id="cheat-hp" type="number" min="0" max="20" step="1"></label>
            <label>生命上限 <input id="cheat-maxhp" type="number" min="1" max="20" step="1"></label>
            <label>基础伤害 <input id="cheat-damage" type="number" min="0" step="0.1"></label>
            <label>移动速度 <input id="cheat-speed" type="number" min="0" step="1"></label>
            <label>射速(次/秒) <input id="cheat-firerate" type="number" min="0.1" step="0.1"></label>
            <label>子弹速度 <input id="cheat-tearspeed" type="number" min="1" step="1"></label>
            <button id="cheat-apply-stats" type="button">应用状态</button>
          </div>
          <div class="cheat-section">
            <h4>资源</h4>
            <label>炸弹 <input id="cheat-bombs" type="number" min="0" max="99" step="1"></label>
            <label>钥匙 <input id="cheat-keys" type="number" min="0" max="99" step="1"></label>
            <label>金币 <input id="cheat-coins" type="number" min="0" max="99" step="1"></label>
            <button id="cheat-apply-resources" type="button">应用资源</button>
          </div>
          <div class="cheat-section">
            <h4>道具</h4>
            <label>道具 ID <input id="cheat-item-id" type="number" min="1" step="1" placeholder="例如 1"></label>
            <button id="cheat-give-item" type="button">给予道具</button>
            <div id="cheat-item-result" class="cheat-feedback" aria-live="polite"></div>
          </div>
          </div>
        </div>
      </div>
    </div>
    <div id="item-codex" class="panel item-codex" aria-live="polite">
      <div class="codex-header">
        <span class="codex-title">道具图鉴</span>
        <span class="codex-progress">已解锁 <span id="codex-count">0</span> / <span id="codex-total">0</span></span>
      </div>
      <div id="codex-grid" class="codex-grid"></div>
    </div>
    <footer>纯前端单文件 · 无素材 · 轻便又俏皮</footer>
  </div>

<script>
(() => {
  'use strict';
  // ======= 配置 =======
  const CONFIG = {
    roomW: 800, roomH: 600,
    grid: 9, // 更大的潜在网格，随机游走生成不规则结构
    roomsToMake: 9, // 随机游走生成房间数量
    itemRooms: 1,
    player: {
      speed: 210,
      radius: 12,
      hp: 6,
      fireCd: 360,
      tearSpeed: 230,
      tearLife: 0.65,
      friction: 3.15,      // 基础滑行阻力（越小越滑）
      accelFactor: 1.02,  // 加速效率（=1 时稳态速度约等于 speed）
      maxSpeedScale: 1.1, // 允许的速度上限倍率，给予一点惯性裕度
    }, // fireCd 毫秒
    enemy: {
      baseHP: 2,
      speed: 90,
      spawnMin: 3, spawnMax: 6,
      maxPerRoom: 5,
      gasbag: {speed: 95, safeRadius: 180, triggerRange: 70, triggerChance: 0.55, triggerCooldown: 0.9, fuse: 1.1, explosionRadius: 68, spawnMin: 3, spawnMax: 5},
      tinyFly: {speed: 80},
      elderFly: {speed: 60, minRange: 130, maxRange: 220, fireInterval: 2.5, telegraph: 1, projectileSpeed: 200},
      spider: {leapSpeed: 320, maxDistance: 320, telegraph: 1, cooldown: 3.2},
    },
    drops: {
      heartPerEnemy: 0.2,
      heartRoomClear: 0.25,
      doubleHeartChance: 0.18,
      resourcePerEnemy: 0.14,
      roomClearResource: 0.5,
      resourceTypes: ['bomb','key','coin'],
    },
    pickupSpawnGrace: 0.7,
    resources: {
      bombStart: 5,
      keyStart: 5,
      coinStart: 5,
    },
    bomb: {damage:65, radius:62, fuse:3, playerDamage:1, knock:270, spawnGrace:0.7},
    obstacles: {
      min:2,
      max:4,
      tileSizePlayerRatio:1.4,
      maxTiles:6,
      maxClusterArea:30,
      hiddenChance:0.005,
      hiddenItemChance:0.001,
      hollowChance:0.55,
    },
    shop: {
      itemChance: 0.95,
      doubleItemChance: 0.05,
      dropPrice: 5,
      itemPrice: 15,
    },
    progression: {
      enemyHp: 1.2,
      enemySpeed: 1.1,
      enemyAggression: 1.1,
    },
    combat: {
      shotInertia: 0.32,
      shotForwardBoost: 0.7,
      shotLateralInfluence: 0.35,
    },
    portal: {
      radius: 36,
      interactRadius: 52,
      spawnDelay: 0.45,
    },
    rngSeed: Date.now() % 1000000,
  };

  // ======= 基础工具 =======
  const rand = mulberry32(CONFIG.rngSeed);
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}};
  function randRange(min,max){return min + (max-min)*rand()}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
  function rectOverlap(a,b){
    return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
  }
  function adjustFireRate(player, delta){
    if(!player) return;
    const currentRate = player.fireInterval>0 ? 1000/player.fireInterval : 0;
    const newRate = Math.max(0.1, currentRate + delta);
    player.fireInterval = 1000 / newRate;
    player.fireCd = Math.min(player.fireCd, player.fireInterval);
  }
  const DIRS = [
    {di:-1,dj:0,key:'up',opp:'down'},
    {di:1,dj:0,key:'down',opp:'up'},
    {di:0,dj:-1,key:'left',opp:'right'},
    {di:0,dj:1,key:'right',opp:'left'}
  ];
  const BOSS_TYPES = [
    {id:'idol', name:'哭泣塑像 · 社畜蛹'},
    {id:'master', name:'余烬教官 · Master'},
  ];
  function rollBossType(){
    return BOSS_TYPES[Math.floor(rand()*BOSS_TYPES.length)];
  }
  function getBossMeta(id){
    return BOSS_TYPES.find(b=>b.id===id) || BOSS_TYPES[0];
  }
  let currentFloor = 1;
  function safeProgressionValue(base){
    return (typeof base === 'number' && isFinite(base) && base>0) ? base : 1;
  }
  function sanitizeScalingValue(value, fallback=1){
    return (typeof value === 'number' && isFinite(value) && value>0) ? value : fallback;
  }
  function getFloorScalingFactors(floor = currentFloor){
    const progression = CONFIG.progression || {};
    if(typeof progression.getEnemyScaling === 'function'){
      const custom = progression.getEnemyScaling(floor) || {};
      const hp = custom.hp ?? custom.enemyHp;
      const speed = custom.speed ?? custom.enemySpeed;
      const aggression = custom.aggression ?? custom.enemyAggression;
      return {
        floor: Math.max(1, floor|0),
        hp: sanitizeScalingValue(hp),
        speed: sanitizeScalingValue(speed),
        aggression: sanitizeScalingValue(aggression),
      };
    }
    const level = Math.max(1, floor|0);
    const exponent = level - 1;
    return {
      floor: level,
      hp: Math.pow(safeProgressionValue(progression.enemyHp), exponent),
      speed: Math.pow(safeProgressionValue(progression.enemySpeed), exponent),
      aggression: Math.pow(safeProgressionValue(progression.enemyAggression), exponent),
    };
  }
  const ITEM_POOL = [
    {
      slug:'onion',
      name:'洋葱',
      weight:50,
      description:'泪腺更发达，射速 +0.75 次/秒',
      apply(player){ adjustFireRate(player, 0.75); }
    },
    {
      slug:'tar',
      name:'焦油抹布',
      weight:30,
      description:'伤害 +0.5，泪滴更厚重',
      apply(player){ player.addDamage(0.5); }
    },
    {
      slug:'sneaker',
      name:'小短跑鞋',
      weight:50,
      description:'移动速度 +35，轻盈不少',
      apply(player){ player.speed += 35; }
    },
    {
      slug:'pepper-steak',
      name:'胡椒牛排',
      weight:5,
      description:'全身沸腾，伤害 +1，攻速 +1，射程 x1.5，血上限 +1',
      apply(player){ player.addDamage(1); adjustFireRate(player,1); player.tearLife*=1.5; if(typeof player.adjustMaxHp==='function'){ player.adjustMaxHp(1); } else { player.maxHp+=1; player.hp=Math.min(player.maxHp, player.hp+1); } }
    },
    {
      slug:'rope',
      name:'绳子',
      weight:20,
      description:'轻盈漂浮，飞行不再畏惧地形',
      apply(player){ player.flying = true; }
    },
    {
      slug:'spirit-date',
      name:'酒枣',
      weight:20,
      description:'射程 x1.5，泪滴可穿透障碍',
      apply(player){ player.tearLife*=1.5; player.canPierceObstacles = true; }
    },
    {
      slug:'betrayal-hound',
      name:'伙伴倒戈犬',
      weight:1,
      description:'狂暴背叛，伤害 x2 +1.5，射速 -0.25 次/秒',
      apply(player){ player.damageMultiplier *= 2; player.addDamage(1.5); adjustFireRate(player,-0.25); }
    },
    {
      slug:'despair-shout',
      name:'绝望呐喊',
      weight:40,
      description:'撕裂呐喊，射程 x5',
      apply(player){ player.tearLife*=5; }
    },
    {
      slug:'bad-thing',
      name:'坏东西',
      weight:50,
      description:'速度有点危险，子弹速度 x1.1',
      apply(player){ player.tearSpeed*=1.1; }
    },
    {
      slug:'good-thing',
      name:'好东西',
      weight:20,
      description:'越看越顺眼，子弹速度 x0.75，射速 +0.75，射程 x1.25',
      apply(player){ player.tearSpeed*=0.75; adjustFireRate(player,0.75); player.tearLife*=1.25; }
    }
  ];
  const SHOP_ITEM_POOL = [
    {
      slug:'blood-power',
      name:'血之力',
      weight:50,
      description:'血越厚，伤害越高',
      apply(player){ player.effects.bloodPower = true; player.recalculateDamage(); }
    },
    {
      slug:'money-power',
      name:'钱之力',
      weight:50,
      description:'财源滚滚，伤害随金币提升',
      apply(player){ player.effects.moneyPower = true; player.recalculateDamage(); }
    },
    {
      slug:'despair-power',
      name:'绝望之力',
      weight:20,
      description:'血越少，越要反击',
      apply(player){ player.effects.despairPower = true; player.recalculateDamage(); }
    }
  ];
  const BOSS_ITEM_POOL = [
    {
      slug:'dog-food',
      name:'狗粮',
      weight:50,
      description:'血量上限 +1',
      apply(player){ if(typeof player.adjustMaxHp==='function'){ player.adjustMaxHp(1); } else { player.maxHp+=1; player.hp=Math.min(player.maxHp, player.hp+1); } }
    },
    {
      slug:'ending-note',
      name:'结束纸条',
      weight:50,
      description:'射速 +0.75 次/秒，射程 x1.1',
      apply(player){ adjustFireRate(player,0.75); player.tearLife*=1.1; }
    },
    {
      slug:'kettle',
      name:'热水壶',
      weight:50,
      description:'伤害 +1',
      apply(player){ player.addDamage(1); }
    }
  ];
  const ITEM_ID_REGISTRY = (()=>{
    const pools = [ITEM_POOL, SHOP_ITEM_POOL, BOSS_ITEM_POOL];
    const byKey = new Map();
    const byId = new Map();
    let nextId = 1;
    for(const pool of pools){
      for(const item of pool){
        if(!item || !item.slug) continue;
        if(byKey.has(item.slug)){
          const stored = byKey.get(item.slug);
          item.id = stored.id;
          continue;
        }
        item.id = nextId++;
        byKey.set(item.slug, item);
        byId.set(item.id, item);
      }
    }
    return {byKey, byId, total: nextId-1};
  })();
  const ITEM_TOTAL_COUNT = ITEM_ID_REGISTRY.total;
  function getItemByNumericId(id){
    const numeric = Number(id);
    if(!Number.isFinite(numeric)) return null;
    return ITEM_ID_REGISTRY.byId.get(numeric) || null;
  }
  function cloneItemData(item){
    return item ? {...item} : null;
  }
  const RESOURCE_LABELS = {bomb:'炸弹', key:'钥匙', coin:'金币'};
  const HUDL = document.getElementById('hud-left');
  const HUDR = document.getElementById('hud-right');
  const HUDS = document.getElementById('hud-stats');
  const cheatToggle = document.getElementById('cheat-toggle');
  const cheatPanelNode = document.getElementById('cheat-panel');
  const cheatInputs = {
    hp: document.getElementById('cheat-hp'),
    maxHp: document.getElementById('cheat-maxhp'),
    damage: document.getElementById('cheat-damage'),
    speed: document.getElementById('cheat-speed'),
    firerate: document.getElementById('cheat-firerate'),
    tearSpeed: document.getElementById('cheat-tearspeed'),
    bombs: document.getElementById('cheat-bombs'),
    keys: document.getElementById('cheat-keys'),
    coins: document.getElementById('cheat-coins')
  };
  const cheatStatsBtn = document.getElementById('cheat-apply-stats');
  const cheatResBtn = document.getElementById('cheat-apply-resources');
  const cheatGiveItemBtn = document.getElementById('cheat-give-item');
  const cheatItemIdInput = document.getElementById('cheat-item-id');
  const cheatItemResult = document.getElementById('cheat-item-result');
  const CODEX_NODE = document.getElementById('item-codex');
  const CODEX_GRID = document.getElementById('codex-grid');
  const CODEX_COUNT = document.getElementById('codex-count');
  const CODEX_TOTAL = document.getElementById('codex-total');

  if(CODEX_TOTAL) CODEX_TOTAL.textContent = ITEM_TOTAL_COUNT;
  if(cheatItemIdInput && ITEM_TOTAL_COUNT>0){
    cheatItemIdInput.setAttribute('max', String(ITEM_TOTAL_COUNT));
  }
  const discoveredItems = new Set();

  function formatItemNumber(id){
    const str = String(id);
    return str.length>=2 ? str : str.padStart(2,'0');
  }

  function drawCodexIcons(canvases){
    if(!Array.isArray(canvases) || !canvases.length) return;
    requestAnimationFrame(()=>{
      for(const canvas of canvases){
        if(!canvas) continue;
        const ctx2 = canvas.getContext('2d');
        if(!ctx2) continue;
        ctx2.clearRect(0,0,canvas.width,canvas.height);
        ctx2.save();
        ctx2.translate(canvas.width/2, canvas.height/2 + 2);
        drawItemIcon(canvas.dataset.itemSlug, 18, ctx2);
        ctx2.restore();
      }
    });
  }

  function updateCodex(){
    if(CODEX_TOTAL) CODEX_TOTAL.textContent = ITEM_TOTAL_COUNT;
    if(CODEX_COUNT) CODEX_COUNT.textContent = discoveredItems.size;
    if(!CODEX_GRID) return;
    CODEX_GRID.innerHTML='';
    const discoveredList = Array.from(discoveredItems)
      .sort((a,b)=>a-b)
      .map(id=>ITEM_ID_REGISTRY.byId.get(id))
      .filter(Boolean);
    if(!discoveredList.length){
      const empty=document.createElement('div');
      empty.className='codex-empty';
      empty.textContent='尚未获得任何道具。探索地下室，解锁第一件宝物吧！';
      CODEX_GRID.appendChild(empty);
      return;
    }
    const canvases=[];
    for(const item of discoveredList){
      const card=document.createElement('div');
      card.className='codex-entry';
      const iconWrap=document.createElement('div');
      iconWrap.className='codex-icon';
      const canvas=document.createElement('canvas');
      canvas.width=64;
      canvas.height=64;
      canvas.dataset.itemSlug=item.slug;
      iconWrap.appendChild(canvas);
      const info=document.createElement('div');
      info.className='codex-info';
      const title=document.createElement('div');
      title.className='codex-name';
      title.textContent=`#${formatItemNumber(item.id)} · ${item.name}`;
      const desc=document.createElement('div');
      desc.className='codex-desc';
      desc.textContent=item.description || '暂无描述';
      info.appendChild(title);
      info.appendChild(desc);
      card.appendChild(iconWrap);
      card.appendChild(info);
      CODEX_GRID.appendChild(card);
      canvases.push(canvas);
    }
    drawCodexIcons(canvases);
  }

  function registerItemDiscovery(item){
    if(!item) return;
    const slug = item.slug;
    let numeric = item.id;
    if(numeric==null && slug && ITEM_ID_REGISTRY.byKey.has(slug)){
      numeric = ITEM_ID_REGISTRY.byKey.get(slug).id;
    }
    if(numeric==null) return;
    if(!discoveredItems.has(numeric)){
      discoveredItems.add(numeric);
      updateCodex();
    } else {
      if(CODEX_COUNT) CODEX_COUNT.textContent = discoveredItems.size;
    }
  }

  updateCodex();

  const cheatDirtyFields = new Set();

  function setCheatDirty(key, dirty = true){
    if(!key) return;
    if(dirty){
      cheatDirtyFields.add(key);
    }else{
      cheatDirtyFields.delete(key);
    }
  }
  function clearCheatDirty(...keys){
    if(!keys.length){
      cheatDirtyFields.clear();
      return;
    }
    for(const key of keys){ cheatDirtyFields.delete(key); }
  }

  for(const [key, input] of Object.entries(cheatInputs)){
    if(!input) continue;
    input.addEventListener('input', ()=> setCheatDirty(key, true));
  }

  function syncCheatPanel(){
    if(!cheatPanelNode || !cheatPanelNode.classList.contains('show') || !player) return;
    const active = document.activeElement;
    const skip = (key, input)=> (input && input===active) || cheatDirtyFields.has(key);
    if(!skip('hp', cheatInputs.hp)) cheatInputs.hp.value = player ? Math.floor(player.hp) : 0;
    if(!skip('maxHp', cheatInputs.maxHp)) cheatInputs.maxHp.value = player ? Math.floor(player.maxHp) : 0;
    if(!skip('damage', cheatInputs.damage)) cheatInputs.damage.value = player ? player.baseDamage.toFixed(2) : '0';
    if(!skip('speed', cheatInputs.speed)) cheatInputs.speed.value = player ? Math.round(player.speed) : 0;
    const rate = player && player.fireInterval>0 ? (1000/player.fireInterval) : 0;
    if(!skip('firerate', cheatInputs.firerate)) cheatInputs.firerate.value = rate ? rate.toFixed(2) : '0';
    if(!skip('tearSpeed', cheatInputs.tearSpeed)) cheatInputs.tearSpeed.value = player ? Math.round(player.tearSpeed) : 0;
    if(!skip('bombs', cheatInputs.bombs)) cheatInputs.bombs.value = player ? Math.floor(player.bombs) : 0;
    if(!skip('keys', cheatInputs.keys)) cheatInputs.keys.value = player ? Math.floor(player.keys) : 0;
    if(!skip('coins', cheatInputs.coins)) cheatInputs.coins.value = player ? Math.floor(player.coins) : 0;
  }
  function applyCheatStats(){
    if(!player) return;
    const maxHpCap = player.maxHpCap || 20;
    const newMax = clamp(Math.floor(Number(cheatInputs.maxHp.value)||player.maxHp), 1, maxHpCap);
    const newHp = clamp(Math.floor(Number(cheatInputs.hp.value)||player.hp), 0, newMax);
    const baseDamage = Number(cheatInputs.damage.value);
    const moveSpeed = Number(cheatInputs.speed.value);
    const fireRate = Number(cheatInputs.firerate.value);
    const tearSpeed = Number(cheatInputs.tearSpeed.value);
    player.maxHp = newMax;
    player.hp = newHp;
    if(Number.isFinite(baseDamage) && baseDamage>=0){ player.baseDamage = baseDamage; }
    if(Number.isFinite(moveSpeed) && moveSpeed>=0){ player.speed = moveSpeed; }
    if(Number.isFinite(fireRate) && fireRate>0){
      player.fireInterval = 1000 / fireRate;
      player.fireCd = Math.min(player.fireCd, player.fireInterval);
    }
    if(Number.isFinite(tearSpeed) && tearSpeed>0){ player.tearSpeed = tearSpeed; }
    if(player.hp>player.maxHp) player.hp = player.maxHp;
    player.recalculateDamage();
    clearCheatDirty('hp','maxHp','damage','speed','firerate','tearSpeed');
    syncCheatPanel();
  }
  function applyCheatResources(){
    if(!player) return;
    const bombs = clamp(Math.floor(Number(cheatInputs.bombs.value)||player.bombs), 0, 99);
    const keys = clamp(Math.floor(Number(cheatInputs.keys.value)||player.keys), 0, 99);
    const coins = clamp(Math.floor(Number(cheatInputs.coins.value)||player.coins), 0, 99);
    player.bombs = bombs;
    player.keys = keys;
    player.coins = coins;
    player.recalculateDamage();
    clearCheatDirty('bombs','keys','coins');
    syncCheatPanel();
  }
  function giveItemByCheat(){
    if(!cheatItemResult) return;
    const resetColor = ()=>{ cheatItemResult.style.color = 'var(--muted)'; };
    resetColor();
    if(!player){
      cheatItemResult.textContent = '请先进入游戏后再使用道具召唤。';
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const raw = cheatItemIdInput ? String(cheatItemIdInput.value).trim() : '';
    if(!raw){
      cheatItemResult.textContent = '请输入道具编号。';
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const numeric = Math.floor(Number(raw));
    if(!Number.isFinite(numeric) || numeric<1){
      cheatItemResult.textContent = '编号无效，请输入正整数。';
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const base = getItemByNumericId(numeric);
    if(!base){
      cheatItemResult.textContent = `未找到编号为 ${numeric} 的道具。`;
      cheatItemResult.style.color = 'var(--danger)';
      return;
    }
    const item = cloneItemData(base);
    if(typeof item.apply === 'function'){ item.apply(player); }
    if(player && !player.items.includes(item.name)){ player.items.push(item.name); }
    registerItemDiscovery(item);
    player.recalculateDamage();
    runtime.itemPickupName = item.name;
    runtime.itemPickupDesc = item.description || '';
    runtime.itemPickupTimer = 2.4;
    cheatItemResult.textContent = `已获得「${item.name}」`;  
    cheatItemResult.style.color = 'var(--accent)';
    syncCheatPanel();
  }
  if(cheatToggle && cheatPanelNode){
    cheatToggle.addEventListener('click', ()=>{
      cheatPanelNode.classList.toggle('show');
      cheatToggle.classList.toggle('active', cheatPanelNode.classList.contains('show'));
      const isOpen = cheatPanelNode.classList.contains('show');
      cheatToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      if(isOpen){
        syncCheatPanel();
      }else{
        clearCheatDirty();
      }
    });
  }
  cheatStatsBtn?.addEventListener('click', applyCheatStats);
  cheatResBtn?.addEventListener('click', applyCheatResources);
  cheatGiveItemBtn?.addEventListener('click', giveItemByCheat);
  cheatItemIdInput?.addEventListener('keydown', (ev)=>{
    if(ev.key==='Enter'){ ev.preventDefault(); giveItemByCheat(); }
  });
  cheatItemIdInput?.addEventListener('input', ()=>{
    if(cheatItemResult){
      cheatItemResult.textContent = '';
      cheatItemResult.style.color = 'var(--muted)';
    }
  });

  function createOverlayManager(mapping){
    const entries = Object.entries(mapping).filter(([,node])=>node);
    return {
      setActive(target){
        for(const [key,node] of entries){ node.classList.toggle('show', key===target); }
      },
      clear(){ for(const [,node] of entries){ node.classList.remove('show'); } }
    };
  }

  function createVirtualKeyboard({panel, toggle, onKeyDown, onKeyUp}){
    if(!panel || !toggle || typeof onKeyDown !== 'function' || typeof onKeyUp !== 'function') return null;
    const layout = [
      {type:'movement', keys:[null,{label:'W', code:'KeyW', hold:true},null]},
      {type:'movement', keys:[
        {label:'A', code:'KeyA', hold:true},
        {label:'S', code:'KeyS', hold:true},
        {label:'D', code:'KeyD', hold:true},
      ]},
      {type:'arrows', keys:[null,{label:'↑', code:'ArrowUp', hold:true},null]},
      {type:'arrows', keys:[
        {label:'←', code:'ArrowLeft', hold:true},
        {label:'↓', code:'ArrowDown', hold:true},
        {label:'→', code:'ArrowRight', hold:true},
      ]},
      {type:'actions', keys:[
        {label:'E', code:'KeyE', tap:true},
        {label:'F', code:'KeyF', tap:true},
        {label:'R', code:'KeyR', tap:true},
        {label:'P', code:'KeyP', tap:true},
      ]},
      {type:'system', keys:[
        {label:'Enter', code:'Enter', tap:true, span:3, className:'small'},
      ]},
    ];

    panel.innerHTML = '';
    const activeHoldButtons = new Map();
    const pointerHold = new Map();

    function releaseHold(code){
      if(!code) return;
      onKeyUp(code);
      const btn = activeHoldButtons.get(code);
      if(btn){
        btn.classList.remove('active');
        activeHoldButtons.delete(code);
      }
    }

    function releaseAll(){
      for(const code of Array.from(activeHoldButtons.keys())){
        releaseHold(code);
      }
      pointerHold.clear();
    }

    for(const row of layout){
      const rowEl = document.createElement('div');
      rowEl.className = 'virtual-kb-row';
      rowEl.dataset.type = row.type;
      for(const key of row.keys){
        if(!key){
          const spacer = document.createElement('div');
          spacer.className = 'virtual-kb-spacer';
          rowEl.appendChild(spacer);
          continue;
        }
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = key.label;
        btn.dataset.code = key.code;
        if(key.className) btn.classList.add(key.className);
        if(key.span){ btn.style.gridColumn = `span ${key.span}`; }
        btn.addEventListener('selectstart', (e)=> e.preventDefault());
        btn.addEventListener('contextmenu', (e)=> e.preventDefault());
        btn.addEventListener('pointerdown', (e)=>{
          e.preventDefault();
          btn.setPointerCapture?.(e.pointerId);
          if(key.hold){
            if(!activeHoldButtons.has(key.code)){
              onKeyDown(key.code);
            }
            btn.classList.add('active');
            activeHoldButtons.set(key.code, btn);
            pointerHold.set(e.pointerId, key.code);
          } else {
            onKeyDown(key.code);
            btn.classList.add('active');
            setTimeout(()=>{
              btn.classList.remove('active');
            }, 120);
            setTimeout(()=>{
              onKeyUp(key.code);
            }, 50);
          }
        });
        const end = (e)=>{
          if(!pointerHold.has(e.pointerId)) return;
          const code = pointerHold.get(e.pointerId);
          pointerHold.delete(e.pointerId);
          releaseHold(code);
        };
        btn.addEventListener('pointerup', end);
        btn.addEventListener('pointercancel', end);
        btn.addEventListener('lostpointercapture', (e)=>{
          if(pointerHold.has(e.pointerId)){
            const code = pointerHold.get(e.pointerId);
            pointerHold.delete(e.pointerId);
            releaseHold(code);
          }
        });
        btn.addEventListener('pointerleave', (e)=>{
          if(pointerHold.has(e.pointerId)){
            const code = pointerHold.get(e.pointerId);
            pointerHold.delete(e.pointerId);
            releaseHold(code);
          }
        });
        rowEl.appendChild(btn);
      }
      panel.appendChild(rowEl);
    }

    panel.setAttribute('aria-hidden', 'true');
    toggle.setAttribute('aria-expanded', 'false');
    panel.addEventListener('contextmenu', (e)=> e.preventDefault());

    function hide(){
      panel.classList.remove('show');
      panel.setAttribute('aria-hidden', 'true');
      toggle.classList.remove('active');
      toggle.setAttribute('aria-expanded', 'false');
      releaseAll();
    }
    function show(){
      panel.classList.add('show');
      panel.setAttribute('aria-hidden', 'false');
      toggle.classList.add('active');
      toggle.setAttribute('aria-expanded', 'true');
    }

    toggle.addEventListener('click', ()=>{
      if(panel.classList.contains('show')) hide();
      else show();
    });

    return {
      releaseAll,
      hide,
      show,
    };
  }

  // DPR 缩放（保持内部 800x600 逻辑坐标）
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fitCanvasToCss(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = CONFIG.roomW * dpr;
    canvas.height = CONFIG.roomH * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvasToCss();
  window.addEventListener('resize', fitCanvasToCss);

  // ======= 输入 =======
  function isTypingTarget(event){
    const target = event && event.target;
    if(!target) return false;
    const tag = target.tagName;
    if(tag==='INPUT' || tag==='TEXTAREA' || tag==='SELECT') return true;
    return !!target.isContentEditable;
  }

  const keys = new Set();
  function processKeyDown(code){
    const firstPress = !keys.has(code);
    keys.add(code);
    if(!firstPress) return;
    if(state===STATE.MENU && code==='Enter') startGame();
    if(state===STATE.PLAY && code==='KeyP') togglePause();
    if(state===STATE.PAUSE && code==='KeyP') togglePause();
    if(state===STATE.OVER && code==='Enter') showMenu();
    if((state===STATE.PLAY || state===STATE.PAUSE || state===STATE.OVER) && code==='KeyR') startGame();
    if(state===STATE.PLAY && code==='KeyE') placeBomb();
    if(state===STATE.PLAY && code==='KeyF') attemptPurchase();
  }
  function processKeyUp(code){
    keys.delete(code);
  }
  window.addEventListener('keydown', (e)=>{
    if(isTypingTarget(e)) return;
    const block = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'];
    if(block.includes(e.code)) e.preventDefault();
    processKeyDown(e.code);
  });
  window.addEventListener('keyup', (e)=> processKeyUp(e.code));

  const virtualKbToggle = document.getElementById('vk-toggle');
  const virtualKbPanel = document.getElementById('virtual-kb');
  const virtualKeyboard = createVirtualKeyboard({
    panel: virtualKbPanel,
    toggle: virtualKbToggle,
    onKeyDown: processKeyDown,
    onKeyUp: processKeyUp,
  });
  if(virtualKeyboard){
    window.addEventListener('blur', ()=> virtualKeyboard.releaseAll());
  }

  // ======= 游戏状态 =======
  const overlayMenu = document.getElementById('menu');
  const overlayPaused = document.getElementById('paused');
  const overlayOver = document.getElementById('gameover');
  const overlayManager = createOverlayManager({ menu: overlayMenu, paused: overlayPaused, over: overlayOver });
  document.getElementById('startBtn').addEventListener('click', (e)=>{e.preventDefault(); startGame();});

  const STATE = { MENU:0, PLAY:1, PAUSE:2, OVER:3 };
  let state = STATE.MENU;

  function showMenu(){ state=STATE.MENU; overlayManager.setActive('menu'); }
  function togglePause(){
    if(state===STATE.PLAY){ state=STATE.PAUSE; overlayManager.setActive('paused'); }
    else if(state===STATE.PAUSE){ state=STATE.PLAY; overlayManager.clear(); lastTime = performance.now(); }
  }
  function gameOver(){ state=STATE.OVER; overlayManager.setActive('over'); }

  // ======= 地图/房间生成 =======
  class Room{
    constructor(i,j){
      this.i=i; this.j=j;
      this.doors={up:false,down:false,left:false,right:false};
      this.cleared=false; this.visited=false; this.discovered=false;
      this.enemies=[]; this.pickups=[];
      this.obstacles=[]; this.obstaclesGenerated=false;
      this.bombs=[];
      this.isBoss=false; this.bossEntity=null; this.bossDefeated=false; this.bossName=''; this.introPlayed=false; this.bossId='idol';
      this.isItemRoom=false; this.itemData=null; this.itemClaimed=false; this.itemSpawned=false;
      this.isShop=false; this.shopInventory=[]; this.shopPrepared=false; this.locked=false;
      this.isSafeRoom=false;
      this.portal=null;
    }
    center(){ return {x: CONFIG.roomW/2, y: CONFIG.roomH/2}; }
    spawnEnemies(depth){
      this.ensureObstacles();
      if(this.isSafeRoom){
        this.enemies = [];
        this.cleared = true;
        return this.enemies;
      }
      if(this.isItemRoom){
        this.enemies = [];
        this.cleared = true;
        this.ensureItem();
        return this.enemies;
      }
      if(this.isShop){
        this.prepareShop();
        this.enemies = [];
        this.cleared = true;
        return this.enemies;
      }
      if(this.isBoss){
        if(this.bossDefeated){ this.enemies = []; return this.enemies; }
        this.portal = null;
        if(!this.bossEntity || this.bossEntity.dead){
          const c = this.center();
          this.bossEntity = makeBoss(c, this);
        }
        this.enemies = [this.bossEntity];
        this.cleared = false;
        return this.enemies;
      }
      // 按深度稍微增加数量
      const baseCount = Math.floor(randRange(CONFIG.enemy.spawnMin, CONFIG.enemy.spawnMax+1) + (depth*0.3));
      const limit = CONFIG.enemy.maxPerRoom || baseCount;
      const n = Math.max(1, Math.min(limit, baseCount));
      this.enemies = [];
      for(let k=0;k<n;k++){
        const t = rollEnemyType(depth);
        const radius = ENEMY_SPAWN_RADIUS[t] || CONFIG.player.radius;
        const pos = this.findSpawnPosition(radius);
        this.enemies.push(makeEnemy(t, pos, depth));
      }
      return this.enemies;
    }
    ensureItem(){
      if(!this.isItemRoom || this.itemClaimed) return;
      if(!this.itemData){ this.itemData = rollItem(); }
      if(this.itemSpawned) return;
      const c = this.center();
      this.pickups = this.pickups.filter(p=>p.type!=='item');
      this.pickups.push(makeItemPickup(c.x, c.y, this));
      this.itemSpawned = true;
    }
    ensureObstacles(){
      if(this.obstaclesGenerated) return;
      this.obstaclesGenerated = true;
      if(this.isBoss || this.isItemRoom || this.isShop) return;
      const targetClusters = Math.floor(randRange(CONFIG.obstacles.min, CONFIG.obstacles.max+1));
      const tileSize = CONFIG.player.radius * 2 * CONFIG.obstacles.tileSizePlayerRatio;
      const created=[];
      let clustersPlaced = 0;
      let tries=0;
      while(clustersPlaced < targetClusters && tries < 220){
        tries++;
        const maxTiles = Math.max(1, CONFIG.obstacles.maxTiles|0);
        const isHidden = rand() < CONFIG.obstacles.hiddenChance;
        let tilesX = 1;
        let tilesY = 1;
        if(isHidden){
          tilesX = 1;
          tilesY = 1;
        } else {
          const baseX = Math.max(1, Math.floor(randRange(1, maxTiles+1)));
          const baseY = Math.max(1, Math.floor(randRange(1, maxTiles+1)));
          const emphasizeLarge = rand() < 0.6;
          tilesX = emphasizeLarge ? Math.max(2, baseX) : baseX;
          tilesY = emphasizeLarge ? Math.max(2, baseY) : baseY;
          if(rand() < 0.4){
            const square = Math.max(2, Math.floor(randRange(2, Math.min(maxTiles, 4)+1)));
            tilesX = square;
            tilesY = Math.max(2, Math.floor(randRange(2, maxTiles+1)));
          }
          if(rand() < 0.5){ tilesX = Math.max(2, tilesX); }
          if(rand() < 0.5){ tilesY = Math.max(2, tilesY); }
          if(tilesX===1 && tilesY===1){
            if(rand()<0.5){ tilesX = Math.max(2, Math.floor(randRange(2, maxTiles+1))); }
            else { tilesY = Math.max(2, Math.floor(randRange(2, maxTiles+1))); }
          }
        }
        while(tilesX * tilesY > CONFIG.obstacles.maxClusterArea){
          if(tilesX>=tilesY && tilesX>1){ tilesX--; }
          else if(tilesY>1){ tilesY--; }
          else break;
        }
        if(tilesX * tilesY > CONFIG.obstacles.maxClusterArea){ continue; }
        const clusterW = tilesX * tileSize;
        const clusterH = tilesY * tileSize;
        if(clusterW >= CONFIG.roomW-120 || clusterH >= CONFIG.roomH-140) continue;
        const minX = 60;
        const maxX = CONFIG.roomW - 60 - clusterW;
        const minY = 70;
        const maxY = CONFIG.roomH - 70 - clusterH;
        if(maxX < minX || maxY < minY) continue;
        const x = maxX===minX ? minX : randRange(minX, maxX);
        const y = maxY===minY ? minY : randRange(minY, maxY);
        const clusterRect = {x, y, w:clusterW, h:clusterH};
        if(this.collidesDoorCorridor(clusterRect)) continue;
        const isThreeByThree = tilesX===3 && tilesY===3;
        const hollow = !isHidden && isThreeByThree && rand() < CONFIG.obstacles.hollowChance;
        const candidateTiles = [];
        let blocked=false;
        for(let ix=0; ix<tilesX && !blocked; ix++){
          for(let iy=0; iy<tilesY; iy++){
            if(hollow && ix===1 && iy===1) continue;
            const tile = {x: x + ix*tileSize, y: y + iy*tileSize, w: tileSize, h: tileSize};
            for(const existing of created){
              if(rectOverlap(existing, tile)){ blocked=true; break; }
            }
            if(blocked) break;
            candidateTiles.push(tile);
          }
        }
        if(blocked || !candidateTiles.length) continue;
        const parent = {
          hidden: isHidden,
          lootDropped: false,
          dropPos: {x: x + clusterW/2, y: y + clusterH/2},
          remaining: candidateTiles.length,
        };
        for(const tile of candidateTiles){
          tile.hp = 60;
          tile.destroyed = false;
          tile.parent = parent;
          tile.hidden = isHidden;
        }
        created.push(...candidateTiles);
        clustersPlaced++;
        if(hollow){
          const centerX = x + tileSize * 1.5;
          const centerY = y + tileSize * 1.5;
          spawnRandomDrop(this, centerX, centerY);
        }
      }
      this.obstacles = created;
    }
    collidesDoorCorridor(rect){
      const corridors = [];
      if(this.doors.up) corridors.push({x:CONFIG.roomW/2-60,y:0,w:120,h:180});
      if(this.doors.down) corridors.push({x:CONFIG.roomW/2-60,y:CONFIG.roomH-180,w:120,h:180});
      if(this.doors.left) corridors.push({x:0,y:CONFIG.roomH/2-70,w:180,h:140});
      if(this.doors.right) corridors.push({x:CONFIG.roomW-180,y:CONFIG.roomH/2-70,w:180,h:140});
      corridors.push({x:CONFIG.roomW/2-80,y:CONFIG.roomH/2-200,w:160,h:400});
      corridors.push({x:CONFIG.roomW/2-220,y:CONFIG.roomH/2-80,w:440,h:160});
      return corridors.some(c=>rectOverlap(c, rect));
    }
    findSpawnPosition(radius){
      const marginX = Math.max(60, radius + 36);
      const marginY = Math.max(64, radius + 40);
      const candidates = Math.max(20, (this.obstacles?.length||0) * 2 + 20);
      for(let attempt=0; attempt<candidates; attempt++){
        const x = randRange(marginX, CONFIG.roomW - marginX);
        const y = randRange(marginY, CONFIG.roomH - marginY);
        const circle = {x,y,r:radius};
        const rect = {x:x-radius, y:y-radius, w:radius*2, h:radius*2};
        if(this.collidesDoorCorridor(rect)) continue;
        let blocked = false;
        for(const obs of this.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(circle, obs)){ blocked=true; break; }
        }
        if(blocked) continue;
        for(const other of this.enemies){
          if(other?.dead) continue;
          if(dist(other, circle) < (other.r || radius) + radius + 6){ blocked=true; break; }
        }
        if(blocked) continue;
        return {x,y};
      }
      const center = this.center();
      const fallbackChecks = [
        {x:center.x, y:center.y},
        {x:center.x + radius*2.4, y:center.y},
        {x:center.x - radius*2.4, y:center.y},
        {x:center.x, y:center.y + radius*2.4},
        {x:center.x, y:center.y - radius*2.4},
      ];
      for(const pos of fallbackChecks){
        const x = clamp(pos.x, marginX, CONFIG.roomW - marginX);
        const y = clamp(pos.y, marginY, CONFIG.roomH - marginY);
        const circle = {x,y,r:radius};
        const rect = {x:x-radius, y:y-radius, w:radius*2, h:radius*2};
        if(this.collidesDoorCorridor(rect)) continue;
        let blocked = false;
        for(const obs of this.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(circle, obs)){ blocked = true; break; }
        }
        if(blocked) continue;
        for(const other of this.enemies){
          if(other?.dead) continue;
          if(dist(other, circle) < (other.r || radius) + radius + 6){ blocked = true; break; }
        }
        if(!blocked) return {x,y};
      }
      return {
        x: clamp(center.x, marginX, CONFIG.roomW - marginX),
        y: clamp(center.y, marginY, CONFIG.roomH - marginY)
      };
    }
    prepareShop(){
      if(!this.isShop || this.shopPrepared) return;
      this.shopPrepared = true;
      this.pickups = [];
      const slots = [
        {x:CONFIG.roomW*0.28, y:CONFIG.roomH*0.28},
        {x:CONFIG.roomW*0.5, y:CONFIG.roomH*0.26},
        {x:CONFIG.roomW*0.72, y:CONFIG.roomH*0.28},
        {x:CONFIG.roomW*0.32, y:CONFIG.roomH*0.64},
        {x:CONFIG.roomW*0.68, y:CONFIG.roomH*0.64},
      ];
      const shopItems = rollShopItems();
      let idx=0;
      for(const entry of shopItems){
        if(idx>=slots.length) break;
        const slot=slots[idx++];
        if(entry.type==='item'){
          this.pickups.push(makeShopPickup(slot.x, slot.y, entry, CONFIG.shop.itemPrice));
        } else {
          this.pickups.push(makeShopPickup(slot.x, slot.y, entry, CONFIG.shop.dropPrice));
        }
      }
      this.shopInventory = shopItems.map(entry=>{
        if(entry.type==='item'){
          return {type:'item', item:{...entry.item}};
        }
        return {...entry};
      });
    }
  }

  class Dungeon{
    constructor(){
      this.gridN = CONFIG.grid;
      // 创建空房
      this.rooms = Array.from({length:this.gridN}, ()=> Array.from({length:this.gridN},()=>null));
      const mid = Math.floor(this.gridN/2);
      const start = new Room(mid,mid);
      start.isSafeRoom = true;
      start.cleared = true;
      this.rooms[mid][mid] = start;
      this.start = start;
      const created = [start];
      const coords = [{i:mid,j:mid}];
      let attempts = 0;
      while(created.length < CONFIG.roomsToMake && attempts < CONFIG.roomsToMake*20){
        const baseIndex = Math.floor(rand()*coords.length);
        const base = coords[baseIndex];
        const baseRoom = this.rooms[base.i][base.j];
        const options = DIRS.map(dir=>({dir,ni:base.i+dir.di,nj:base.j+dir.dj}))
          .filter(opt=>opt.ni>=0 && opt.ni<this.gridN && opt.nj>=0 && opt.nj<this.gridN && !this.rooms[opt.ni][opt.nj]);
        if(!options.length){ attempts++; continue; }
        const choice = options[Math.floor(rand()*options.length)];
        const newRoom = new Room(choice.ni, choice.nj);
        this.rooms[choice.ni][choice.nj] = newRoom;
        created.push(newRoom);
        coords.push({i:choice.ni, j:choice.nj});
        baseRoom.doors[choice.dir.key] = true;
        newRoom.doors[choice.dir.opp] = true;
        attempts = 0;
      }
      this.allRooms = created;

      this.current = this.start;
      this.depth = 1;
      this.bounds = {minI:mid, maxI:mid, minJ:mid, maxJ:mid};

      // 指定 Boss 房 & 道具房
      this.bossRoom = this.setupBossRoom(mid);
      this.itemRooms = this.setupItemRooms(mid);
      this.shopRoom = this.setupShopRoom(mid);

      // 连接所有相邻房间的门，确保连通性
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r = this.rooms[i][j]; if(!r) continue;
          for(const dir of DIRS){
            const ni = i + dir.di, nj = j + dir.dj;
            if(ni<0 || nj<0 || ni>=this.gridN || nj>=this.gridN) continue;
            if(this.rooms[ni][nj]){
              r.doors[dir.key] = true;
              this.rooms[ni][nj].doors[dir.opp] = true;
            }
          }
        }
      }
    }

    setupBossRoom(mid){
      let farthest=null, maxDist=-1;
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j]; if(!r || (i===mid && j===mid)) continue;
          const d = Math.abs(i-mid)+Math.abs(j-mid);
          if(d>maxDist){ maxDist=d; farthest=r; }
        }
      }
      if(!farthest) return null;
      for(const dir of DIRS){
        const ni = farthest.i+dir.di;
        const nj = farthest.j+dir.dj;
        if(ni<0 || nj<0 || ni>=this.gridN || nj>=this.gridN) continue;
        if(this.rooms[ni][nj]) continue;
        const bossRoom = new Room(ni,nj);
        bossRoom.isBoss=true;
        const bossType = rollBossType();
        bossRoom.bossId = bossType.id;
        bossRoom.bossName = bossType.name;
        this.rooms[ni][nj]=bossRoom;
        farthest.doors[dir.key]=true;
        bossRoom.doors[dir.opp]=true;
        this.allRooms.push(bossRoom);
        return bossRoom;
      }
      // 如果周围无空位，则直接把最远房间作为 Boss 房
      farthest.isBoss=true;
      const fallbackType = rollBossType();
      farthest.bossId = fallbackType.id;
      farthest.bossName = fallbackType.name;
      return farthest;
    }

    setupItemRooms(mid){
      const items=[];
      const available=[];
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j];
          if(!r || r.isBoss || (i===mid && j===mid)) continue;
          const dist = Math.abs(i-mid)+Math.abs(j-mid);
          const options = DIRS.map(dir=>({dir,ni:i+dir.di,nj:j+dir.dj}))
            .filter(opt=>opt.ni>=0 && opt.nj>=0 && opt.ni<this.gridN && opt.nj<this.gridN && !this.rooms[opt.ni][opt.nj]);
          if(options.length){ available.push({room:r, options, dist}); }
        }
      }
      const need = Math.max(1, CONFIG.itemRooms|0);
      let placed = 0;
      while(placed<need && available.length){
        available.sort((a,b)=>b.dist-a.dist || rand()-0.5);
        const choice = available.shift();
        const target = choice.options[Math.floor(rand()*choice.options.length)];
        const itemRoom = new Room(target.ni, target.nj);
        itemRoom.isItemRoom = true;
        itemRoom.cleared = true;
        itemRoom.locked = true;
        this.rooms[target.ni][target.nj] = itemRoom;
        choice.room.doors[target.dir.key] = true;
        itemRoom.doors[target.dir.opp] = true;
        this.allRooms.push(itemRoom);
        items.push(itemRoom);
        placed++;
        for(let k=available.length-1;k>=0;k--){
          available[k].options = available[k].options.filter(opt=>!this.rooms[opt.ni][opt.nj]);
          if(!available[k].options.length) available.splice(k,1);
        }
      }
      if(placed===0){
        // 如果无法扩展，则挑选一个非 Boss 房间直接转为道具房
        for(let i=0;i<this.gridN;i++){
          for(let j=0;j<this.gridN;j++){
            const r=this.rooms[i][j];
            if(!r || r.isBoss || (i===mid && j===mid)) continue;
            r.isItemRoom = true;
            r.cleared = true;
            r.locked = true;
            items.push(r);
            placed=1;
            break;
          }
          if(placed) break;
        }
      }
      return items;
    }

    setupShopRoom(mid){
      const candidates=[];
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j];
          if(!r || r.isBoss || r.isItemRoom || (i===mid && j===mid)) continue;
          const dist = Math.abs(i-mid)+Math.abs(j-mid);
          const options = DIRS.map(dir=>({dir,ni:i+dir.di,nj:j+dir.dj}))
            .filter(opt=>opt.ni>=0 && opt.nj>=0 && opt.ni<this.gridN && opt.nj<this.gridN && !this.rooms[opt.ni][opt.nj]);
          if(options.length){ candidates.push({room:r, options, dist}); }
        }
      }
      candidates.sort((a,b)=>b.dist-a.dist || rand()-0.5);
      const choice = candidates[0];
      if(choice){
        const target = choice.options[Math.floor(rand()*choice.options.length)];
        const shop = new Room(target.ni, target.nj);
        shop.isShop = true;
        shop.cleared = true;
        shop.locked = true;
        this.rooms[target.ni][target.nj] = shop;
        choice.room.doors[target.dir.key] = true;
        shop.doors[target.dir.opp] = true;
        this.allRooms.push(shop);
        return shop;
      }
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j];
          if(!r || r.isBoss || r.isItemRoom || (i===mid && j===mid)) continue;
          r.isShop = true;
          r.cleared = true;
          r.locked = true;
          r.obstacles = [];
          r.obstaclesGenerated = true;
          return r;
        }
      }
      return null;
    }

    updateBounds(room){
      if(!room) return;
      this.bounds.minI = Math.min(this.bounds.minI, room.i);
      this.bounds.maxI = Math.max(this.bounds.maxI, room.i);
      this.bounds.minJ = Math.min(this.bounds.minJ, room.j);
      this.bounds.maxJ = Math.max(this.bounds.maxJ, room.j);
    }

    revealRoom(room){
      if(!room) return;
      room.discovered = true;
      this.updateBounds(room);
    }
  }
  function key(i,j){return `${i},${j}`}

  function weightedRoll(pool, options={}){
    const exclude = options.exclude;
    const excludeSet = Array.isArray(exclude) && exclude.length ? new Set(exclude) : null;
    let candidates = !excludeSet ? pool.slice() : pool.filter(item=>{
      if(!item || typeof item !== 'object') return false;
      if(item.slug==null) return true;
      return !excludeSet.has(item.slug);
    });
    if(!candidates.length){
      candidates = pool.slice();
    }
    candidates = candidates.filter(item=>item && typeof item === 'object');
    if(!candidates.length){
      const fallback = pool.find(item=>item && typeof item === 'object');
      if(fallback) return {...fallback};
      return {...(pool[0]||{})};
    }
    const weights = candidates.map(item=>{
      const w = Number(item.weight);
      return Number.isFinite(w) && w>0 ? w : 0;
    });
    const total = weights.reduce((sum,w)=>sum+w,0);
    let pick = total>0 ? rand()*total : rand()*candidates.length;
    for(let i=0;i<candidates.length;i++){
      const weight = total>0 ? weights[i] : 1;
      pick -= weight;
      if(pick<=0){
        return {...candidates[i]};
      }
    }
    return {...candidates[candidates.length-1]};
  }
  const recentItemHistory = [];
  const recentShopItemHistory = [];
  function rememberRecent(history, id, limit){
    if(!id) return;
    history.push(id);
    if(history.length>limit){ history.splice(0, history.length-limit); }
  }
  function rollItem(){
    const item = weightedRoll(ITEM_POOL, {exclude: recentItemHistory});
    rememberRecent(recentItemHistory, item.slug, 3);
    return item;
  }
  function rollShopItems(){
    const entries=[];
    const indices=[0,1,2,3,4];
    for(let i=indices.length-1;i>0;i--){ const j=Math.floor(rand()*(i+1)); [indices[i],indices[j]]=[indices[j],indices[i]]; }
    const itemCount = rand()<CONFIG.shop.doubleItemChance ? 2 : 1;
    const itemSlots = new Set(indices.slice(0,itemCount));
    for(let i=0;i<5;i++){
      if(itemSlots.has(i)){
        const shopItem = weightedRoll(SHOP_ITEM_POOL, {exclude: recentShopItemHistory});
        rememberRecent(recentShopItemHistory, shopItem.slug, 2);
        entries.push({type:'item', item: shopItem});
      } else {
        const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
        const amount = resType==='coin'?8:2;
        entries.push({type:'resource', resource:resType, amount});
      }
    }
    return entries;
  }
  function rollBossItem(){
    return weightedRoll(BOSS_ITEM_POOL);
  }

  function makeItemPickup(x,y,room){
    return {
      type:'item',
      x:clamp(x,80,CONFIG.roomW-80),
      y:clamp(y,90,CONFIG.roomH-90),
      r:18,
      item:room.itemData,
      room,
      vx:0,
      vy:0,
      solid:false
    };
  }
  function makeResourcePickup(type,x,y,amount){
    return {
      type,
      resource:type,
      amount:amount||1,
      x:clamp(x,70,CONFIG.roomW-70),
      y:clamp(y,80,CONFIG.roomH-80),
      r:12,
      vx:0,
      vy:0,
      solid:true,
      spawnGrace:CONFIG.pickupSpawnGrace,
    };
  }
  function makeShopPickup(x,y,entry,price){
    return {
      type:'shop',
      x:clamp(x,90,CONFIG.roomW-90),
      y:clamp(y,100,CONFIG.roomH-100),
      r:22,
      entry,
      price,
      purchased:false,
      vx:0,
      vy:0,
      solid:false
    };
  }
  function spawnRandomDrop(room,x,y){
    if(!room) return null;
    const roll = rand();
    let pickup = null;
    if(roll < 0.5){
      const heal = rand() < 0.25 ? 2 : 1;
      pickup = makeHeartPickup(x, y, heal);
    } else {
      const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
      let amount = 1;
      if(resType==='coin'){
        amount = rand() < 0.35 ? 5 : 3;
      } else if(rand() < 0.25){
        amount = 2;
      }
      pickup = makeResourcePickup(resType, x, y, amount);
    }
    room.pickups.push(pickup);
    return pickup;
  }

  function pickupItem(pickup){
    if(!pickup || !pickup.item) return;
    const item = pickup.item;
    if(typeof item.apply === 'function'){ item.apply(player); }
    if(player && !player.items.includes(item.name)){ player.items.push(item.name); }
    registerItemDiscovery(item);
    if(pickup.room){ pickup.room.itemClaimed = true; pickup.room.itemSpawned = false; }
    runtime.itemPickupName = item.name;
    runtime.itemPickupDesc = item.description || '';
    runtime.itemPickupTimer = 3.2;
  }
  function grantResource(type, amount){
    if(!player) return 0;
    const cap = 99;
    const amt = Math.max(0, Math.floor(amount||1));
    let prop = null;
    if(type==='bomb'){ prop='bombs'; }
    else if(type==='key'){ prop='keys'; }
    else if(type==='coin'){ prop='coins'; }
    if(!prop) return 0;
    const before = Math.max(0, player[prop]||0);
    const space = Math.max(0, cap - before);
    const gained = Math.min(space, amt);
    if(gained>0){
      player[prop] = clamp(before + gained, 0, cap);
      player.recalculateDamage();
    } else if(type==='coin'){ // 确保金币相关增益及时刷新
      player.recalculateDamage();
    }
    return gained;
  }

  function isPhysicalPickup(p){
    return !!(p && p.solid);
  }
  function ensurePickupMotion(p){
    if(typeof p.vx !== 'number') p.vx = 0;
    if(typeof p.vy !== 'number') p.vy = 0;
  }
  function pushPickup(p, origin, strength, options={}){
    if(!isPhysicalPickup(p) || !origin) return;
    if(!options.force && (p.spawnGrace||0) > 0) return;
    ensurePickupMotion(p);
    const dx = p.x - origin.x;
    const dy = p.y - origin.y;
    const d = Math.hypot(dx,dy) || 0.0001;
    const impulse = strength ?? 180;
    const nx = dx / d;
    const ny = dy / d;
    p.vx += nx * impulse;
    p.vy += ny * impulse;
    const speed = Math.hypot(p.vx, p.vy);
    const maxSpeed = 360;
    if(speed > maxSpeed){
      const scale = maxSpeed / speed;
      p.vx *= scale;
      p.vy *= scale;
    }
    const overlap = (p.r + (origin.r||0)) - d;
    if(overlap>0){
      p.x += nx * overlap;
      p.y += ny * overlap;
    }
  }
  function keepPickupInBounds(p){
    const marginX = p.r + 24;
    const marginY = p.r + 28;
    if(p.x < marginX){ p.x = marginX; if(p.vx<0) p.vx*=-0.35; }
    if(p.x > CONFIG.roomW - marginX){ p.x = CONFIG.roomW - marginX; if(p.vx>0) p.vx*=-0.35; }
    if(p.y < marginY){ p.y = marginY; if(p.vy<0) p.vy*=-0.35; }
    if(p.y > CONFIG.roomH - marginY){ p.y = CONFIG.roomH - marginY; if(p.vy>0) p.vy*=-0.35; }
  }
  function resolvePickupObstacles(p){
    if(!dungeon?.current) return;
    if(p.spawnGrace>0) return;
    for(const obs of dungeon.current.obstacles){
      if(obs.destroyed) continue;
      const push = circleRectResolve(p, obs);
      if(push){
        p.x += push.x;
        p.y += push.y;
        const len = Math.hypot(push.x, push.y) || 1;
        const nx = push.x/len;
        const ny = push.y/len;
        const dot = p.vx*nx + p.vy*ny;
        if(dot<0){
          p.vx -= dot*nx;
          p.vy -= dot*ny;
        }
      }
    }
  }
  function updatePickups(dt){
    const picks = dungeon?.current?.pickups;
    if(!picks) return;
    const decay = Math.exp(-dt*4.5);
    for(const p of picks){
      if(typeof p.spawnGrace === 'number' && p.spawnGrace>0){
        p.spawnGrace = Math.max(0, p.spawnGrace - dt);
      }
      if(!isPhysicalPickup(p)) continue;
      ensurePickupMotion(p);
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= decay;
      p.vy *= decay;
      if(Math.abs(p.vx) < 1e-2) p.vx = 0;
      if(Math.abs(p.vy) < 1e-2) p.vy = 0;
      keepPickupInBounds(p);
      if(!(p.spawnGrace>0)){
        resolvePickupObstacles(p);
      }
    }
  }
  function keepBombInBounds(bomb){
    const margin = bomb.r + 24;
    const marginY = bomb.r + 24;
    if(bomb.x < margin){ bomb.x = margin; if(bomb.vx<0) bomb.vx*=-0.4; }
    if(bomb.x > CONFIG.roomW - margin){ bomb.x = CONFIG.roomW - margin; if(bomb.vx>0) bomb.vx*=-0.4; }
    if(bomb.y < marginY){ bomb.y = marginY; if(bomb.vy<0) bomb.vy*=-0.4; }
    if(bomb.y > CONFIG.roomH - marginY){ bomb.y = CONFIG.roomH - marginY; if(bomb.vy>0) bomb.vy*=-0.4; }
  }
  function resolveBombObstacles(bomb){
    if(!dungeon?.current || bomb.exploded) return;
    for(const obs of dungeon.current.obstacles){
      if(obs.destroyed) continue;
      const push = circleRectResolve(bomb, obs);
      if(push){
        bomb.x += push.x;
        bomb.y += push.y;
        const len = Math.hypot(push.x, push.y) || 1;
        const nx = push.x/len;
        const ny = push.y/len;
        const dot = bomb.vx*nx + bomb.vy*ny;
        if(dot<0){
          bomb.vx -= dot*nx;
          bomb.vy -= dot*ny;
        }
      }
    }
  }

  // ======= 实体 =======
  class Player{
    constructor(x,y){
      this.x=x; this.y=y; this.r=CONFIG.player.radius; this.speed=CONFIG.player.speed;
      this.maxHpCap = 20;
      this.maxHp = Math.min(CONFIG.player.hp, this.maxHpCap);
      this.hp = this.maxHp; this.ifr=0; // 无敌帧
      this.fireCd = 0; this.fireInterval = CONFIG.player.fireCd;
      this.tearSpeed=CONFIG.player.tearSpeed; this.tearLife=CONFIG.player.tearLife;
      this.baseDamage = 1;
      this.damageMultiplier = 1;
      this.damage = 1;
      this.items=[];
      this.bombs = CONFIG.resources.bombStart;
      this.keys = CONFIG.resources.keyStart;
      this.coins = CONFIG.resources.coinStart;
      this.bombCooldown = 0;
      this.knockVel = {x:0,y:0};
      this.knockTimer = 0;
      this.flying = false;
      this.canPierceObstacles = false;
      this.effects = {bloodPower:false, moneyPower:false, despairPower:false};
      this.moveDir = {x:0,y:0};
      this.lastDisplacement = {x:0,y:0};
      this.lastVelocity = {x:0,y:0};
      this.vel = {x:0,y:0};
      this.moveFriction = CONFIG.player.friction ?? 3.15;
      this.accelFactor = CONFIG.player.accelFactor ?? 1.0;
      this.maxSpeedScale = CONFIG.player.maxSpeedScale ?? 1.1;
    }
    update(dt){
      this.bombCooldown = Math.max(0, this.bombCooldown - dt);
      const startX = this.x;
      const startY = this.y;
      const mv = {x:0,y:0};
      if(keys.has('KeyW')) mv.y -= 1;
      if(keys.has('KeyS')) mv.y += 1;
      if(keys.has('KeyA')) mv.x -= 1;
      if(keys.has('KeyD')) mv.x += 1;
      const friction = (this.moveFriction ?? CONFIG.player.friction ?? 3.15);
      const accelFactor = (this.accelFactor ?? CONFIG.player.accelFactor ?? 1.0);
      const maxSpeedScale = (this.maxSpeedScale ?? CONFIG.player.maxSpeedScale ?? 1.1);
      const decay = Math.exp(-friction * dt);
      this.vel.x *= decay;
      this.vel.y *= decay;
      const len = Math.hypot(mv.x,mv.y);
      if(len>0){
        const nx = mv.x/len;
        const ny = mv.y/len;
        this.moveDir.x = nx;
        this.moveDir.y = ny;
        const accel = this.speed * friction * accelFactor;
        this.vel.x += nx * accel * dt;
        this.vel.y += ny * accel * dt;
      } else {
        const vmag = Math.hypot(this.vel.x, this.vel.y);
        if(vmag>1e-3){
          this.moveDir.x = this.vel.x / vmag;
          this.moveDir.y = this.vel.y / vmag;
        } else {
          this.moveDir.x = 0;
          this.moveDir.y = 0;
        }
      }
      const maxSpeed = this.speed * maxSpeedScale;
      const curSpeed = Math.hypot(this.vel.x, this.vel.y);
      if(curSpeed > maxSpeed){
        const scale = maxSpeed / curSpeed;
        this.vel.x *= scale;
        this.vel.y *= scale;
      }
      this.x += this.vel.x * dt;
      this.y += this.vel.y * dt;
      if(this.knockTimer>0){
        this.x += this.knockVel.x * dt;
        this.y += this.knockVel.y * dt;
        this.knockVel.x *= 0.86;
        this.knockVel.y *= 0.86;
        this.knockTimer = Math.max(0, this.knockTimer - dt);
      }
      // 边界
      const minX = 30;
      const maxX = CONFIG.roomW - 30;
      const minY = 30;
      const maxY = CONFIG.roomH - 30;
      if(this.x < minX){ if(this.vel.x < 0) this.vel.x = 0; this.x = minX; }
      if(this.x > maxX){ if(this.vel.x > 0) this.vel.x = 0; this.x = maxX; }
      if(this.y < minY){ if(this.vel.y < 0) this.vel.y = 0; this.y = minY; }
      if(this.y > maxY){ if(this.vel.y > 0) this.vel.y = 0; this.y = maxY; }
      this.ifr = Math.max(0, this.ifr - dt);
      this.fireCd = Math.max(0, this.fireCd - dt*1000);

      // 射击（方向键）
      let sx=0, sy=0;
      if(keys.has('ArrowUp')) sy -= 1;
      if(keys.has('ArrowDown')) sy += 1;
      if(keys.has('ArrowLeft')) sx -= 1;
      if(keys.has('ArrowRight')) sx += 1;
      let shotDir = null;
      if((sx||sy) && this.fireCd<=0){
        const l = Math.hypot(sx,sy)||1;
        shotDir = {x: sx/l, y: sy/l};
        this.fireCd = this.fireInterval;
      }
      const preResolveX = this.x;
      const preResolveY = this.y;
      resolveEntityObstacles(this);
      if(this.x!==preResolveX || this.y!==preResolveY){
        const corrX = this.x - preResolveX;
        const corrY = this.y - preResolveY;
        const corrLen = Math.hypot(corrX, corrY);
        if(corrLen>1e-6){
          const nx = corrX / corrLen;
          const ny = corrY / corrLen;
          const dot = this.vel.x * nx + this.vel.y * ny;
          if(dot<0){
            this.vel.x -= dot * nx;
            this.vel.y -= dot * ny;
          }
        }
      }
      const dx = this.x - startX;
      const dy = this.y - startY;
      const lvx = dt>0 ? dx/dt : 0;
      const lvy = dt>0 ? dy/dt : 0;
      this.lastDisplacement.x = dx;
      this.lastDisplacement.y = dy;
      this.lastVelocity.x = lvx;
      this.lastVelocity.y = lvy;
      if(shotDir){
        const combatCfg = CONFIG.combat || {};
        const carry = combatCfg.shotCarry ?? combatCfg.shotInertia ?? 0;
        const forwardScale = combatCfg.shotForwardBoost ?? 0;
        const lateralScale = combatCfg.shotLateralInfluence ?? 0;
        const forwardSpeed = lvx * shotDir.x + lvy * shotDir.y;
        let dirX = shotDir.x;
        let dirY = shotDir.y;
        if(lateralScale>0){
          const px = lvx - forwardSpeed * shotDir.x;
          const py = lvy - forwardSpeed * shotDir.y;
          const lateralSpeed = Math.hypot(px, py);
          if(lateralSpeed>1e-4){
            const refSpeed = maxSpeed>0 ? maxSpeed : lateralSpeed;
            let influence = lateralScale * (lateralSpeed / refSpeed);
            influence = clamp(influence, 0, 0.85);
            const inv = 1 / lateralSpeed;
            dirX += px * inv * influence;
            dirY += py * inv * influence;
            const dlen = Math.hypot(dirX, dirY) || 1;
            dirX /= dlen;
            dirY /= dlen;
          }
        }
        let baseSpeed = this.tearSpeed;
        if(forwardScale!==0){
          const boost = forwardSpeed * forwardScale;
          baseSpeed = Math.max(40, baseSpeed + boost);
        }
        let vx = dirX * baseSpeed;
        let vy = dirY * baseSpeed;
        if(carry!==0){
          vx += lvx * carry;
          vy += lvy * carry;
        }
        runtime.bullets.push(new Bullet(this.x, this.y, vx, vy, this.tearLife, this.damage, this.canPierceObstacles));
      }
      this.recalculateDamage();
    }
    hurt(dmg){
      if(this.ifr>0) return;
      this.hp = Math.max(0, this.hp - dmg);
      this.ifr = 1.0;
      if(this.hp<=0) gameOver();
      this.recalculateDamage();
    }
    addDamage(amount){
      this.baseDamage = +(this.baseDamage + amount).toFixed(2);
      this.recalculateDamage();
    }
    adjustMaxHp(delta){
      if(!Number.isFinite(delta)) return;
      const prev = this.maxHp;
      this.maxHp = clamp(prev + delta, 1, this.maxHpCap);
      if(this.hp > this.maxHp){
        this.hp = this.maxHp;
      } else if(delta>0){
        const diff = this.maxHp - prev;
        if(diff>0) this.hp = Math.min(this.maxHp, this.hp + diff);
      }
      this.recalculateDamage();
    }
    applyImpulse(dx,dy,strength){
      const len = Math.hypot(dx,dy) || 1;
      const power = strength || CONFIG.bomb.knock;
      this.knockVel.x += (dx/len) * power;
      this.knockVel.y += (dy/len) * power;
      this.knockTimer = 0.25;
    }
    recalculateDamage(){
      let dmg = this.baseDamage;
      if(this.effects.bloodPower){ dmg += this.hp * 0.3; }
      if(this.effects.moneyPower){ dmg += this.coins * 0.05; }
      if(this.effects.despairPower){ const missing = this.maxHp - this.hp; dmg += missing * 0.6; }
      this.damage = +(Math.max(0.4, dmg) * this.damageMultiplier).toFixed(2);
    }
  }

  const TEAR_RADIUS_BASE = 5;
  const TEAR_RADIUS_GROWTH = 3.2;
  function calcTearRadius(damage){
    // 参考以撒的结合的弹丸成长：使用平方根降低增长曲线的坡度，避免数值过激
    const dmg = Math.max(0.25, damage);
    return TEAR_RADIUS_BASE + TEAR_RADIUS_GROWTH * (Math.sqrt(dmg) - 1);
  }

  class Bullet{
    constructor(x,y,vx,vy,life,damage=1,pierce=false){
      this.x=x;
      this.y=y;
      this.vx=vx;
      this.vy=vy;
      this.life=life;
      this.damage=damage;
      this.alive=true;
      this.r=calcTearRadius(damage);
      this.pierceObstacles = pierce;
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
      if(this.life<=0) this.alive=false;
      if(this.x<0||this.x>CONFIG.roomW||this.y<0||this.y>CONFIG.roomH) this.alive=false;
      if(!this.pierceObstacles){
        for(const obs of dungeon.current.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(this, obs)){ this.alive=false; break; }
        }
      }
    }
    draw(){
      ctx.beginPath();
      ctx.fillStyle = '#a6e3ff';
      ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  class Bomb{
    constructor(x,y){
      this.x=x;
      this.y=y;
      this.r=14;
      this.timer=CONFIG.bomb.fuse;
      this.exploded=false;
      this.explosionTimer=0;
      this.done=false;
      this.vx=0;
      this.vy=0;
      this.spawnGrace = CONFIG.bomb.spawnGrace ?? CONFIG.pickupSpawnGrace ?? 0;
    }
    update(dt){
      if(this.done) return;
      if(this.spawnGrace>0){ this.spawnGrace = Math.max(0, this.spawnGrace - dt); }
      if(this.exploded){
        this.explosionTimer = Math.max(0, this.explosionTimer - dt);
        if(this.explosionTimer<=0){ this.done=true; }
        return;
      }
      this.integrateMotion(dt);
      this.timer -= dt;
      if(this.timer<=0){ this.explode(); }
    }
    integrateMotion(dt){
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      const drag = Math.exp(-dt*4.2);
      this.vx *= drag;
      this.vy *= drag;
      if(Math.abs(this.vx) < 1e-2) this.vx = 0;
      if(Math.abs(this.vy) < 1e-2) this.vy = 0;
      keepBombInBounds(this);
      if(this.spawnGrace<=0){
        resolveBombObstacles(this);
      }
    }
    applyImpulse(dx,dy,strength){
      if(this.done || this.exploded) return;
      const len = Math.hypot(dx,dy) || 0.0001;
      const power = strength ?? CONFIG.bomb.knock;
      this.vx += (dx/len) * power;
      this.vy += (dy/len) * power;
      const speed = Math.hypot(this.vx, this.vy);
      const maxSpeed = 480;
      if(speed > maxSpeed){
        const scale = maxSpeed / speed;
        this.vx *= scale;
        this.vy *= scale;
      }
    }
    explode(){
      if(this.exploded) return;
      this.exploded=true;
      this.explosionTimer = 0.4;
      this.vx = 0;
      this.vy = 0;
      handleBombExplosion(dungeon.current, this);
    }
    draw(){
      if(this.exploded){
        const ratio = this.explosionTimer / 0.4;
        const radius = CONFIG.bomb.radius * (1 + (1-ratio)*0.2);
        ctx.save();
        ctx.globalAlpha = Math.max(0, ratio*0.7);
        const g = ctx.createRadialGradient(this.x,this.y,radius*0.15,this.x,this.y,radius);
        g.addColorStop(0,'#fff5');
        g.addColorStop(0.4,'#ffd5');
        g.addColorStop(1,'#ff4d');
        ctx.fillStyle=g;
        ctx.beginPath(); ctx.arc(this.x,this.y,radius,0,Math.PI*2); ctx.fill();
        ctx.globalAlpha = Math.max(0, ratio*0.9);
        ctx.strokeStyle='#ffe4';
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(this.x,this.y,radius*0.55,0,Math.PI*2); ctx.stroke();
        ctx.restore();
        return;
      }
      const progress = Math.max(0, CONFIG.bomb.fuse - this.timer);
      const freq = 2 + progress*6;
      const pulse = Math.sin(progress*freq*Math.PI) > 0 ? '#ff6b6b' : '#ffffff';
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = '#2f3345';
      ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = pulse;
      ctx.beginPath(); ctx.arc(0,0,this.r*0.7,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2f3345';
      ctx.fillRect(-2,-this.r*1.1,4,this.r*0.6);
      ctx.restore();
    }
  }

  function onObstacleDestroyed(room, obs){
    if(!room || !obs) return;
    const parent = obs.parent;
    if(parent && typeof parent.remaining === 'number'){
      parent.remaining = Math.max(0, parent.remaining - 1);
      if(parent.hidden && !parent.lootDropped && parent.remaining<=0){
        parent.lootDropped = true;
        const dropPos = parent.dropPos || {x: obs.x + obs.w/2, y: obs.y + obs.h/2};
        const dropX = clamp(dropPos.x, 70, CONFIG.roomW-70);
        const dropY = clamp(dropPos.y, 80, CONFIG.roomH-80);
        spawnRandomDrop(room, dropX, dropY);
        if(rand() < CONFIG.obstacles.hiddenItemChance){
          const item = rollItem();
          room.pickups.push({type:'item', x:clamp(dropX,80,CONFIG.roomW-80), y:clamp(dropY,90,CONFIG.roomH-90), r:18, item, vx:0, vy:0, solid:false});
        }
      }
    }
  }

  function handleBombExplosion(room, bomb){
    if(!room) return;
    const radius = CONFIG.bomb.radius;
    const circle = {x:bomb.x, y:bomb.y, r:radius};
    for(const enemy of room.enemies){
      if(enemy.dead) continue;
      const d = dist(bomb, enemy);
      if(d <= radius + enemy.r){
        if(typeof enemy.damage === 'function'){
          if(enemy.damage(CONFIG.bomb.damage)){ handleEnemyDeath(enemy, room); }
        }
        const len = Math.max(1, d);
        const push = (radius - Math.min(radius, d)) * 0.6;
        if(enemy.knock!==undefined){ enemy.knock = 0.35; }
        enemy.x += (enemy.x - bomb.x)/len * push;
        enemy.y += (enemy.y - bomb.y)/len * push;
        if(enemy.base){
          enemy.base.x += (enemy.base.x - bomb.x)/len * push;
          enemy.base.y += (enemy.base.y - bomb.y)/len * push;
        }
        if(enemy.vx!==undefined && enemy.vy!==undefined && enemy.state!=='charge'){
          enemy.vx += (enemy.x - bomb.x)/len * 160;
          enemy.vy += (enemy.y - bomb.y)/len * 160;
        }
      }
    }
    if(player){
      const dp = dist(player, bomb);
      if(dp <= radius + player.r){
        player.applyImpulse(player.x - bomb.x, player.y - bomb.y, CONFIG.bomb.knock);
        player.hurt(CONFIG.bomb.playerDamage);
      }
    }
    for(const obs of room.obstacles){
      if(obs.destroyed) continue;
      if(circleRectOverlap(circle, obs)){
        obs.destroyed = true;
        onObstacleDestroyed(room, obs);
      }
    }
    if(room.pickups){
      for(const drop of room.pickups){
        if(!isPhysicalPickup(drop)) continue;
        if(dist(drop, bomb) <= radius + drop.r){
          pushPickup(drop, bomb, CONFIG.bomb.knock * 1.45, {force:true});
          ensurePickupMotion(drop);
          drop.vx *= 1.25;
          drop.vy *= 1.25;
        }
      }
    }
    for(const other of room.bombs){
      if(other===bomb || other.done || other.exploded) continue;
      const db = dist(other, bomb);
      if(db <= radius + other.r){
        other.applyImpulse(other.x - bomb.x, other.y - bomb.y, CONFIG.bomb.knock * 1.1);
      }
    }
    for(const proj of runtime.enemyProjectiles){
      if(!proj.alive) continue;
      if(dist(proj, bomb) <= radius){ proj.alive=false; }
    }
  }

  const ENEMY_SPAWN_RADIUS = {
    chaser:12,
    orbiter:10,
    gasbag:14,
    tinyfly:8,
    elderfly:13,
    spider:16,
  };

  function rollEnemyType(depth){
    const weights = [
      {type:'chaser', w: 2.6},
      {type:'orbiter', w: 1.2 + depth*0.05},
      {type:'gasbag', w: 0.7 + depth*0.04},
      {type:'tinyfly', w: 0.6 + Math.max(0, depth-1)*0.05},
      {type:'elderfly', w: 0.75 + depth*0.06},
      {type:'spider', w: 0.65 + depth*0.07},
    ];
    const total = weights.reduce((sum, entry)=>sum+entry.w,0);
    let r = rand()*total;
    for(const entry of weights){
      r -= entry.w;
      if(r<=0) return entry.type;
    }
    return 'chaser';
  }

  function makeEnemy(type, pos, depth){
    const hp = Math.max(1, Math.round(CONFIG.enemy.baseHP + depth*0.3 + rand()*1.0));
    if(type==='chaser') return new EnemyChaser(pos.x,pos.y,hp);
    if(type==='orbiter') return new EnemyOrbiter(pos.x,pos.y,hp);
    if(type==='gasbag') return new EnemyGasbag(pos.x,pos.y, Math.max(hp+1, 3));
    if(type==='tinyfly') return new EnemyTinyFly(pos.x,pos.y, Math.max(1, Math.round(1 + depth*0.15)));
    if(type==='elderfly') return new EnemyElderFly(pos.x,pos.y, Math.max(hp, 3));
    if(type==='spider') return new EnemySpiderLeaper(pos.x,pos.y, Math.max(hp+1, 4));
    return new EnemyChaser(pos.x,pos.y,hp);
  }

  function makeBoss(pos, room){
    const bossId = room?.bossId || 'idol';
    let boss;
    if(bossId==='master'){
      boss = new EnemyBossMaster(pos.x, pos.y, room?.bossName || getBossMeta('master').name);
    } else {
      boss = new EnemyBoss(pos.x, pos.y, room?.bossName || getBossMeta('idol').name);
    }
    boss.room = room;
    return boss;
  }

  class EnemyChaser{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=12; this.hp=hp;
      this.speed = CONFIG.enemy.speed * randRange(0.9,1.2);
      this.knock=0;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.speed *= this.scaling.speed;
      this.aggression = this.scaling.aggression;
    }
    update(dt){
      const to = {x:player.x - this.x, y:player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1; to.x/=l; to.y/=l;
      // 受击后短暂击退
      if(this.knock>0){ this.x -= to.x * 220 * dt; this.y -= to.y * 220 * dt; this.knock-=dt; }
      else { this.x += to.x * this.speed * dt; this.y += to.y * this.speed * dt; }
      // 碰撞到玩家
      if(dist(this, player) < this.r + player.r){ player.hurt(1); this.knock = 0.2; }
      resolveEntityObstacles(this);
    }
    draw(){ drawBlob(this.x,this.y,this.r,'#ff9aa2','#ff6b6b'); }
    damage(d){ this.hp-=d; this.knock=0.15; if(this.hp<=0){ this.dead=true; return true; } return false; }
  }

  class EnemyOrbiter{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=10; this.hp=hp;
      this.t=rand()*Math.PI*2; this.base={x,y}; this.range=40+rand()*25;
      this.omega = 2+rand()*1.5; this.speed=40; this.flying=true;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.speed *= this.scaling.speed;
      this.omega *= this.scaling.aggression;
      this.aggression = this.scaling.aggression;
    }
    update(dt){
      this.t += this.omega*dt;
      this.x = this.base.x + Math.cos(this.t)*this.range;
      this.y = this.base.y + Math.sin(this.t)*this.range;
      // 慢慢靠近玩家（弱追踪）
      const dx = player.x - this.base.x; const dy = player.y - this.base.y;
      const l = Math.hypot(dx,dy)||1; this.base.x += (dx/l)*this.speed*dt*0.6; this.base.y += (dy/l)*this.speed*dt*0.6;
      if(dist(this, player) < this.r + player.r) player.hurt(1);
      resolveEntityObstacles(this);
    }
    draw(){ drawBlob(this.x,this.y,this.r,'#b4c7ff','#7aa2ff'); }
    damage(d){ this.hp-=d; if(this.hp<=0){ this.dead=true; return true; } return false; }
  }

  class EnemyGasbag{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=14; this.hp=hp;
      const cfg = CONFIG.enemy.gasbag;
      this.speed = cfg.speed * randRange(0.85,1.15);
      this.wanderAngle = rand()*Math.PI*2;
      this.wanderTimer = randRange(0.6,1.4);
      this.safeRadius = cfg.safeRadius;
      this.fuse = -1;
      this.flashTimer = 0;
      this.cooldown = 0;
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = false;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.speed *= this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.triggerCooldownBase = Math.max(0.25, cfg.triggerCooldown / this.aggression);
      this.triggerChance = Math.min(0.98, cfg.triggerChance * this.aggression);
      this.fuseDuration = Math.max(0.45, cfg.fuse / this.aggression);
    }
    startFuse(){
      if(this.fuse>0) return;
      this.fuse = this.fuseDuration;
      this.flashTimer = this.fuse;
    }
    detonate(){
      if(this.dead) return;
      this.dead = true;
      const cfg = CONFIG.enemy.gasbag;
      if(player && dist(this, player) < this.r + cfg.explosionRadius){
        player.hurt(1);
        player.applyImpulse(player.x - this.x, player.y - this.y, 180);
      }
      const room = dungeon?.current;
      if(room){
        const count = Math.floor(randRange(cfg.spawnMin, cfg.spawnMax+1));
        for(let i=0;i<count;i++){
          const ang = rand()*Math.PI*2;
          const rad = randRange(14, 38);
          const pos = {
            x: clamp(this.x + Math.cos(ang)*rad, 60, CONFIG.roomW-60),
            y: clamp(this.y + Math.sin(ang)*rad, 60, CONFIG.roomH-60)
          };
          queueEnemySpawn(makeEnemy('tinyfly', pos, dungeon.depth));
        }
        handleEnemyDeath(this, room);
      }
    }
    update(dt){
      if(this.dead) return;
      const cfg = CONFIG.enemy.gasbag;
      this.flashTimer = Math.max(0, this.flashTimer - dt);
      if(this.fuse>0){
        this.fuse -= dt;
        if(this.fuse<=0){ this.detonate(); return; }
      }
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.86;
        this.knockVy *= 0.86;
      } else {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const d = Math.hypot(dx,dy)||1;
        if(this.fuse<=0 && d < cfg.triggerRange){
          this.cooldown -= dt * this.aggression;
          if(this.cooldown<=0){
            if(rand() < Math.min(0.98, this.triggerChance)){ this.startFuse(); }
            this.cooldown = this.triggerCooldownBase;
          }
        } else {
          this.cooldown = Math.max(0, this.cooldown - dt*0.5*this.aggression);
        }
        if(d < this.safeRadius){
          this.x += (dx/d) * this.speed * dt;
          this.y += (dy/d) * this.speed * dt;
        } else {
          this.wanderTimer -= dt;
          if(this.wanderTimer<=0){
            this.wanderAngle = rand()*Math.PI*2;
            this.wanderTimer = randRange(0.6,1.4);
          }
          this.x += Math.cos(this.wanderAngle) * this.speed * 0.45 * dt;
          this.y += Math.sin(this.wanderAngle) * this.speed * 0.45 * dt;
        }
      }
      this.x = clamp(this.x, 46, CONFIG.roomW-46);
      this.y = clamp(this.y, 56, CONFIG.roomH-56);
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r){
        player.hurt(1);
        this.knock = 0.16;
        const vec = {x:this.x - player.x, y:this.y - player.y};
        const len = Math.hypot(vec.x,vec.y)||1;
        this.knockVx = (vec.x/len)*180;
        this.knockVy = (vec.y/len)*180;
      }
    }
    damage(d){
      if(this.dead) return false;
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.18;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*200;
      this.knockVy = (vec.y/len)*200;
      return false;
    }
    draw(){
      const telegraph = this.fuse>0;
      const base = telegraph ? '#ffd6a8' : '#fcd5ce';
      const edge = telegraph ? '#fb923c' : '#f973a6';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = '#2f1d38';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.25, -this.r*0.15, this.r*0.18, this.r*0.26, 0, 0, Math.PI*2);
      ctx.ellipse(this.r*0.25, -this.r*0.15, this.r*0.18, this.r*0.26, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      if(telegraph){
        ctx.save();
        ctx.globalAlpha = 0.65 + 0.3*Math.sin(performance.now()/80);
        ctx.strokeStyle = '#ffd29a';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r + 8, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }
  }

  class EnemyTinyFly{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=8; this.hp=hp;
      this.speed = CONFIG.enemy.tinyFly.speed * randRange(0.85,1.15);
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.flying = true;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.speed *= this.scaling.speed;
      this.aggression = this.scaling.aggression;
    }
    update(dt){
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.85;
        this.knockVy *= 0.85;
      } else {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const d = Math.hypot(dx,dy)||1;
        this.x += (dx/d) * this.speed * dt;
        this.y += (dy/d) * this.speed * dt;
      }
      this.x = clamp(this.x, 36, CONFIG.roomW-36);
      this.y = clamp(this.y, 40, CONFIG.roomH-40);
      resolveEntityObstacles(this);
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const wobble = Math.sin(performance.now()/120 + this.x*0.01)*1.2;
      drawBlob(this.x,this.y,this.r,'#fef08a','#facc15');
      ctx.save();
      ctx.translate(this.x,this.y - this.r*0.2);
      ctx.rotate(wobble*0.05);
      ctx.fillStyle = '#fde68aaa';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.8, -this.r*0.3, this.r*0.9, this.r*0.35, -0.6, 0, Math.PI*2);
      ctx.ellipse(this.r*0.8, -this.r*0.3, this.r*0.9, this.r*0.35, 0.6, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.12;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*140;
      this.knockVy = (vec.y/len)*140;
      return false;
    }
  }

  class EnemyElderFly{
    constructor(x,y,hp){
      this.x=x; this.y=y; this.r=13; this.hp=hp;
      const cfg = CONFIG.enemy.elderFly;
      this.speed = cfg.speed;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.speed *= this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.fireInterval = Math.max(0.7, cfg.fireInterval / this.aggression);
      this.telegraphWindow = Math.max(0.25, cfg.telegraph / this.aggression);
      this.fireTimer = randRange(this.telegraphWindow, this.fireInterval);
      this.projectileSpeed = cfg.projectileSpeed * this.scaling.speed;
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.charging = false;
      this.flying = true;
    }
    update(dt){
      const cfg = CONFIG.enemy.elderFly;
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.84;
        this.knockVy *= 0.84;
      } else {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        let mx=0, my=0;
        if(distLen < cfg.minRange){ mx = -dx/distLen; my = -dy/distLen; }
        else if(distLen > cfg.maxRange){ mx = dx/distLen; my = dy/distLen; }
        else { mx = -dy/distLen; my = dx/distLen; }
        this.x += mx * this.speed * dt;
        this.y += my * this.speed * dt;
      }
      this.x = clamp(this.x, 50, CONFIG.roomW-50);
      this.y = clamp(this.y, 54, CONFIG.roomH-54);
      resolveEntityObstacles(this);
      this.fireTimer -= dt * this.aggression;
      if(this.fireTimer <= 0){
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        const speed = this.projectileSpeed + rand()*50;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.8, 'tear'));
        this.fireTimer = this.fireInterval;
        this.charging = false;
      } else {
        this.charging = this.fireTimer <= this.telegraphWindow;
      }
      if(dist(this, player) < this.r + player.r){ player.hurt(1); }
    }
    draw(){
      const charging = this.charging;
      const base = charging ? '#fde68a' : '#dbeafe';
      const edge = charging ? '#f97316' : '#93c5fd';
      drawBlob(this.x,this.y,this.r,base,edge);
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.fillStyle = charging ? '#7f1d1d' : '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.3, -this.r*0.05, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.3, -this.r*0.05, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.18;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*150;
      this.knockVy = (vec.y/len)*150;
      return false;
    }
  }

  class EnemySpiderLeaper{
    constructor(x,y,hp){
      const cfg = CONFIG.enemy.spider;
      this.x=x; this.y=y; this.r=13; this.hp=hp;
      this.state='idle';
      this.cooldown = randRange(1.2, cfg.cooldown);
      this.telegraphTimer = 0;
      this.leapDuration = 0;
      this.leapElapsed = 0;
      this.leapStart = {x,y};
      this.leapEnd = {x,y};
      this.knock = 0;
      this.knockVx = 0;
      this.knockVy = 0;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.max(1, Math.round(this.hp * this.scaling.hp));
      this.aggression = this.scaling.aggression;
      this.cooldownBase = Math.max(0.6, cfg.cooldown / this.aggression);
      this.cooldown = Math.max(0.4, this.cooldown / this.aggression);
      this.telegraphDuration = Math.max(0.2, cfg.telegraph / this.aggression);
      this.leapSpeed = cfg.leapSpeed * this.scaling.speed;
    }
    beginLeap(){
      const cfg = CONFIG.enemy.spider;
      const targetX = clamp(player.x, 50, CONFIG.roomW-50);
      const targetY = clamp(player.y, 60, CONFIG.roomH-60);
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const distLen = Math.hypot(dx,dy)||1;
      const travel = Math.min(cfg.maxDistance, distLen);
      const nx = dx/distLen;
      const ny = dy/distLen;
      this.leapStart = {x:this.x, y:this.y};
      this.leapEnd = {
        x: clamp(this.x + nx*travel, 40, CONFIG.roomW-40),
        y: clamp(this.y + ny*travel, 46, CONFIG.roomH-46)
      };
      this.leapDuration = Math.max(0.2, travel / this.leapSpeed);
      this.leapElapsed = 0;
      this.state='leap';
    }
    update(dt){
      const cfg = CONFIG.enemy.spider;
      if(this.knock>0){
        this.x += this.knockVx * dt;
        this.y += this.knockVy * dt;
        this.knock -= dt;
        this.knockVx *= 0.85;
        this.knockVy *= 0.85;
        resolveEntityObstacles(this);
        return;
      }
      if(this.state==='idle'){
        this.cooldown -= dt * this.aggression;
        if(this.cooldown<=0){
          this.state='telegraph';
          this.telegraphTimer = this.telegraphDuration;
        }
      } else if(this.state==='telegraph'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.telegraphTimer<=0){
          this.beginLeap();
        }
      } else if(this.state==='leap'){
        this.leapElapsed = Math.min(this.leapDuration, this.leapElapsed + dt);
        const ratio = this.leapDuration>0 ? this.leapElapsed / this.leapDuration : 1;
        const ease = ratio<0.5 ? 2*ratio*ratio : -1 + (4 - 2*ratio)*ratio; // easeInOutQuad
        this.x = this.leapStart.x + (this.leapEnd.x - this.leapStart.x) * ease;
        this.y = this.leapStart.y + (this.leapEnd.y - this.leapStart.y) * ease;
        if(dist(this, player) < this.r + player.r){ player.hurt(1); }
        if(this.leapElapsed>=this.leapDuration){
          this.state='idle';
          this.cooldown = this.cooldownBase;
          this.x = this.leapEnd.x;
          this.y = this.leapEnd.y;
        }
      }
      if(this.state!=='leap'){ resolveEntityObstacles(this); }
      this.x = clamp(this.x, 36, CONFIG.roomW-36);
      this.y = clamp(this.y, 44, CONFIG.roomH-44);
    }
    getAltitude(){
      if(this.state!=='leap' || this.leapDuration<=0) return 0;
      const ratio = this.leapElapsed / this.leapDuration;
      return Math.sin(Math.PI * ratio);
    }
    damage(d){
      this.hp -= d;
      if(this.hp<=0){ this.dead=true; return true; }
      this.knock = 0.2;
      const vec = {x:this.x - player.x, y:this.y - player.y};
      const len = Math.hypot(vec.x,vec.y)||1;
      this.knockVx = (vec.x/len)*180;
      this.knockVy = (vec.y/len)*180;
      return false;
    }
    draw(){
      const altitude = this.getAltitude();
      ctx.save();
      ctx.globalAlpha = 0.35 + 0.25*altitude;
      ctx.fillStyle = '#0006';
      ctx.beginPath();
      ctx.ellipse(this.x, this.y + this.r*0.9, this.r*(1-altitude*0.35), this.r*0.6*(1-altitude*0.45), 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      const telegraphing = this.state==='telegraph';
      const base = telegraphing ? '#fed7aa' : '#cbd5f5';
      const edge = telegraphing ? '#f97316' : '#8b5cf6';
      drawBlob(this.x, this.y - altitude*this.r*0.8, this.r, base, edge);
      ctx.save();
      ctx.translate(this.x, this.y - altitude*this.r*0.8);
      ctx.fillStyle = '#1f2937';
      ctx.beginPath();
      ctx.arc(-this.r*0.35, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.35, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  class EnemyBoss{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=36;
      this.hp=70; this.maxHp=this.hp;
      this.name=name;
      this.state='idle';
      this.attackTimer=1.5; this.chargeTimer=0; this.recoverTimer=0;
      this.hitFlash=0; this.enraged=false;
      this.isBossEntity = true;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.round(this.hp * this.scaling.hp);
      this.maxHp = this.hp;
      this.speedScale = this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.attackTimer /= this.aggression;
    }
    update(dt){
      const drift = (40 + (this.enraged?25:0)) * this.speedScale;
      if(this.state==='charge'){
        this.chargeTimer -= dt * this.aggression;
        this.x += this.vx*dt; this.y += this.vy*dt;
        if(this.chargeTimer<=0){ this.state='recover'; this.recoverTimer=0.6 / this.aggression; }
      } else {
        const to = {x: player.x - this.x, y: player.y - this.y};
        const l = Math.hypot(to.x,to.y)||1;
        this.x += (to.x/l) * drift * dt * 0.55;
        this.y += (to.y/l) * drift * dt * 0.55;
        this.x += Math.cos(performance.now()/480) * 18 * dt;
        this.y += Math.sin(performance.now()/360) * 18 * dt;
        if(this.state==='recover'){
          this.recoverTimer -= dt * this.aggression;
          if(this.recoverTimer<=0) this.state='idle';
        }
      }
      this.x = clamp(this.x, 90, CONFIG.roomW-90);
      this.y = clamp(this.y, 110, CONFIG.roomH-110);
      if(dist(this, player) < this.r + player.r - 2){ player.hurt(1); }
      resolveEntityObstacles(this);

      if(this.hitFlash>0) this.hitFlash -= dt;
      if(!this.enraged && this.hp <= this.maxHp*0.55){
        this.enraged=true;
        this.attackTimer = Math.min(this.attackTimer, 1.1 / this.aggression);
      }

      this.attackTimer -= dt * this.aggression;
      if(this.attackTimer<=0){ this.chooseAttack(); }
    }
    chooseAttack(){
      const roll = rand();
      if(roll < 0.45){ this.sprayAttack(); this.attackTimer = (this.enraged ? 1.6 : 2.2) / this.aggression; }
      else if(roll < 0.75){ this.spawnMinions(); this.attackTimer = (this.enraged ? 2.0 : 2.6) / this.aggression; }
      else { this.chargeAttack(); this.attackTimer = (this.enraged ? 2.4 : 3.2) / this.aggression; }
    }
    sprayAttack(){
      const waves = this.enraged ? 3 : 2;
      for(let w=0; w<waves; w++){
        const base = rand()*Math.PI*2;
        const total = 10 + (this.enraged?4:0);
        for(let i=0;i<total;i++){
          const angle = base + (Math.PI*2/total)*i + w*0.12;
          const speed = 120 + rand()*40 + (this.enraged?30:0);
          runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
        }
      }
      // 指向性射流
      const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
      for(let k=0;k<4;k++){
        const angle = toPlayer + randRange(-0.4,0.4) + k*0.1*(this.enraged?1.2:0.6);
        const speed = 160 + rand()*90;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'needle'));
      }
    }
    spawnMinions(){
      const count = this.enraged ? 3 : 2;
      for(let i=0;i<count;i++){
        const angle = rand()*Math.PI*2;
        const radius = 90 + rand()*60;
        const pos = {x: clamp(this.x + Math.cos(angle)*radius, 70, CONFIG.roomW-70), y: clamp(this.y + Math.sin(angle)*radius, 70, CONFIG.roomH-70)};
        const minion = makeEnemy(rollEnemyType(dungeon.depth+2), pos, dungeon.depth+2);
        minion.r += 2;
        queueEnemySpawn(minion);
      }
    }
    chargeAttack(){
      const to = {x: player.x - this.x, y: player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1;
      const speed = (this.enraged ? 300 : 240) * this.speedScale;
      this.vx = (to.x/l) * speed;
      this.vy = (to.y/l) * speed;
      this.state='charge';
      this.chargeTimer = 0.75 / this.aggression;
    }
    damage(d){
      this.hp -= d;
      this.hitFlash = 0.18;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      const outer = this.hitFlash>0 ? '#ffd5dc' : '#ffb4c8';
      drawBlob(this.x,this.y,this.r, outer,'#d946ef');
      ctx.save();
      ctx.translate(this.x,this.y);
      const blink = this.enraged ? 1.5 : 1;
      ctx.fillStyle = this.enraged ? '#ffe5f2' : '#faf6ff';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.35, -this.r*0.15, this.r*0.25, this.r*0.35, 0, 0, Math.PI*2);
      ctx.ellipse(this.r*0.35, -this.r*0.15, this.r*0.25, this.r*0.35, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#151523';
      const eyeOffset = Math.sin(performance.now()/240)*this.r*0.12;
      ctx.beginPath();
      ctx.arc(-this.r*0.32, -this.r*0.12 + eyeOffset, this.r*0.12*blink, 0, Math.PI*2);
      ctx.arc(this.r*0.32, -this.r*0.12 - eyeOffset, this.r*0.12*blink, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#2f1d38';
      ctx.beginPath();
      ctx.moveTo(-this.r*0.4, this.r*0.1);
      ctx.quadraticCurveTo(0, this.r*0.28 + Math.sin(performance.now()/200)*4, this.r*0.4, this.r*0.1);
      ctx.quadraticCurveTo(0, this.r*0.5, -this.r*0.4, this.r*0.1);
      ctx.fill();
      ctx.restore();
    }
  }

  class EnemyBossMaster{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=34;
      this.hp=85; this.maxHp=this.hp;
      this.name=name;
      this.state='idle';
      this.attackCooldown = 1.8;
      this.telegraphTimer = 0;
      this.hitFlash = 0;
      this.enraged=false;
      this.recoverTimer = 0;
      this.jumpStart = {x,y};
      this.jumpEnd = {x,y};
      this.jumpDuration = 0.8;
      this.jumpElapsed = 0;
      this.altitude = 0;
      this.isBossEntity = true;
      this.scaling = getFloorScalingFactors();
      this.hp = Math.round(this.hp * this.scaling.hp);
      this.maxHp = this.hp;
      this.speedScale = this.scaling.speed;
      this.aggression = this.scaling.aggression;
      this.attackCooldown /= this.aggression;
    }
    update(dt){
      this.hitFlash = Math.max(0, this.hitFlash - dt*3.5);
      if(!this.enraged && this.hp <= this.maxHp*0.45){ this.enraged = true; }
      if(this.state==='idle'){
        this.attackCooldown -= dt * this.aggression;
        const drift = (this.enraged ? 95 : 70) * this.speedScale;
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const distLen = Math.hypot(dx,dy)||1;
        this.x += (dx/distLen) * drift * dt * 0.4;
        this.y += (dy/distLen) * drift * dt * 0.4;
        this.x += Math.cos(performance.now()/520) * 18 * dt;
        this.y += Math.sin(performance.now()/430) * 18 * dt;
        resolveEntityObstacles(this);
        if(this.attackCooldown<=0){ this.chooseAttack(); }
        this.altitude = Math.max(0, this.altitude - dt*2.8*this.aggression);
      } else if(this.state==='telegraph-jump' || this.state==='telegraph-wave'){
        this.telegraphTimer -= dt * this.aggression;
        if(this.state==='telegraph-jump'){ this.altitude = 0.12 + 0.04*Math.sin(performance.now()/90); }
        else { this.altitude = Math.max(0, this.altitude - dt*3*this.aggression); }
        if(this.telegraphTimer<=0){
          if(this.state==='telegraph-jump'){ this.beginJump(); }
          else { this.performWave(); }
        }
      } else if(this.state==='jumping'){
        this.jumpElapsed = Math.min(this.jumpDuration, this.jumpElapsed + dt);
        const ratio = this.jumpDuration>0 ? this.jumpElapsed / this.jumpDuration : 1;
        const ease = ratio<0.5 ? 2*ratio*ratio : -1 + (4 - 2*ratio)*ratio;
        this.x = this.jumpStart.x + (this.jumpEnd.x - this.jumpStart.x) * ease;
        this.y = this.jumpStart.y + (this.jumpEnd.y - this.jumpStart.y) * ease;
        this.altitude = Math.sin(Math.PI * ratio);
        if(this.jumpElapsed>=this.jumpDuration){
          this.state='slam';
          this.altitude = 0;
          this.performSlam();
          this.recoverTimer = (this.enraged ? 0.6 : 0.75) / this.aggression;
        }
      } else if(this.state==='slam'){
        this.recoverTimer -= dt * this.aggression;
        this.altitude = Math.max(0, this.altitude - dt*4*this.aggression);
        if(this.recoverTimer<=0){
          this.state='recover';
          this.attackCooldown = (this.enraged ? 1.2 : 1.6) / this.aggression;
          this.recoverTimer = (this.enraged ? 0.5 : 0.7) / this.aggression;
        }
      } else if(this.state==='wave'){
        this.recoverTimer -= dt * this.aggression;
        this.altitude = Math.max(0, this.altitude - dt*3.5*this.aggression);
        if(this.recoverTimer<=0){
          this.state='recover';
          this.attackCooldown = (this.enraged ? 1.35 : 1.8) / this.aggression;
          this.recoverTimer = (this.enraged ? 0.45 : 0.6) / this.aggression;
        }
      } else if(this.state==='recover'){
        this.recoverTimer -= dt * this.aggression;
        this.altitude = Math.max(0, this.altitude - dt*3*this.aggression);
        if(this.recoverTimer<=0){ this.state='idle'; }
      }
      this.x = clamp(this.x, 70, CONFIG.roomW-70);
      this.y = clamp(this.y, 90, CONFIG.roomH-90);
    }
    chooseAttack(){
      if(rand() < 0.55){
        this.state='telegraph-jump';
        this.telegraphTimer = (this.enraged ? 0.9 : 1.1) / this.aggression;
      } else {
        this.state='telegraph-wave';
        this.telegraphTimer = 1.0 / this.aggression;
      }
    }
    beginJump(){
      const maxTravel = this.enraged ? 360 : 320;
      const targetX = clamp(player.x, 80, CONFIG.roomW-80);
      const targetY = clamp(player.y, 96, CONFIG.roomH-96);
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const distLen = Math.hypot(dx,dy)||1;
      const travel = clamp(distLen, 140, maxTravel);
      const nx = dx/distLen;
      const ny = dy/distLen;
      this.jumpStart = {x:this.x, y:this.y};
      this.jumpEnd = {
        x: clamp(this.x + nx*travel, 70, CONFIG.roomW-70),
        y: clamp(this.y + ny*travel, 86, CONFIG.roomH-86)
      };
      const speed = (this.enraged ? 420 : 360) * this.speedScale;
      this.jumpDuration = Math.max(0.55, travel / speed);
      this.jumpElapsed = 0;
      this.state='jumping';
    }
    performSlam(){
      const radius = 90 + (this.enraged ? 20 : 0);
      if(player && dist(this, player) <= this.r + radius){
        player.hurt(2);
        player.applyImpulse(player.x - this.x, player.y - this.y, 220);
      }
      const shards = this.enraged ? 14 : 10;
      for(let i=0;i<shards;i++){
        const angle = (Math.PI*2/shards) * i;
        const speed = 180 + rand()*60 + (this.enraged?40:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'tear'));
      }
    }
    performWave(){
      const bursts = this.enraged ? 5 : 4;
      const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
      const spread = 0.3;
      for(let lane=0; lane<bursts; lane++){
        const offset = (lane - (bursts-1)/2) * spread;
        const angle = baseAngle + offset;
        const speed = 220 + rand()*60 + (this.enraged?40:0);
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
      }
      const secondary = this.enraged ? 8 : 6;
      for(let i=0;i<secondary;i++){
        const angle = baseAngle + randRange(-Math.PI, Math.PI);
        const speed = 140 + rand()*40;
        runtime.enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 3.2, 'tear'));
      }
      const spawns = this.enraged ? 2 : 1;
      for(let k=0;k<spawns;k++){
        const ang = baseAngle + (k===0?Math.PI/2:-Math.PI/2) + randRange(-0.35,0.35);
        const distLen = 110 + rand()*60;
        const pos = {
          x: clamp(this.x + Math.cos(ang)*distLen, 80, CONFIG.roomW-80),
          y: clamp(this.y + Math.sin(ang)*distLen, 90, CONFIG.roomH-90)
        };
        queueEnemySpawn(makeEnemy('spider', pos, dungeon.depth+1));
      }
      this.state='wave';
      this.recoverTimer = (this.enraged ? 0.8 : 1.0) / this.aggression;
    }
    damage(d){
      if(this.state==='jumping'){ d *= 0.6; }
      this.hp -= d;
      this.hitFlash = 0.2;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      const telegraph = this.state==='telegraph-jump' || this.state==='telegraph-wave';
      const enraged = this.enraged;
      ctx.save();
      ctx.globalAlpha = 0.4 + 0.3*this.altitude;
      ctx.fillStyle = '#0007';
      ctx.beginPath();
      ctx.ellipse(this.x, this.y + this.r*0.9, this.r*(1 - this.altitude*0.4), this.r*0.6*(1 - this.altitude*0.45), 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      const base = this.hitFlash>0 ? '#ffe6ef' : telegraph ? '#fda4af' : (enraged ? '#f87171' : '#ffcad6');
      const edge = telegraph ? '#fb7185' : (enraged ? '#ef4444' : '#f472b6');
      drawBlob(this.x, this.y - this.altitude*this.r*0.9, this.r, base, edge);
      ctx.save();
      ctx.translate(this.x, this.y - this.altitude*this.r*0.9);
      ctx.fillStyle = '#2d0f1f';
      ctx.beginPath();
      ctx.arc(-this.r*0.28, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.arc(this.r*0.28, -this.r*0.1, this.r*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#3f1d33';
      ctx.beginPath();
      ctx.moveTo(-this.r*0.4, this.r*0.15);
      ctx.quadraticCurveTo(0, this.r*(telegraph?0.45:0.35), this.r*0.4, this.r*0.15);
      ctx.quadraticCurveTo(0, this.r*(telegraph?0.55:0.45), -this.r*0.4, this.r*0.15);
      ctx.fill();
      ctx.restore();
      if(telegraph){
        ctx.save();
        ctx.globalAlpha = 0.6 + 0.2*Math.sin(performance.now()/90);
        ctx.strokeStyle = enraged ? '#f87171' : '#fbcfe8';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.altitude*this.r*0.9, this.r + 10, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }
    }
  }

  function drawBlob(x,y,r,base,edge){
    const g = ctx.createRadialGradient(x-r*0.4,y-r*0.4,r*0.1,x,y,r*1.1);
    g.addColorStop(0, base);
    g.addColorStop(1, edge);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  function updateRoomPortal(room, dt){
    if(!room?.portal) return;
    const portal = room.portal;
    if(portal.used) return;
    portal.phase = (portal.phase || 0) + dt;
    if(!portal.active){
      const delay = portal.spawnDelay ?? 0;
      if(delay>0){
        portal.spawnDelay = Math.max(0, delay - dt);
        if(portal.spawnDelay<=0){ portal.active = true; }
      } else {
        portal.active = true;
      }
    }
    if(!portal.active){
      portal.interactable = false;
      portal.highlight = Math.max(0, (portal.highlight || 0) - dt*2.6);
      return;
    }
    const interactRadius = portal.interactRadius ?? (portal.r + 18);
    const distance = player ? dist(player, portal) : Infinity;
    portal.interactable = distance <= interactRadius;
    const target = portal.interactable ? 1 : 0;
    const rate = portal.interactable ? 4 : 2.4;
    portal.highlight = portal.highlight || 0;
    if(portal.highlight < target){
      portal.highlight = Math.min(target, portal.highlight + dt * rate);
    } else if(portal.highlight > target){
      portal.highlight = Math.max(target, portal.highlight - dt * rate);
    }
  }

  function drawPortal(portal){
    if(!portal || portal.used) return;
    const cfg = CONFIG.portal || {};
    const radius = portal.r ?? (cfg.radius ?? 34);
    const wobble = 1 + 0.08*Math.sin((portal.phase || 0) * 4.2);
    const highlight = portal.highlight || 0;
    const hint = cfg.hint || '按 F 进入下一层';

    ctx.save();
    ctx.globalAlpha = 0.35 + highlight*0.15;
    ctx.fillStyle = '#0f172acc';
    ctx.beginPath();
    ctx.ellipse(portal.x, portal.y + radius*0.45, radius*0.9, radius*0.32, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(portal.x, portal.y);
    const outerR = radius * wobble;
    const gradient = ctx.createRadialGradient(0,0, outerR*0.18, 0,0, outerR);
    gradient.addColorStop(0, `rgba(110,231,255,${0.8 + 0.2*highlight})`);
    gradient.addColorStop(0.55, 'rgba(167,139,250,0.55)');
    gradient.addColorStop(1, 'rgba(56,189,248,0.2)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.ellipse(0,0, outerR, outerR*0.65, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.lineWidth = 2.5 + highlight*2.2;
    ctx.strokeStyle = `rgba(125,211,252,${0.65 + 0.25*highlight})`;
    ctx.beginPath();
    ctx.ellipse(0,0, outerR*0.78, outerR*0.5, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.rotate((portal.phase || 0) * 1.8);
    const arcCount = 4;
    for(let i=0;i<arcCount;i++){
      ctx.beginPath();
      ctx.strokeStyle = `rgba(186,230,253,${0.4 + 0.3*highlight})`;
      ctx.lineWidth = 1.6 + highlight*1.2;
      const start = (Math.PI*2/arcCount)*i;
      ctx.arc(0,0, outerR*0.55, start, start + Math.PI*0.6);
      ctx.stroke();
    }
    ctx.restore();

    if(portal.interactable){
      ctx.save();
      ctx.font = '16px "Microsoft YaHei", system-ui';
      ctx.fillStyle = '#e0f2fe';
      ctx.textAlign = 'center';
      ctx.fillText(hint, portal.x, portal.y - radius*1.2 - 12);
      ctx.restore();
    }
  }

  // ======= 运行时上下文 =======
  const runtime = {
    bullets: [],
    enemyProjectiles: [],
    pendingEnemySpawns: [],
    bossIntroTimer: 0,
    bossIntroText: '',
    itemPickupTimer: 0,
    itemPickupName: '',
    itemPickupDesc: '',
    floor: currentFloor,
  };
  let dungeon, player;

  function startGame(){
    overlayManager.clear();
    recentItemHistory.length = 0;
    recentShopItemHistory.length = 0;
    currentFloor = 1;
    runtime.floor = currentFloor;
    dungeon = new Dungeon();
    player = new Player(CONFIG.roomW/2, CONFIG.roomH/2);
    keys.clear();
    dungeon.current.visited=true;
    dungeon.revealRoom(dungeon.current);
    dungeon.current.spawnEnemies(dungeon.depth);
    state = STATE.PLAY;
    lastTime = performance.now();
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    runtime.bossIntroTimer = 0;
    runtime.bossIntroText = '';
    runtime.itemPickupTimer = 0;
    runtime.itemPickupName = '';
    runtime.itemPickupDesc = '';
    syncCheatPanel();
  }

  function advanceToNextFloor(){
    if(!player || !dungeon) return;
    const prevDepth = dungeon.depth || 1;
    const portalRoom = dungeon.current;
    if(portalRoom?.portal){ portalRoom.portal.used = true; portalRoom.portal = null; }
    currentFloor = Math.max(1, currentFloor + 1);
    runtime.floor = currentFloor;
    const preservedKeys = new Set(keys);
    dungeon = new Dungeon();
    dungeon.depth = Math.max(prevDepth + 1, 1);
    dungeon.current.visited = true;
    dungeon.revealRoom(dungeon.current);
    dungeon.current.spawnEnemies(dungeon.depth);
    player.x = CONFIG.roomW/2;
    player.y = CONFIG.roomH/2;
    player.knockVel.x = 0;
    player.knockVel.y = 0;
    player.knockTimer = 0;
    if(player.vel){ player.vel.x = 0; player.vel.y = 0; }
    player.moveDir.x = 0;
    player.moveDir.y = 0;
    player.lastDisplacement.x = 0;
    player.lastDisplacement.y = 0;
    if(player.lastVelocity){ player.lastVelocity.x = 0; player.lastVelocity.y = 0; }
    player.ifr = 0;
    runtime.bullets.length = 0;
    runtime.enemyProjectiles.length = 0;
    runtime.pendingEnemySpawns.length = 0;
    runtime.bossIntroTimer = 0;
    runtime.bossIntroText = '';
    runtime.itemPickupName = `已抵达第 ${currentFloor} 层`;
    runtime.itemPickupDesc = '敌人变得更加愤怒。';
    runtime.itemPickupTimer = 2.6;
    keys.clear();
    for(const code of preservedKeys){ keys.add(code); }
    syncCheatPanel();
  }

  // ======= 门与换房 =======
  function roomDoors(r){
    const doors = [];
    const w=CONFIG.roomW, h=CONFIG.roomH;
    const doorW=60, doorH=10, offset=22;
    if(r.doors.up) doors.push({dir:'up',   x:w/2-doorW/2, y:offset,      w:doorW, h:doorH});
    if(r.doors.down) doors.push({dir:'down', x:w/2-doorW/2, y:h-offset-doorH, w:doorW, h:doorH});
    if(r.doors.left) doors.push({dir:'left', x:offset,      y:h/2-doorW/2, w:doorH, h:doorW});
    if(r.doors.right) doors.push({dir:'right',x:w-offset-doorH, y:h/2-doorW/2, w:doorH, h:doorW});
    return doors;
  }
  function tryRoomTransition(){
    const r = dungeon.current;
    const doors = roomDoors(r);
    for(const d of doors){
      const ni = r.i + (d.dir==='down') - (d.dir==='up');
      const nj = r.j + (d.dir==='right') - (d.dir==='left');
      const nr = dungeon.rooms[ni]?.[nj];
      if(!nr) continue;
      const requiresClear = r.cleared || r.isBoss || nr.isBoss;
      if(!requiresClear) continue;
      if(!rectCircleOverlap(d.x,d.y,d.w,d.h, player.x,player.y,player.r)) continue;
      if(nr.locked){
        if(player.keys>0){
          player.keys -= 1;
          player.recalculateDamage();
          nr.locked = false;
          if(runtime.itemPickupTimer<=0){
            runtime.itemPickupName = '钥匙冒着烟消失';
            runtime.itemPickupDesc = nr.isShop ? '商店老板：欢迎惠顾！' : '门锁：「勉强通过。」';
            runtime.itemPickupTimer = 1.4;
          }
        } else if(runtime.itemPickupTimer<=0){
          runtime.itemPickupName = '缺钥匙提示';
          runtime.itemPickupDesc = '门锁不吃嘴炮，只认金属';
          runtime.itemPickupTimer = 1.2;
        }
        continue;
      }
      dungeon.current = nr;
      if(!nr.visited){ dungeon.depth++; }
      nr.visited = true;
      dungeon.revealRoom(nr);
      // 入口位置
      if(d.dir==='up'){ player.x=CONFIG.roomW/2; player.y=CONFIG.roomH-60; }
      if(d.dir==='down'){ player.x=CONFIG.roomW/2; player.y=60; }
      if(d.dir==='left'){ player.x=CONFIG.roomW-60; player.y=CONFIG.roomH/2; }
      if(d.dir==='right'){ player.x=60; player.y=CONFIG.roomH/2; }
      runtime.bullets.length = 0; runtime.enemyProjectiles.length = 0;
      if(nr.isBoss && !nr.introPlayed){
        runtime.bossIntroText = nr.bossName;
        runtime.bossIntroTimer = 3.2;
        nr.introPlayed = true;
      }
      if(nr.isItemRoom){ nr.ensureItem(); }
      if(nr.isShop){ nr.prepareShop(); }
      if(!nr.cleared || nr.isBoss){ nr.spawnEnemies(dungeon.depth); }
      break;
    }
  }
  function rectCircleOverlap(rx,ry,rw,rh, cx,cy,cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }
  function circleRectOverlap(circle, rect){
    return rectCircleOverlap(rect.x, rect.y, rect.w, rect.h, circle.x, circle.y, circle.r);
  }
  function resolveEntityObstacles(entity){
    if(!dungeon?.current) return;
    if(entity===player){
      if(player.flying) return;
    } else if(entity?.flying){
      return;
    }
    for(const obs of dungeon.current.obstacles){
      if(obs.destroyed) continue;
      const push = circleRectResolve(entity, obs);
      if(push){
        entity.x += push.x;
        entity.y += push.y;
        if(entity.knockVel){ entity.knockVel.x *= 0.5; entity.knockVel.y *= 0.5; }
      }
    }
  }
  function circleRectResolve(circle, rect){
    const nx = clamp(circle.x, rect.x, rect.x+rect.w);
    const ny = clamp(circle.y, rect.y, rect.y+rect.h);
    const dx = circle.x - nx;
    const dy = circle.y - ny;
    const distSq = dx*dx + dy*dy;
    const r = circle.r;
    if(distSq >= r*r) return null;
    const dist = Math.sqrt(distSq) || 0.0001;
    const overlap = r - dist;
    const ox = dist ? (dx/dist) * overlap : 0;
    const oy = dist ? (dy/dist) * overlap : -overlap;
    return {x:ox, y:oy};
  }

  // ======= 主循环 =======
  let lastTime = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now - lastTime) / 1000);
    if(state===STATE.PLAY){ update(dt); }
    draw();
    if(state===STATE.PLAY) lastTime = now; // 暂停时不要推进时间
  }
  requestAnimationFrame(loop);

  function update(dt){
    player.update(dt);

    const bombs = dungeon.current.bombs;
    for(let i=bombs.length-1;i>=0;i--){
      const b = bombs[i];
      b.update(dt);
      if(b.done){ bombs.splice(i,1); }
    }
    updatePickups(dt);
    updateRoomPortal(dungeon.current, dt);
    for(const b of bombs){
      if(b.done || b.exploded || b.spawnGrace>0) continue;
      const d = dist(player, b);
      if(d < player.r + b.r){
        const dx = b.x - player.x;
        const dy = b.y - player.y;
        const len = Math.hypot(dx,dy) || 1;
        const overlap = player.r + b.r - d;
        if(overlap>0){
          b.x += (dx/len) * overlap;
          b.y += (dy/len) * overlap;
        }
        const moveImpulse = Math.hypot(player.lastDisplacement.x, player.lastDisplacement.y);
        const pushPower = 140 + moveImpulse * 420;
        b.applyImpulse(dx, dy, pushPower);
      }
    }

    // 子弹
    for(const b of runtime.bullets) b.update(dt);
    runtime.bullets = runtime.bullets.filter(b=>b.alive);

    // 敌人
    const enemies = dungeon.current.enemies;
    for(const e of enemies) e.update(dt);
    if(runtime.pendingEnemySpawns.length){ enemies.push(...runtime.pendingEnemySpawns.splice(0)); }

    // 敌方弹幕
    for(const eb of runtime.enemyProjectiles){ eb.update(dt); }
    runtime.enemyProjectiles = runtime.enemyProjectiles.filter(p=>p.alive);

    // 碰撞：子弹-敌人
    for(const b of runtime.bullets){
      for(const e of enemies){
        if(e.dead) continue;
        const dd = dist(b, e);
        if(dd < (b.r + e.r)){
          if(e.damage(b.damage)){ handleEnemyDeath(e, dungeon.current); }
          b.alive=false; break;
        }
      }
    }
    // 清理死亡
    dungeon.current.enemies = enemies.filter(e=>!e.dead);

    // 玩家被弹幕命中
    for(const eb of runtime.enemyProjectiles){ if(eb.checkHit(player)){ eb.alive=false; } }

    // 房间是否清空
    if(!dungeon.current.cleared && dungeon.current.enemies.length===0){
      dungeon.current.cleared = true;
      // 小概率掉红心
      if(rand()<CONFIG.drops.heartRoomClear){
        dungeon.current.pickups.push(makeHeartPickup(randRange(120,CONFIG.roomW-120), randRange(120,CONFIG.roomH-120), 1));
      }
      if(rand()<CONFIG.drops.roomClearResource){
        const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
        const amount = resType==='coin'?4:1;
        dungeon.current.pickups.push(makeResourcePickup(resType, randRange(120,CONFIG.roomW-120), randRange(120,CONFIG.roomH-120), amount));
      }
    }

    // 拾取
    const picks = dungeon.current.pickups;
    for(let i=picks.length-1;i>=0;i--){
      const p = picks[i];
      if((p.spawnGrace||0)>0) continue;
      const distance = dist(p,player);
      if(distance < p.r + player.r){
        const movement = Math.hypot(player.lastDisplacement.x, player.lastDisplacement.y);
        const shove = 170 + movement * 420;
        if(p.type==='heart'){
          const missing = Math.max(0, player.maxHp - player.hp);
          const healValue = Math.min(missing, p.heal || 1);
          if(healValue>0){
            player.hp = Math.min(player.maxHp, player.hp + healValue);
            if(typeof p.heal === 'number'){
              p.heal = Math.max(0, (p.heal || 0) - healValue);
              p.r = p.heal>1 ? 14 : 10;
            }
            if(!p.heal || p.heal<=0){ picks.splice(i,1); }
            player.recalculateDamage();
          } else {
            pushPickup(p, player, shove);
          }
        } else if(p.type==='item'){
          pickupItem(p);
          picks.splice(i,1);
        } else if(p.type==='bomb' || p.type==='key' || p.type==='coin'){
          const amount = p.amount || 1;
          const gained = grantResource(p.type, amount);
          if(gained>0){
            if(typeof p.amount === 'number'){
              p.amount = Math.max(0, amount - gained);
            }
            if(!p.amount){ picks.splice(i,1); }
          } else {
            pushPickup(p, player, shove);
          }
        }
      }
    }

    // 换房
    tryRoomTransition();

    // 更新 HUD
    renderHUD();
    runtime.bossIntroTimer = Math.max(0, runtime.bossIntroTimer - dt);
    runtime.itemPickupTimer = Math.max(0, runtime.itemPickupTimer - dt);
    if(runtime.itemPickupTimer<=0){ runtime.itemPickupName=''; runtime.itemPickupDesc=''; }
  }

  function renderHUD(){
    const hearts = '❤'.repeat(Math.max(0,player.hp)) + '·'.repeat(Math.max(0, player.maxHp - player.hp));
    HUDL.innerHTML = `生命：<span style="letter-spacing:1px">${hearts}</span><span class="kbd">💣 ${player.bombs}</span><span class="kbd">🔑 ${player.keys}</span><span class="kbd">🪙 ${player.coins}</span>`;
    const fireRate = player.fireInterval>0 ? (1000/player.fireInterval).toFixed(2) : '∞';
    const damage = Number.isInteger(player.damage) ? player.damage : player.damage.toFixed(1);
    const moveSpeed = Math.round(player.speed);
    const tearSpeed = Math.round(player.tearSpeed);
    const range = Math.round(player.tearSpeed * player.tearLife);
    const statItems = [
      {label:'攻速', value: fireRate, unit:'次/秒'},
      {label:'伤害', value: damage},
      {label:'移动速度', value: moveSpeed},
      {label:'子弹速度', value: tearSpeed},
      {label:'射程', value: range}
    ];
    HUDS.innerHTML = statItems.map(({label,value,unit})=>`<span>${label}：<strong>${value}</strong>${unit?`<small>${unit}</small>`:''}</span>`).join('');
    const itemsText = player.items.length ? player.items.join('、') : '空手上阵';
    const floorLevel = runtime.floor || currentFloor || 1;
    if(dungeon.current.isBoss && dungeon.current.bossEntity && !dungeon.current.bossEntity.dead){
      HUDR.innerHTML = `<span style="display:flex;flex-direction:column;gap:2px;align-items:flex-end"><span>楼层：${floorLevel} / <span style="color:#ffb4c8">BOSS：${dungeon.current.bossEntity.name}</span></span><span>道具：${itemsText}</span></span>`;
    } else {
      HUDR.innerHTML = `<span style="display:flex;flex-direction:column;gap:2px;align-items:flex-end"><span>楼层：${floorLevel} / 已探索：${exploredRooms()} 间</span><span>道具：${itemsText}</span></span>`;
    }
    if(cheatPanelNode?.classList.contains('show')){ syncCheatPanel(); }
  }
  function exploredRooms(){
    let n=0; for(let i=0;i<dungeon.gridN;i++){for(let j=0;j<dungeon.gridN;j++){if(dungeon.rooms[i][j]?.visited) n++;}} return n;
  }

  // ======= 渲染 =======
  function draw(){
    // 背景
    ctx.clearRect(0,0,CONFIG.roomW, CONFIG.roomH);
    drawRoomBackdrop();
    drawDoors();
    drawObstacles();

    // 拾取
    for(const p of dungeon.current.pickups){ drawPickup(p); }

    if(dungeon.current.portal){ drawPortal(dungeon.current.portal); }

    for(const bomb of dungeon.current.bombs){ bomb.draw(); }

    // 敌人
    for(const e of dungeon.current.enemies){ e.draw(); }

    // 敌弹
    for(const eb of runtime.enemyProjectiles){ eb.draw(); }

    // 子弹
    for(const b of runtime.bullets){ b.draw(); }

    // 玩家
    drawPlayer();

    drawBossHealth();

    // 小地图
    drawMiniMap();

    drawItemPickupBanner();

  }

  function drawRoomBackdrop(){
    const w=CONFIG.roomW, h=CONFIG.roomH;
    // 地砖
    const isBoss = dungeon.current.isBoss && !dungeon.current.cleared;
    const g = ctx.createLinearGradient(0,0,0,h);
    if(isBoss){ g.addColorStop(0,'#1b0f19'); g.addColorStop(1,'#120913'); }
    else { g.addColorStop(0,'#10141d'); g.addColorStop(1,'#0d121a'); }
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    // 边框
    ctx.strokeStyle = isBoss ? '#663355' : '#2a3142'; ctx.lineWidth=14; ctx.strokeRect(10,10,w-20,h-20);
    // 裂纹/污渍
    ctx.globalAlpha = isBoss ? 0.12 : 0.06; ctx.fillStyle=isBoss ? '#ff88b1' : '#bcd';
    for(let i=0;i<22;i++){ const x=randRange(30,w-30), y=randRange(30,h-30), r=randRange(8,38); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
    ctx.globalAlpha = 1;
  }
  function drawDoors(){
    const r = dungeon.current; const doors = roomDoors(r);
    for(const d of doors){
      const ni = r.i + (d.dir==='down') - (d.dir==='up');
      const nj = r.j + (d.dir==='right') - (d.dir==='left');
      const nr = dungeon.rooms[ni]?.[nj];
      const leadsBoss = !!(nr && nr.isBoss && !nr.bossDefeated);
      const leadsItem = !!(nr && nr.isItemRoom && !nr.itemClaimed);
      const locked = !!(nr && nr.locked);
      const doorReady = r.cleared || r.isBoss || (nr && nr.isBoss);
      const doorUnlocked = doorReady && !locked;
      let frame = '#2a3142';
      let fill = '#1e2330';
      if(leadsBoss){
        frame = doorUnlocked ? '#ff6b6b55' : '#2f1b28';
        fill = doorUnlocked ? '#ff6b6b' : '#371822';
      } else if(leadsItem){
        frame = doorUnlocked ? '#facc1555' : '#3a3318';
        fill = doorUnlocked ? '#facc15' : '#3b3414';
      } else if(nr?.isShop){
        frame = doorUnlocked ? '#fbbf2455' : '#3a2f1a';
        fill = doorUnlocked ? '#fbbf24' : '#3b2f18';
      } else if(doorUnlocked){
        frame = '#6ee7ff55';
        fill = '#6ee7ff';
      }
      if(locked){
        frame = '#b4530955';
        fill = '#7c2d12';
      }
      ctx.save();
      // 门框
      ctx.fillStyle = frame;
      ctx.fillRect(d.x-4,d.y-4,d.w+8,d.h+8);
      // 门
      ctx.fillStyle = fill;
      ctx.fillRect(d.x,d.y,d.w,d.h);
      ctx.restore();
    }
  }
  function drawObstacles(){
    const room = dungeon.current;
    ctx.save();
    for(const obs of room.obstacles){
      if(obs.destroyed) continue;
      if(obs.hidden) continue;
      const g = ctx.createLinearGradient(obs.x, obs.y, obs.x, obs.y+obs.h);
      g.addColorStop(0,'#2b2f3f');
      g.addColorStop(1,'#1b1f2b');
      ctx.fillStyle = g;
      ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
      ctx.strokeStyle = '#0005';
      ctx.lineWidth = 2;
      ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
      ctx.fillStyle = '#fff1';
      ctx.fillRect(obs.x+4, obs.y+4, obs.w-8, 2);
    }
    ctx.restore();
  }
  function drawPickup(p){
    if(p.type==='heart'){
      drawHeartPickup(p);
    } else if((p.type==='bomb' || p.type==='key' || p.type==='coin') && !p.entry){
      drawResourcePickup(p);
    } else if(p.type==='item' && p.item){
      drawItemPickup(p);
    } else if(p.type==='shop'){
      drawShopPickup(p);
    }
  }

  function drawHeartPickup(p){
    const t = (performance.now()/300)%Math.PI;
    const r = p.r + Math.sin(t)*1.2;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.fillStyle = p.heal>1 ? '#ff98a8' : '#ff7787';
    ctx.strokeStyle = '#fff3'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, r*0.6);
    ctx.bezierCurveTo(r, -r*0.6, r*1.2, r*0.6, 0, r);
    ctx.bezierCurveTo(-r*1.2, r*0.6, -r, -r*0.6, 0, r*0.6);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function drawResourcePickup(p){
    const bob = Math.sin(performance.now()/480)*4;
    ctx.save();
    ctx.translate(p.x, p.y + bob);
    drawResourceIcon(p.type, p.r);
    ctx.restore();
    if(p.amount>1){
      ctx.save();
      ctx.fillStyle = '#dbeafe';
      ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
      ctx.textAlign='center';
      ctx.fillText(`x${p.amount}`, p.x, p.y + 28);
      ctx.restore();
    }
  }

  function drawItemPickup(p){
    const bob = Math.sin(performance.now()/480)*4;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.fillStyle = '#2a3146';
    ctx.fillRect(-18,12,36,9);
    ctx.fillStyle = '#39415c';
    ctx.fillRect(-14,6,28,8);
    ctx.translate(0, bob-6);
    drawItemIcon(p.item.slug, p.r);
    ctx.restore();
    ctx.save();
    ctx.fillStyle = '#dde3ff';
    ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(p.item.name, p.x, p.y - 30);
    ctx.restore();
  }

  function drawShopPickup(p){
    const bob = Math.sin(performance.now()/520)*4;
    const near = player ? dist(p, player) < p.r + player.r + 16 : false;
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.fillStyle = near ? '#303854' : '#2a3146';
    ctx.fillRect(-20,14,40,10);
    ctx.fillStyle = near ? '#4b5774' : '#39415c';
    ctx.fillRect(-16,7,32,9);
    ctx.translate(0,bob-6);
    if(p.entry.type==='item'){
      drawItemIcon(p.entry.item.slug, p.r*0.9);
    } else {
      drawResourceIcon(p.entry.resource, p.r*0.9);
    }
    ctx.restore();
    const title = p.entry.type==='item' ? p.entry.item.name : `${RESOURCE_LABELS[p.entry.resource]} x${p.entry.amount}`;
    ctx.save();
    ctx.fillStyle = '#d6dcff';
    ctx.font = '12px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(title, p.x, p.y - 32);
    ctx.fillStyle = near ? '#facc15' : '#cbd5f5';
    ctx.fillText(`${p.price}🪙`, p.x, p.y - 16);
    ctx.restore();
  }

  function drawItemIcon(id, radius, ctxRef = ctx){
    const g = ctxRef;
    if(!g) return;
    const r = radius;
    if(id==='onion'){
      g.fillStyle = '#facc15';
      g.strokeStyle = '#fff5';
      g.lineWidth = 1.5;
      g.beginPath();
      g.moveTo(0,-r*0.7);
      g.bezierCurveTo(r*0.75,-r*0.3, r*0.55, r*0.45, 0, r*0.85);
      g.bezierCurveTo(-r*0.55, r*0.45, -r*0.75, -r*0.3, 0, -r*0.7);
      g.fill();
      g.stroke();
      g.strokeStyle = '#7c5b0f';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(0,-r*0.9);
      g.lineTo(0,-r*1.2);
      g.stroke();
    } else if(id==='tar'){
      const grad = g.createRadialGradient(0,-2,2,0,0,r*0.75);
      grad.addColorStop(0,'#5f6cff');
      grad.addColorStop(1,'#2d2f59');
      g.fillStyle = grad;
      g.beginPath();
      g.ellipse(0,0,r*0.9,r*0.7,0,0,Math.PI*2);
      g.fill();
    } else if(id==='sneaker'){
      g.fillStyle = '#9ae6b4';
      g.beginPath();
      g.moveTo(-r*0.8, r*0.2);
      g.quadraticCurveTo(-r*0.2, -r*0.7, r*0.8, -r*0.1);
      g.lineTo(r*0.5, r*0.5);
      g.quadraticCurveTo(-r*0.1, r*0.3, -r*0.8, r*0.2);
      g.fill();
      g.fillStyle='#2f855a';
      g.fillRect(-r*0.2, -r*0.1, r*0.8, r*0.15);
    } else if(id==='pepper-steak'){
      g.fillStyle = '#b45309';
      g.beginPath(); g.ellipse(0,0,r*0.95,r*0.65,0,0,Math.PI*2); g.fill();
      g.fillStyle = '#f59e0b';
      g.beginPath(); g.ellipse(0,0,r*0.6,r*0.35,0,0,Math.PI*2); g.fill();
    } else if(id==='rope'){
      g.strokeStyle = '#fde68a';
      g.lineWidth = 4;
      g.beginPath();
      g.moveTo(-r*0.6, -r*0.8);
      g.quadraticCurveTo(0, r*0.4, r*0.6, -r*0.8);
      g.stroke();
    } else if(id==='spirit-date'){
      g.fillStyle = '#92400e';
      g.beginPath(); g.ellipse(0,0,r*0.6,r*0.85,0,0,Math.PI*2); g.fill();
      g.fillStyle='#f97316';
      g.beginPath(); g.arc(0,-r*0.25,r*0.25,0,Math.PI*2); g.fill();
    } else if(id==='betrayal-hound'){
      g.fillStyle='#4c1d95';
      g.beginPath(); g.arc(-r*0.3,-r*0.2,r*0.3,0,Math.PI*2); g.fill();
      g.beginPath(); g.arc(r*0.3,-r*0.2,r*0.3,0,Math.PI*2); g.fill();
      g.fillStyle='#a855f7';
      g.beginPath(); g.arc(0,r*0.2,r*0.5,0,Math.PI*2); g.fill();
    } else if(id==='despair-shout'){
      g.fillStyle='#cbd5f5';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#7c3aed';
      g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.fill();
    } else if(id==='bad-thing'){
      g.fillStyle='#1f2937';
      g.beginPath(); g.arc(0,0,r*0.9,0,Math.PI*2); g.fill();
      g.strokeStyle='#f97316'; g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*0.6,0,Math.PI*2); g.stroke();
    } else if(id==='good-thing'){
      g.fillStyle='#fbcfe8';
      g.beginPath(); g.arc(0,0,r*0.9,0,Math.PI*2); g.fill();
      g.strokeStyle='#f472b6'; g.lineWidth=2;
      g.beginPath(); g.arc(0,0,r*0.55,0,Math.PI*2); g.stroke();
    } else if(id==='blood-power'){
      g.fillStyle='#ef4444';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#fee2e2';
      g.beginPath(); g.arc(0,0,r*0.4,0,Math.PI*2); g.fill();
    } else if(id==='money-power'){
      g.fillStyle='#fbbf24';
      g.beginPath(); g.arc(0,0,r*0.85,0,Math.PI*2); g.fill();
      g.fillStyle='#fde68a';
      g.beginPath(); g.arc(0,0,r*0.4,0,Math.PI*2); g.fill();
    } else if(id==='despair-power'){
      g.fillStyle='#1f2937';
      g.beginPath(); g.arc(0,0,r*0.9,0,Math.PI*2); g.fill();
      g.fillStyle='#f9a8d4';
      g.beginPath(); g.arc(0,0,r*0.35,0,Math.PI*2); g.fill();
    } else if(id==='dog-food'){
      g.fillStyle='#92400e';
      g.fillRect(-r*0.7,-r*0.5,r*1.4,r*0.9);
      g.fillStyle='#fde68a';
      g.fillRect(-r*0.7,-r*0.9,r*1.4,r*0.4);
    } else if(id==='ending-note'){
      g.fillStyle='#f8fafc';
      g.fillRect(-r*0.5,-r*0.8,r,r*1.4);
      g.fillStyle='#6366f1';
      g.fillRect(-r*0.5,-r*0.2,r,r*0.12);
    } else if(id==='kettle'){
      g.fillStyle='#94a3b8';
      g.beginPath(); g.arc(0,0,r*0.75,0,Math.PI*2); g.fill();
      g.fillRect(-r*0.2,-r*0.95,r*0.4,r*0.4);
    } else {
      g.fillStyle = '#b0c9ff';
      g.beginPath();
      g.arc(0,0,r*0.8,0,Math.PI*2);
      g.fill();
    }
  }

  function drawResourceIcon(type, radius){
    const r = radius;
    if(type==='bomb'){
      ctx.fillStyle = '#2f3345';
      ctx.beginPath(); ctx.arc(0,0,r*0.9,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2f3345';
      ctx.fillRect(-2,-r*1.1,4,r*0.6);
    } else if(type==='key'){
      ctx.fillStyle = '#facc15';
      ctx.beginPath(); ctx.arc(-r*0.3,0,r*0.55,0,Math.PI*2); ctx.fill();
      ctx.fillRect(-r*0.3, -r*0.15, r*1.3, r*0.3);
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(r*0.35, -r*0.05, r*0.3, r*0.2);
    } else if(type==='coin'){
      const grad = ctx.createRadialGradient(-2,-2,2,0,0,r*0.9);
      grad.addColorStop(0,'#fff5ba');
      grad.addColorStop(1,'#facc15');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(0,0,r*0.9,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#d97706';
      ctx.fillRect(-r*0.2,-r*0.75,r*0.4,r*1.5);
    }
  }
  function drawPlayer(){
    // 身体
    drawBlob(player.x, player.y, player.r, '#e1e7ff', '#a78bfa');
    // 眼泪闪烁（无敌帧提示）
    if(player.ifr>0){ ctx.save(); ctx.globalAlpha = 0.5 + 0.5*Math.sin(performance.now()/60); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x,player.y,player.r+3,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  }
  function drawMiniMap(){
    const cell=12, pad=8, left=16, top=16;
    const discovered=[];
    for(let i=0;i<dungeon.gridN;i++){
      for(let j=0;j<dungeon.gridN;j++){
        const r = dungeon.rooms[i][j];
        if(r?.discovered) discovered.push(r);
      }
    }
    if(!discovered.length) return;
    const width = (dungeon.bounds.maxJ - dungeon.bounds.minJ + 1) * cell;
    const height = (dungeon.bounds.maxI - dungeon.bounds.minI + 1) * cell;
    ctx.save();
    ctx.translate(left, top);
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = '#141a25';
    ctx.fillRect(-pad,-pad,width+pad*2,height+pad*2);
    for(const r of discovered){
      const x = (r.j - dungeon.bounds.minJ) * cell;
      const y = (r.i - dungeon.bounds.minI) * cell;
      if(r===dungeon.current){ ctx.fillStyle='#6ee7ff'; }
      else if(r.isBoss && !r.bossDefeated){ ctx.fillStyle='#ff6b6b'; }
      else if(r.isItemRoom && !r.itemClaimed){ ctx.fillStyle='#facc15'; }
      else if(r.isShop){ ctx.fillStyle='#fbbf24'; }
      else { ctx.fillStyle='#2c3a54'; }
      ctx.fillRect(x,y,cell-1,cell-1);
    }
    ctx.restore();
    if(runtime.bossIntroTimer>0){ drawBossIntro(); }
  }

  function drawBossHealth(){
    const room = dungeon.current;
    const boss = room.isBoss ? room.bossEntity : null;
    if(!boss || boss.dead) return;
    const ratio = Math.max(0, boss.hp / boss.maxHp);
    const barW = 360, barH = 16;
    const x = CONFIG.roomW/2 - barW/2;
    const y = 52;
    ctx.save();
    ctx.fillStyle = '#0b0912aa';
    ctx.fillRect(x-6,y-10,barW+12,barH+24);
    ctx.fillStyle = '#24152e';
    ctx.fillRect(x,y,barW,barH);
    const grad = ctx.createLinearGradient(x,0,x+barW,0);
    grad.addColorStop(0,'#ff6b9a');
    grad.addColorStop(1,'#f472b6');
    ctx.fillStyle = grad;
    ctx.fillRect(x,y,barW*ratio,barH);
    ctx.strokeStyle='#fff3'; ctx.strokeRect(x,y,barW,barH);
    ctx.fillStyle='#ffcfdf';
    ctx.font='16px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(boss.name, CONFIG.roomW/2, y-12);
    ctx.restore();
  }

  function drawBossIntro(){
    const alpha = Math.min(1, runtime.bossIntroTimer / 1.2);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle='#0b0912aa';
    ctx.fillRect(0, CONFIG.roomH/2 - 60, CONFIG.roomW, 120);
    ctx.fillStyle='#ffb4c8';
    ctx.font='38px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(runtime.bossIntroText, CONFIG.roomW/2, CONFIG.roomH/2 - 6);
    ctx.fillStyle='#ffd6e6';
    ctx.font='18px "HYWenHei", "PingFang SC", sans-serif';
    ctx.fillText('地窖打工仔：又是背锅的加班日。', CONFIG.roomW/2, CONFIG.roomH/2 + 28);
    ctx.restore();
  }

  function drawItemPickupBanner(){
    if(runtime.itemPickupTimer<=0 || !runtime.itemPickupName) return;
    const baseText = `${runtime.itemPickupName} 入手！`;
    const desc = runtime.itemPickupDesc;
    ctx.save();
    const lifeRatio = Math.min(1, runtime.itemPickupTimer / 1.2);
    ctx.globalAlpha = 0.85 + 0.15*lifeRatio;
    ctx.textAlign='center';
    const mainFont='20px "HYWenHei", "PingFang SC", sans-serif';
    const subFont='14px "HYWenHei", "PingFang SC", sans-serif';
    ctx.font = mainFont;
    const mainWidth = ctx.measureText(baseText).width;
    ctx.font = subFont;
    const subWidth = desc ? ctx.measureText(desc).width : 0;
    const paddingX = 22;
    const w = Math.max(mainWidth, subWidth) + paddingX*2;
    const h = desc ? 70 : 50;
    const x = CONFIG.roomW/2 - w/2;
    const y = CONFIG.roomH - h - 36;
    ctx.fillStyle = '#0b101dcc';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = '#2f3755';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1, y+1, w-2, h-2);
    ctx.font = mainFont;
    ctx.fillStyle = '#facc15';
    ctx.fillText(baseText, CONFIG.roomW/2, y + 28);
    if(desc){
      ctx.font = subFont;
      ctx.fillStyle = '#d6dcff';
      ctx.fillText(desc, CONFIG.roomW/2, y + 52);
    }
    ctx.restore();
  }

  class EnemyProjectile{
    constructor(x,y,vx,vy,life,type){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.alive=true; this.r= type==='needle'?6:7;
      this.type=type;
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
      if(this.life<=0) this.alive=false;
      if(this.x<20||this.x>CONFIG.roomW-20||this.y<20||this.y>CONFIG.roomH-20) this.alive=false;
      if(this.alive){
        for(const obs of dungeon.current.obstacles){
          if(obs.destroyed) continue;
          if(circleRectOverlap(this, obs)){ this.alive=false; break; }
        }
      }
    }
    checkHit(target){
      if(!this.alive) return false;
      if(dist(this,target) < this.r + target.r){ target.hurt(this.type==='needle'?2:1); return true; }
      return false;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.rotate(Math.atan2(this.vy,this.vx));
      if(this.type==='needle'){
        ctx.fillStyle='#f973a6';
        ctx.fillRect(-8,-2,16,4);
        ctx.fillStyle='#ffe4f0';
        ctx.fillRect(4,-1.2,6,2.4);
      } else {
        const g = ctx.createRadialGradient(0,0,1,0,0,this.r*1.4);
        g.addColorStop(0,'#ffe6f3');
        g.addColorStop(1,'#ff7aa9');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }

  function handleEnemyDeath(enemy, room){
    if(enemy._dropHandled) return;
    enemy._dropHandled = true;
    if(enemy.isBossEntity){
      room.bossDefeated = true;
      room.cleared = true;
      spawnBossRewards(room, enemy.x, enemy.y);
      spawnBossPortal(room);
    } else {
      if(rand() < CONFIG.drops.heartPerEnemy){
        const heal = rand() < CONFIG.drops.doubleHeartChance ? 2 : 1;
        room.pickups.push(makeHeartPickup(enemy.x + randRange(-12,12), enemy.y + randRange(-12,12), heal));
      }
      if(rand() < CONFIG.drops.resourcePerEnemy){
        const resType = CONFIG.drops.resourceTypes[Math.floor(rand()*CONFIG.drops.resourceTypes.length)];
        const amount = resType==='coin'?3:1;
        room.pickups.push(makeResourcePickup(resType, enemy.x + randRange(-18,18), enemy.y + randRange(-18,18), amount));
      }
    }
  }

  function spawnHeartBundle(room,x,y){
    room.pickups.push(makeHeartPickup(x+randRange(-18,18), y, 2));
    room.pickups.push(makeHeartPickup(x+randRange(-24,24), y+randRange(-20,20), 1));
    room.pickups.push(makeHeartPickup(x+randRange(-24,24), y+randRange(-20,20), 1));
  }

  function spawnBossRewards(room,x,y){
    spawnHeartBundle(room,x,y);
    const item = rollBossItem();
    room.pickups.push({type:'item', x:clamp(x,90,CONFIG.roomW-90), y:clamp(y-40,120,CONFIG.roomH-120), r:18, item, vx:0, vy:0, solid:false});
  }

  function spawnBossPortal(room){
    if(!room) return null;
    const cfg = CONFIG.portal || {};
    const center = typeof room.center === 'function' ? room.center() : {x: CONFIG.roomW/2, y: CONFIG.roomH/2};
    const offsetY = cfg.offsetY ?? 60;
    const portal = {
      x: clamp(center.x, 90, CONFIG.roomW-90),
      y: clamp(center.y + offsetY, 120, CONFIG.roomH-100),
      r: cfg.radius ?? 34,
      interactRadius: cfg.interactRadius ?? ((cfg.radius ?? 34) + 18),
      spawnDelay: Math.max(0, cfg.spawnDelay ?? 0),
      phase: rand()*Math.PI*2,
      active: false,
      used: false,
      highlight: 0,
    };
    room.portal = portal;
    if(Array.isArray(room.pickups)){
      for(const drop of room.pickups){
        if(!isPhysicalPickup(drop)) continue;
        pushPickup(drop, portal, 140, {force:true});
        ensurePickupMotion(drop);
      }
    }
    return portal;
  }

  function makeHeartPickup(x,y,heal){
    return {type:'heart', x:clamp(x,60,CONFIG.roomW-60), y:clamp(y,60,CONFIG.roomH-60), r: heal>1?14:10, heal, vx:0, vy:0, solid:true, spawnGrace:CONFIG.pickupSpawnGrace};
  }

  function queueEnemySpawn(enemy){ runtime.pendingEnemySpawns.push(enemy); }

  function placeBomb(){
    if(!player || !dungeon?.current) return;
    if(player.bombs<=0 || player.bombCooldown>0) return;
    const bomb = new Bomb(player.x, player.y);
    dungeon.current.bombs.push(bomb);
    player.bombs = Math.max(0, player.bombs-1);
    player.bombCooldown = 0.3;
  }

  function tryPortalInteract(room){
    const portal = room?.portal;
    if(!player || !portal || portal.used || !portal.active) return false;
    const interactRadius = portal.interactRadius ?? (portal.r + 18);
    if(dist(player, portal) > interactRadius) return false;
    portal.used = true;
    advanceToNextFloor();
    return true;
  }

  function attemptPurchase(){
    const room = dungeon?.current;
    if(!player || !room) return;
    if(tryPortalInteract(room)) return;
    let targetIndex=-1;
    let nearest=Infinity;
    for(let i=0;i<room.pickups.length;i++){
      const p = room.pickups[i];
      if(p.type!=='shop' || p.purchased) continue;
      const d = dist(p, player);
      if(d < p.r + player.r + 16 && d < nearest){ nearest=d; targetIndex=i; }
    }
    if(targetIndex===-1) return;
    const pickup = room.pickups[targetIndex];
    if(player.coins < pickup.price){
      if(runtime.itemPickupTimer<=0){
        runtime.itemPickupName = '钱包在抗议';
        runtime.itemPickupDesc = `还差 ${pickup.price - player.coins} 枚金币才买得起`;
        runtime.itemPickupTimer = 1.2;
      }
      return;
    }
    player.coins -= pickup.price;
    player.recalculateDamage();
    pickup.purchased = true;
    room.pickups.splice(targetIndex,1);
    if(pickup.entry.type==='item'){
      const item = pickup.entry.item;
      if(typeof item.apply === 'function'){ item.apply(player); }
      if(player && !player.items.includes(item.name)){ player.items.push(item.name); }
      registerItemDiscovery(item);
      runtime.itemPickupName = item.name;
      runtime.itemPickupDesc = item.description || '';
      runtime.itemPickupTimer = 2.4;
    } else if(pickup.entry.type==='resource'){
      const gained = grantResource(pickup.entry.resource, pickup.entry.amount);
      const label = RESOURCE_LABELS[pickup.entry.resource] || '资源';
      if(gained>0){
        runtime.itemPickupName = `${label} +${gained}`;
        runtime.itemPickupDesc = '来自商店柜台的友情价';
        runtime.itemPickupTimer = 1.5;
      } else {
        runtime.itemPickupName = `${label} 背包已满`;
        runtime.itemPickupDesc = '再整理一下口袋吧';
        runtime.itemPickupTimer = 1.2;
      }
    }
  }

  // ======= 入口 =======
  function showStart(){ showMenu(); lastTime = performance.now(); }
  showStart();

})();
</script>
</body>
</html>
