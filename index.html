<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>简易以撒-like</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#151923; --ink:#e6e6e6; --muted:#9aa4b2; --accent:#6ee7ff; --accent2:#a78bfa; --danger:#ff6b6b; --ok:#86efac;
    }
    html,body{height:100%;}
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 600px at 50% -10%,#1a2030 0%,#0f1115 55%,#0b0d12 100%);color:var(--ink);font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;}
    .wrap{max-width:960px;margin:24px auto;padding:16px;}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:12px}
    .title{font-weight:700;letter-spacing:.5px}
    .badge{padding:4px 8px;border:1px solid #2a3142;border-radius:999px;color:var(--muted)}
    .panel{background:linear-gradient(180deg,#121623,#0f131e);border:1px solid #202736;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .canvas-wrap{position:relative;aspect-ratio:4/3}
    canvas{width:100%;height:100%;display:block;border-radius:16px}
    .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:10px 12px;margin-top:10px;flex-wrap:wrap}
    .hud-section{display:flex;align-items:center;gap:6px}
    .hud-stats{flex:1 1 100%;display:flex;flex-wrap:wrap;gap:10px;font-size:13px;color:var(--muted);letter-spacing:.2px}
    .hud-stats span{display:flex;align-items:center;gap:4px;padding:2px 6px;border:1px solid #222a38;border-radius:8px;background:rgba(17,21,29,.65);color:var(--muted)}
    .hud-stats span strong{color:var(--ink);font-weight:600;min-width:36px;text-align:right;font-variant-numeric:tabular-nums}
    .hud-stats span small{font-size:12px;color:var(--muted);opacity:.8}
    .kbd{padding:2px 6px;border:1px solid #2a3142;border-radius:6px;color:var(--muted)}
    footer{margin-top:16px;color:var(--muted);text-align:center}
    /* overlays */
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;padding:24px}
    .overlay.show{display:flex}
    .card{max-width:520px;padding:18px 18px;border-radius:14px;background:rgba(15,17,21,.85);backdrop-filter: blur(6px);border:1px solid #202736}
    .card h2{margin:0 0 8px 0}
    .card p{margin:8px 0;color:var(--muted)}
    .card ul{margin:10px 0 0 1.2em;color:var(--muted)}
    .card li{margin:4px 0}
    a.btn{display:inline-block;margin-top:10px;padding:8px 12px;border-radius:10px;border:1px solid #273044;color:var(--ink);text-decoration:none}
    a.btn:hover{border-color:#3a4764}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">简易以撒-like · HTML5 Canvas</div>
      <div class="badge">WASD 移动 · 方向键射击 · 回车开始 · P 暂停 · R 重开</div>
    </header>
    <div class="panel canvas-wrap">
      <canvas id="game" width="800" height="600"></canvas>
      <div class="overlay" id="menu">
        <div class="card">
          <h2>地窖在等待…</h2>
          <p>这是一版极简的地牢房间制顶视角射击。清空当前房间敌人，门会开启，穿过门进入下一间。</p>
          <ul>
            <li><b>W/A/S/D</b> 移动，<b>↑/↓/←/→</b> 射击</li>
            <li><b>Enter</b> 开始 · <b>P</b> 暂停/继续 · <b>R</b> 重开</li>
          </ul>
          <a class="btn" href="#" id="startBtn">开始游戏</a>
        </div>
      </div>
      <div class="overlay" id="paused">
        <div class="card">
          <h2>已暂停</h2>
          <p>按 <b>P</b> 继续。清掉一屋子的小怪，门就开。</p>
        </div>
      </div>
      <div class="overlay" id="gameover">
        <div class="card">
          <h2>你倒下了</h2>
          <p>按 <b>R</b> 重开，或者 <b>Enter</b> 回到主菜单。</p>
        </div>
      </div>
    </div>
    <div class="panel hud">
      <div id="hud-left" class="hud-section"></div>
      <div id="hud-stats" class="hud-stats"></div>
      <div id="hud-right" class="hud-section"></div>
    </div>
    <footer>纯前端单文件 · 无素材 · 为演示而生</footer>
  </div>

<script>
(() => {
  'use strict';
  // ======= 配置 =======
  const CONFIG = {
    roomW: 800, roomH: 600,
    grid: 5, // 地图 5x5
    roomsToMake: 9, // 随机游走生成房间数量
    player: {speed: 210, radius: 12, hp: 6, fireCd: 360, tearSpeed: 230, tearLife: 0.45}, // fireCd 毫秒
    enemy: {
      baseHP: 2,
      speed: 90,
      spawnMin: 3, spawnMax: 6,
    },
    drops: {
      heartPerEnemy: 0.45,
      heartRoomClear: 0.6,
      doubleHeartChance: 0.22,
    },
    rngSeed: Date.now() % 1000000,
  };

  // ======= 基础工具 =======
  const rand = mulberry32(CONFIG.rngSeed);
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}};
  function randRange(min,max){return min + (max-min)*rand()}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
  const HUDL = document.getElementById('hud-left');
  const HUDR = document.getElementById('hud-right');
  const HUDS = document.getElementById('hud-stats');

  // DPR 缩放（保持内部 800x600 逻辑坐标）
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fitCanvasToCss(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = CONFIG.roomW * dpr;
    canvas.height = CONFIG.roomH * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitCanvasToCss();
  window.addEventListener('resize', fitCanvasToCss);

  // ======= 输入 =======
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    const block = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'];
    if(block.includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if(state===STATE.MENU && e.code==='Enter') startGame();
    if(state===STATE.PLAY && e.code==='KeyP') togglePause();
    if(state===STATE.PAUSE && e.code==='KeyP') togglePause();
    if(state===STATE.OVER && e.code==='Enter') showMenu();
    if((state===STATE.PLAY || state===STATE.PAUSE || state===STATE.OVER) && e.code==='KeyR') startGame();
  });
  window.addEventListener('keyup', (e)=> keys.delete(e.code));

  // ======= 游戏状态 =======
  const overlayMenu = document.getElementById('menu');
  const overlayPaused = document.getElementById('paused');
  const overlayOver = document.getElementById('gameover');
  document.getElementById('startBtn').addEventListener('click', (e)=>{e.preventDefault(); startGame();});

  const STATE = { MENU:0, PLAY:1, PAUSE:2, OVER:3 };
  let state = STATE.MENU;

  function showMenu(){ state=STATE.MENU; overlayMenu.classList.add('show'); overlayPaused.classList.remove('show'); overlayOver.classList.remove('show'); }
  function togglePause(){ if(state===STATE.PLAY){ state=STATE.PAUSE; overlayPaused.classList.add('show'); } else if(state===STATE.PAUSE){ state=STATE.PLAY; overlayPaused.classList.remove('show'); lastTime = performance.now(); } }
  function gameOver(){ state=STATE.OVER; overlayOver.classList.add('show'); }

  // ======= 地图/房间生成 =======
  class Room{
    constructor(i,j){
      this.i=i; this.j=j;
      this.doors={up:false,down:false,left:false,right:false};
      this.cleared=false; this.visited=false;
      this.enemies=[]; this.pickups=[];
      this.isBoss=false; this.bossEntity=null; this.bossDefeated=false; this.bossName=''; this.introPlayed=false;
    }
    center(){ return {x: CONFIG.roomW/2, y: CONFIG.roomH/2}; }
    spawnEnemies(depth){
      if(this.isBoss){
        if(this.bossDefeated){ this.enemies = []; return this.enemies; }
        if(!this.bossEntity || this.bossEntity.dead){
          const c = this.center();
          this.bossEntity = makeBoss(c, this);
        }
        this.enemies = [this.bossEntity];
        this.cleared = false;
        return this.enemies;
      }
      // 按深度稍微增加数量
      const n = Math.floor(randRange(CONFIG.enemy.spawnMin, CONFIG.enemy.spawnMax+1) + (depth*0.3));
      this.enemies = [];
      for(let k=0;k<n;k++){
        const x = randRange(80, CONFIG.roomW-80);
        const y = randRange(80, CONFIG.roomH-80);
        const t = rand() < 0.7 ? 'chaser' : 'orbiter';
        this.enemies.push(makeEnemy(t, {x,y}, depth));
      }
      return this.enemies;
    }
  }

  class Dungeon{
    constructor(){
      this.gridN = CONFIG.grid;
      // 创建空房
      this.rooms = Array.from({length:this.gridN}, (_,i)=> Array.from({length:this.gridN},(_,j)=>null));
      const mid = Math.floor(this.gridN/2);
      let ci=mid, cj=mid;
      const visited = new Set([key(ci,cj)]);
      this.rooms[ci][cj] = new Room(ci,cj);
      // 随机游走生成若干房间
      for(let n=1;n<CONFIG.roomsToMake;n++){
        const dir = Math.floor(rand()*4);
        const di = [ -1, 1, 0, 0 ][dir];
        const dj = [ 0, 0, -1, 1 ][dir];
        const ni = clamp(ci+di, 0, this.gridN-1);
        const nj = clamp(cj+dj, 0, this.gridN-1);
        ci=ni; cj=nj;
        if(!this.rooms[ci][cj]) this.rooms[ci][cj] = new Room(ci,cj);
        visited.add(key(ci,cj));
      }
      // 连接门
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r = this.rooms[i][j]; if(!r) continue;
          if(i>0 && this.rooms[i-1][j]) { r.doors.up=true; this.rooms[i-1][j].doors.down=true; }
          if(i<this.gridN-1 && this.rooms[i+1][j]) { r.doors.down=true; this.rooms[i+1][j].doors.up=true; }
          if(j>0 && this.rooms[i][j-1]) { r.doors.left=true; this.rooms[i][j-1].doors.right=true; }
          if(j<this.gridN-1 && this.rooms[i][j+1]) { r.doors.right=true; this.rooms[i][j+1].doors.left=true; }
        }
      }
      this.start = this.rooms[mid][mid];
      this.current = this.start;
      this.depth = 1;

      // 指定 Boss 房
      this.bossRoom = this.setupBossRoom(mid);
    }

    setupBossRoom(mid){
      let farthest=null, maxDist=-1;
      for(let i=0;i<this.gridN;i++){
        for(let j=0;j<this.gridN;j++){
          const r=this.rooms[i][j]; if(!r || (i===mid && j===mid)) continue;
          const d = Math.abs(i-mid)+Math.abs(j-mid);
          if(d>maxDist){ maxDist=d; farthest=r; }
        }
      }
      if(!farthest) return null;
      const dirs=[{di:-1,dj:0,key:'up',opp:'down'},{di:1,dj:0,key:'down',opp:'up'},{di:0,dj:-1,key:'left',opp:'right'},{di:0,dj:1,key:'right',opp:'left'}];
      for(const dir of dirs){
        const ni = clamp(farthest.i+dir.di,0,this.gridN-1);
        const nj = clamp(farthest.j+dir.dj,0,this.gridN-1);
        if(this.rooms[ni][nj]) continue;
        const bossRoom = new Room(ni,nj);
        bossRoom.isBoss=true;
        bossRoom.bossName = '哭泣塑像 · 胎衣蛹';
        this.rooms[ni][nj]=bossRoom;
        farthest.doors[dir.key]=true;
        bossRoom.doors[dir.opp]=true;
        return bossRoom;
      }
      // 如果周围无空位，则直接把最远房间作为 Boss 房
      farthest.isBoss=true;
      farthest.bossName = '哭泣塑像 · 胎衣蛹';
      return farthest;
    }
  }
  function key(i,j){return `${i},${j}`}

  // ======= 实体 =======
  class Player{
    constructor(x,y){
      this.x=x; this.y=y; this.r=CONFIG.player.radius; this.speed=CONFIG.player.speed;
      this.maxHp = CONFIG.player.hp;
      this.hp = this.maxHp; this.ifr=0; // 无敌帧
      this.fireCd = 0; this.fireInterval = CONFIG.player.fireCd;
      this.tearSpeed=CONFIG.player.tearSpeed; this.tearLife=CONFIG.player.tearLife;
      this.damage = 1;
    }
    update(dt){
      const mv = {x:0,y:0};
      if(keys.has('KeyW')) mv.y -= 1;
      if(keys.has('KeyS')) mv.y += 1;
      if(keys.has('KeyA')) mv.x -= 1;
      if(keys.has('KeyD')) mv.x += 1;
      const len = Math.hypot(mv.x,mv.y) || 1;
      this.x += (mv.x/len) * this.speed * dt;
      this.y += (mv.y/len) * this.speed * dt;
      // 边界
      this.x = clamp(this.x, 30, CONFIG.roomW-30);
      this.y = clamp(this.y, 30, CONFIG.roomH-30);
      this.ifr = Math.max(0, this.ifr - dt);
      this.fireCd = Math.max(0, this.fireCd - dt*1000);

      // 射击（方向键）
      let sx=0, sy=0;
      if(keys.has('ArrowUp')) sy -= 1;
      if(keys.has('ArrowDown')) sy += 1;
      if(keys.has('ArrowLeft')) sx -= 1;
      if(keys.has('ArrowRight')) sx += 1;
      if((sx||sy) && this.fireCd<=0){
        const l = Math.hypot(sx,sy)||1; sx/=l; sy/=l;
        bullets.push(new Bullet(this.x, this.y, sx*this.tearSpeed, sy*this.tearSpeed, this.tearLife, this.damage));
        this.fireCd = this.fireInterval;
      }
    }
    hurt(dmg){
      if(this.ifr>0) return;
      this.hp = Math.max(0, this.hp - dmg);
      this.ifr = 1.0;
      if(this.hp<=0) gameOver();
    }
  }

  const TEAR_RADIUS_BASE = 5;
  const TEAR_RADIUS_GROWTH = 3.2;
  function calcTearRadius(damage){
    // 参考以撒的结合的弹丸成长：使用平方根降低增长曲线的坡度，避免数值过激
    const dmg = Math.max(0.25, damage);
    return TEAR_RADIUS_BASE + TEAR_RADIUS_GROWTH * (Math.sqrt(dmg) - 1);
  }

  class Bullet{
    constructor(x,y,vx,vy,life,damage=1){
      this.x=x;
      this.y=y;
      this.vx=vx;
      this.vy=vy;
      this.life=life;
      this.damage=damage;
      this.alive=true;
      this.r=calcTearRadius(damage);
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
      if(this.life<=0) this.alive=false;
      if(this.x<0||this.x>CONFIG.roomW||this.y<0||this.y>CONFIG.roomH) this.alive=false;
    }
    draw(){
      ctx.beginPath();
      ctx.fillStyle = '#a6e3ff';
      ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  function makeEnemy(type, pos, depth){
    const hp = Math.max(1, Math.round(CONFIG.enemy.baseHP + depth*0.3 + rand()*1.0));
    if(type==='chaser') return new EnemyChaser(pos.x,pos.y,hp);
    return new EnemyOrbiter(pos.x,pos.y,hp);
  }

  function makeBoss(pos, room){
    const boss = new EnemyBoss(pos.x, pos.y, room?.bossName || '未知胎物');
    boss.room = room;
    return boss;
  }

  class EnemyChaser{
    constructor(x,y,hp){ this.x=x; this.y=y; this.r=12; this.hp=hp; this.speed = CONFIG.enemy.speed * randRange(0.9,1.2); this.knock=0; }
    update(dt){
      const to = {x:player.x - this.x, y:player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1; to.x/=l; to.y/=l;
      // 受击后短暂击退
      if(this.knock>0){ this.x -= to.x * 220 * dt; this.y -= to.y * 220 * dt; this.knock-=dt; }
      else { this.x += to.x * this.speed * dt; this.y += to.y * this.speed * dt; }
      // 碰撞到玩家
      if(dist(this, player) < this.r + player.r){ player.hurt(1); this.knock = 0.2; }
    }
    draw(){ drawBlob(this.x,this.y,this.r,'#ff9aa2','#ff6b6b'); }
    damage(d){ this.hp-=d; this.knock=0.15; if(this.hp<=0){ this.dead=true; return true; } return false; }
  }

  class EnemyOrbiter{
    constructor(x,y,hp){ this.x=x; this.y=y; this.r=10; this.hp=hp; this.t=rand()*Math.PI*2; this.base={x,y}; this.range=40+rand()*25; this.omega = 2+rand()*1.5; this.speed=40; }
    update(dt){
      this.t += this.omega*dt;
      this.x = this.base.x + Math.cos(this.t)*this.range;
      this.y = this.base.y + Math.sin(this.t)*this.range;
      // 慢慢靠近玩家（弱追踪）
      const dx = player.x - this.base.x; const dy = player.y - this.base.y;
      const l = Math.hypot(dx,dy)||1; this.base.x += (dx/l)*this.speed*dt*0.6; this.base.y += (dy/l)*this.speed*dt*0.6;
      if(dist(this, player) < this.r + player.r) player.hurt(1);
    }
    draw(){ drawBlob(this.x,this.y,this.r,'#b4c7ff','#7aa2ff'); }
    damage(d){ this.hp-=d; if(this.hp<=0){ this.dead=true; return true; } return false; }
  }

  class EnemyBoss{
    constructor(x,y,name){
      this.x=x; this.y=y; this.r=36;
      this.hp=70; this.maxHp=this.hp;
      this.name=name;
      this.state='idle';
      this.attackTimer=1.5; this.chargeTimer=0; this.recoverTimer=0;
      this.hitFlash=0; this.enraged=false;
    }
    update(dt){
      const drift = 40 + (this.enraged?25:0);
      if(this.state==='charge'){
        this.chargeTimer -= dt;
        this.x += this.vx*dt; this.y += this.vy*dt;
        if(this.chargeTimer<=0){ this.state='recover'; this.recoverTimer=0.6; }
      } else {
        const to = {x: player.x - this.x, y: player.y - this.y};
        const l = Math.hypot(to.x,to.y)||1;
        this.x += (to.x/l) * drift * dt * 0.55;
        this.y += (to.y/l) * drift * dt * 0.55;
        this.x += Math.cos(performance.now()/480) * 18 * dt;
        this.y += Math.sin(performance.now()/360) * 18 * dt;
        if(this.state==='recover'){
          this.recoverTimer -= dt;
          if(this.recoverTimer<=0) this.state='idle';
        }
      }
      this.x = clamp(this.x, 90, CONFIG.roomW-90);
      this.y = clamp(this.y, 110, CONFIG.roomH-110);
      if(dist(this, player) < this.r + player.r - 2){ player.hurt(1); }

      if(this.hitFlash>0) this.hitFlash -= dt;
      if(!this.enraged && this.hp <= this.maxHp*0.55){ this.enraged=true; this.attackTimer = Math.min(this.attackTimer, 1.1); }

      this.attackTimer -= dt;
      if(this.attackTimer<=0){ this.chooseAttack(); }
    }
    chooseAttack(){
      const roll = rand();
      if(roll < 0.45){ this.sprayAttack(); this.attackTimer = this.enraged ? 1.6 : 2.2; }
      else if(roll < 0.75){ this.spawnMinions(); this.attackTimer = this.enraged ? 2.0 : 2.6; }
      else { this.chargeAttack(); this.attackTimer = this.enraged ? 2.4 : 3.2; }
    }
    sprayAttack(){
      const waves = this.enraged ? 3 : 2;
      for(let w=0; w<waves; w++){
        const base = rand()*Math.PI*2;
        const total = 10 + (this.enraged?4:0);
        for(let i=0;i<total;i++){
          const angle = base + (Math.PI*2/total)*i + w*0.12;
          const speed = 120 + rand()*40 + (this.enraged?30:0);
          enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 4.2, 'tear'));
        }
      }
      // 指向性射流
      const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
      for(let k=0;k<4;k++){
        const angle = toPlayer + randRange(-0.4,0.4) + k*0.1*(this.enraged?1.2:0.6);
        const speed = 160 + rand()*90;
        enemyProjectiles.push(new EnemyProjectile(this.x, this.y, Math.cos(angle)*speed, Math.sin(angle)*speed, 5, 'needle'));
      }
    }
    spawnMinions(){
      const count = this.enraged ? 3 : 2;
      for(let i=0;i<count;i++){
        const angle = rand()*Math.PI*2;
        const radius = 90 + rand()*60;
        const pos = {x: clamp(this.x + Math.cos(angle)*radius, 70, CONFIG.roomW-70), y: clamp(this.y + Math.sin(angle)*radius, 70, CONFIG.roomH-70)};
        const minion = makeEnemy(rand()<0.5?'chaser':'orbiter', pos, dungeon.depth+2);
        minion.r += 2;
        queueEnemySpawn(minion);
      }
    }
    chargeAttack(){
      const to = {x: player.x - this.x, y: player.y - this.y};
      const l = Math.hypot(to.x,to.y)||1;
      const speed = this.enraged ? 300 : 240;
      this.vx = (to.x/l) * speed;
      this.vy = (to.y/l) * speed;
      this.state='charge';
      this.chargeTimer = 0.75;
    }
    damage(d){
      this.hp -= d;
      this.hitFlash = 0.18;
      if(this.hp<=0){ this.dead=true; return true; }
      return false;
    }
    draw(){
      const outer = this.hitFlash>0 ? '#ffd5dc' : '#ffb4c8';
      drawBlob(this.x,this.y,this.r, outer,'#d946ef');
      ctx.save();
      ctx.translate(this.x,this.y);
      const blink = this.enraged ? 1.5 : 1;
      ctx.fillStyle = this.enraged ? '#ffe5f2' : '#faf6ff';
      ctx.beginPath();
      ctx.ellipse(-this.r*0.35, -this.r*0.15, this.r*0.25, this.r*0.35, 0, 0, Math.PI*2);
      ctx.ellipse(this.r*0.35, -this.r*0.15, this.r*0.25, this.r*0.35, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#151523';
      const eyeOffset = Math.sin(performance.now()/240)*this.r*0.12;
      ctx.beginPath();
      ctx.arc(-this.r*0.32, -this.r*0.12 + eyeOffset, this.r*0.12*blink, 0, Math.PI*2);
      ctx.arc(this.r*0.32, -this.r*0.12 - eyeOffset, this.r*0.12*blink, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#2f1d38';
      ctx.beginPath();
      ctx.moveTo(-this.r*0.4, this.r*0.1);
      ctx.quadraticCurveTo(0, this.r*0.28 + Math.sin(performance.now()/200)*4, this.r*0.4, this.r*0.1);
      ctx.quadraticCurveTo(0, this.r*0.5, -this.r*0.4, this.r*0.1);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawBlob(x,y,r,base,edge){
    const g = ctx.createRadialGradient(x-r*0.4,y-r*0.4,r*0.1,x,y,r*1.1);
    g.addColorStop(0, base);
    g.addColorStop(1, edge);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  // ======= 运行时上下文 =======
  let dungeon, bullets=[], enemyProjectiles=[], player;
  let bossIntroTimer = 0, bossIntroText='';
  const pendingEnemySpawns = [];

  function startGame(){
    overlayMenu.classList.remove('show'); overlayPaused.classList.remove('show'); overlayOver.classList.remove('show');
    dungeon = new Dungeon();
    player = new Player(CONFIG.roomW/2, CONFIG.roomH/2);
    dungeon.current.visited=true;
    dungeon.current.spawnEnemies(dungeon.depth);
    state = STATE.PLAY;
    lastTime = performance.now();
    bullets.length=0; enemyProjectiles.length=0; bossIntroTimer=0;
  }

  // ======= 门与换房 =======
  function roomDoors(r){
    const doors = [];
    const w=CONFIG.roomW, h=CONFIG.roomH;
    const doorW=60, doorH=10, offset=22;
    if(r.doors.up) doors.push({dir:'up',   x:w/2-doorW/2, y:offset,      w:doorW, h:doorH});
    if(r.doors.down) doors.push({dir:'down', x:w/2-doorW/2, y:h-offset-doorH, w:doorW, h:doorH});
    if(r.doors.left) doors.push({dir:'left', x:offset,      y:h/2-doorW/2, w:doorH, h:doorW});
    if(r.doors.right) doors.push({dir:'right',x:w-offset-doorH, y:h/2-doorW/2, w:doorH, h:doorW});
    return doors;
  }
  function tryRoomTransition(){
    const r = dungeon.current;
    const doors = roomDoors(r);
    for(const d of doors){
      if(!r.cleared) continue; // 清空才开门
      if(rectCircleOverlap(d.x,d.y,d.w,d.h, player.x,player.y,player.r)){
        // 传送到相邻房间
        const ni = r.i + (d.dir==='down') - (d.dir==='up');
        const nj = r.j + (d.dir==='right') - (d.dir==='left');
        const nr = dungeon.rooms[ni]?.[nj];
        if(nr){
          dungeon.current = nr; nr.visited=true; dungeon.depth++;
          // 入口位置
          if(d.dir==='up'){ player.x=CONFIG.roomW/2; player.y=CONFIG.roomH-60; }
          if(d.dir==='down'){ player.x=CONFIG.roomW/2; player.y=60; }
          if(d.dir==='left'){ player.x=CONFIG.roomW-60; player.y=CONFIG.roomH/2; }
          if(d.dir==='right'){ player.x=60; player.y=CONFIG.roomH/2; }
          bullets.length=0; enemyProjectiles.length=0;
          if(nr.isBoss && !nr.introPlayed){
            bossIntroText = nr.bossName;
            bossIntroTimer = 3.2;
            nr.introPlayed = true;
          }
          if(!nr.cleared){ nr.spawnEnemies(dungeon.depth); }
          break;
        }
      }
    }
  }
  function rectCircleOverlap(rx,ry,rw,rh, cx,cy,cr){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= cr*cr;
  }

  // ======= 主循环 =======
  let lastTime = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now - lastTime) / 1000);
    if(state===STATE.PLAY){ update(dt); }
    draw();
    if(state===STATE.PLAY) lastTime = now; // 暂停时不要推进时间
  }
  requestAnimationFrame(loop);

  function update(dt){
    player.update(dt);

    // 子弹
    for(const b of bullets) b.update(dt);
    bullets = bullets.filter(b=>b.alive);

    // 敌人
    const enemies = dungeon.current.enemies;
    for(const e of enemies) e.update(dt);
    if(pendingEnemySpawns.length){ enemies.push(...pendingEnemySpawns.splice(0)); }

    // 敌方弹幕
    for(const eb of enemyProjectiles){ eb.update(dt); }
    enemyProjectiles = enemyProjectiles.filter(p=>p.alive);

    // 碰撞：子弹-敌人
    for(const b of bullets){
      for(const e of enemies){
        if(e.dead) continue;
        const dd = dist(b, e);
        if(dd < (b.r + e.r)){
          if(e.damage(b.damage)){ handleEnemyDeath(e, dungeon.current); }
          b.alive=false; break;
        }
      }
    }
    // 清理死亡
    dungeon.current.enemies = enemies.filter(e=>!e.dead);

    // 玩家被弹幕命中
    for(const eb of enemyProjectiles){ if(eb.checkHit(player)){ eb.alive=false; } }

    // 房间是否清空
    if(!dungeon.current.cleared && dungeon.current.enemies.length===0){
      dungeon.current.cleared = true;
      // 小概率掉红心
      if(rand()<CONFIG.drops.heartRoomClear){
        dungeon.current.pickups.push(makeHeartPickup(randRange(120,CONFIG.roomW-120), randRange(120,CONFIG.roomH-120), 1));
      }
    }

    // 拾取
    const picks = dungeon.current.pickups;
    for(let i=picks.length-1;i>=0;i--){
      const p = picks[i];
      if(dist(p,player) < p.r + player.r){
        if(p.type==='heart' && player.hp < player.maxHp){
          player.hp = Math.min(player.maxHp, player.hp + (p.heal || 1));
          picks.splice(i,1);
        }
      }
    }

    // 换房
    tryRoomTransition();

    // 更新 HUD
    renderHUD();
    bossIntroTimer = Math.max(0, bossIntroTimer - dt);
  }

  function renderHUD(){
    const hearts = '❤'.repeat(Math.max(0,player.hp)) + '·'.repeat(Math.max(0, player.maxHp - player.hp));
    HUDL.innerHTML = `生命：<span style="letter-spacing:1px">${hearts}</span>`;
    const fireRate = player.fireInterval>0 ? (1000/player.fireInterval).toFixed(2) : '∞';
    const damage = Number.isInteger(player.damage) ? player.damage : player.damage.toFixed(1);
    const moveSpeed = Math.round(player.speed);
    const tearSpeed = Math.round(player.tearSpeed);
    const range = Math.round(player.tearSpeed * player.tearLife);
    const statItems = [
      {label:'攻速', value: fireRate, unit:'次/秒'},
      {label:'伤害', value: damage},
      {label:'移动速度', value: moveSpeed},
      {label:'子弹速度', value: tearSpeed},
      {label:'射程', value: range}
    ];
    HUDS.innerHTML = statItems.map(({label,value,unit})=>`<span>${label}：<strong>${value}</strong>${unit?`<small>${unit}</small>`:''}</span>`).join('');
    if(dungeon.current.isBoss && dungeon.current.bossEntity && !dungeon.current.bossEntity.dead){
      HUDR.innerHTML = `层数：${dungeon.depth} / <span style="color:#ffb4c8">BOSS：${dungeon.current.bossEntity.name}</span>`;
    } else {
      HUDR.innerHTML = `层数：${dungeon.depth} / 已探索：${exploredRooms()} 间`;
    }
  }
  function exploredRooms(){
    let n=0; for(let i=0;i<dungeon.gridN;i++){for(let j=0;j<dungeon.gridN;j++){if(dungeon.rooms[i][j]?.visited) n++;}} return n;
  }

  // ======= 渲染 =======
  function draw(){
    // 背景
    ctx.clearRect(0,0,CONFIG.roomW, CONFIG.roomH);
    drawRoomBackdrop();
    drawDoors();

    // 拾取
    for(const p of dungeon.current.pickups){ drawPickup(p); }

    // 敌人
    for(const e of dungeon.current.enemies){ e.draw(); }

    // 敌弹
    for(const eb of enemyProjectiles){ eb.draw(); }

    // 子弹
    for(const b of bullets){ b.draw(); }

    // 玩家
    drawPlayer();

    drawBossHealth();

    // 小地图
    drawMiniMap();

    // 覆盖层显隐
    overlayMenu.classList.toggle('show', state===STATE.MENU);
    overlayPaused.classList.toggle('show', state===STATE.PAUSE);
    overlayOver.classList.toggle('show', state===STATE.OVER);
  }

  function drawRoomBackdrop(){
    const w=CONFIG.roomW, h=CONFIG.roomH;
    // 地砖
    const isBoss = dungeon.current.isBoss && !dungeon.current.cleared;
    const g = ctx.createLinearGradient(0,0,0,h);
    if(isBoss){ g.addColorStop(0,'#1b0f19'); g.addColorStop(1,'#120913'); }
    else { g.addColorStop(0,'#10141d'); g.addColorStop(1,'#0d121a'); }
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    // 边框
    ctx.strokeStyle = isBoss ? '#663355' : '#2a3142'; ctx.lineWidth=14; ctx.strokeRect(10,10,w-20,h-20);
    // 裂纹/污渍
    ctx.globalAlpha = isBoss ? 0.12 : 0.06; ctx.fillStyle=isBoss ? '#ff88b1' : '#bcd';
    for(let i=0;i<22;i++){ const x=randRange(30,w-30), y=randRange(30,h-30), r=randRange(8,38); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
    ctx.globalAlpha = 1;
  }
  function drawDoors(){
    const r = dungeon.current; const doors = roomDoors(r);
    for(const d of doors){
      ctx.save();
      // 门框
      ctx.fillStyle = r.cleared ? '#6ee7ff55' : '#2a3142';
      ctx.fillRect(d.x-4,d.y-4,d.w+8,d.h+8);
      // 门
      ctx.fillStyle = r.cleared ? '#6ee7ff' : '#1e2330';
      ctx.fillRect(d.x,d.y,d.w,d.h);
      ctx.restore();
    }
  }
  function drawPickup(p){
    if(p.type==='heart'){
      const t = (performance.now()/300)%Math.PI;
      const r = p.r + Math.sin(t)*1.2;
      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.fillStyle = p.heal>1 ? '#ff98a8' : '#ff7787';
      ctx.strokeStyle = '#fff3'; ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(0, r*0.6);
      ctx.bezierCurveTo(r, -r*0.6, r*1.2, r*0.6, 0, r);
      ctx.bezierCurveTo(-r*1.2, r*0.6, -r, -r*0.6, 0, r*0.6);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
  }
  function drawPlayer(){
    // 身体
    drawBlob(player.x, player.y, player.r, '#e1e7ff', '#a78bfa');
    // 眼泪闪烁（无敌帧提示）
    if(player.ifr>0){ ctx.save(); ctx.globalAlpha = 0.5 + 0.5*Math.sin(performance.now()/60); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x,player.y,player.r+3,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  }
  function drawMiniMap(){
    const N = dungeon.gridN; const cell=12, pad=8; const left=16, top=16;
    ctx.save();
    ctx.translate(left, top);
    ctx.globalAlpha=0.9;
    ctx.fillStyle='#141a25'; ctx.fillRect(-pad,-pad,N*cell+pad*2,N*cell+pad*2);
    for(let i=0;i<N;i++){
      for(let j=0;j<N;j++){
        const r = dungeon.rooms[i][j];
        const x = j*cell, y=i*cell;
        if(!r){ ctx.fillStyle='#0b0f16'; }
        else if(r===dungeon.current){ ctx.fillStyle='#6ee7ff'; }
        else if(r.isBoss && !r.bossDefeated){ ctx.fillStyle='#ff6b6b'; }
        else if(r.visited){ ctx.fillStyle='#2c3a54'; }
        else { ctx.fillStyle='#182131'; }
        ctx.fillRect(x,y,cell-1,cell-1);
      }
    }
    ctx.restore();
    if(bossIntroTimer>0){ drawBossIntro(); }
  }

  function drawBossHealth(){
    const room = dungeon.current;
    const boss = room.isBoss ? room.bossEntity : null;
    if(!boss || boss.dead) return;
    const ratio = Math.max(0, boss.hp / boss.maxHp);
    const barW = 360, barH = 16;
    const x = CONFIG.roomW/2 - barW/2;
    const y = 52;
    ctx.save();
    ctx.fillStyle = '#0b0912aa';
    ctx.fillRect(x-6,y-10,barW+12,barH+24);
    ctx.fillStyle = '#24152e';
    ctx.fillRect(x,y,barW,barH);
    const grad = ctx.createLinearGradient(x,0,x+barW,0);
    grad.addColorStop(0,'#ff6b9a');
    grad.addColorStop(1,'#f472b6');
    ctx.fillStyle = grad;
    ctx.fillRect(x,y,barW*ratio,barH);
    ctx.strokeStyle='#fff3'; ctx.strokeRect(x,y,barW,barH);
    ctx.fillStyle='#ffcfdf';
    ctx.font='16px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(boss.name, CONFIG.roomW/2, y-12);
    ctx.restore();
  }

  function drawBossIntro(){
    const alpha = Math.min(1, bossIntroTimer / 1.2);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle='#0b0912aa';
    ctx.fillRect(0, CONFIG.roomH/2 - 60, CONFIG.roomW, 120);
    ctx.fillStyle='#ffb4c8';
    ctx.font='38px "HYWenHei", "PingFang SC", sans-serif';
    ctx.textAlign='center';
    ctx.fillText(bossIntroText, CONFIG.roomW/2, CONFIG.roomH/2 - 6);
    ctx.fillStyle='#ffd6e6';
    ctx.font='18px "HYWenHei", "PingFang SC", sans-serif';
    ctx.fillText('渗出的胎衣在地窖尽头凝聚成型……', CONFIG.roomW/2, CONFIG.roomH/2 + 28);
    ctx.restore();
  }

  class EnemyProjectile{
    constructor(x,y,vx,vy,life,type){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=life; this.alive=true; this.r= type==='needle'?6:7;
      this.type=type;
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
      if(this.life<=0) this.alive=false;
      if(this.x<20||this.x>CONFIG.roomW-20||this.y<20||this.y>CONFIG.roomH-20) this.alive=false;
    }
    checkHit(target){
      if(!this.alive) return false;
      if(dist(this,target) < this.r + target.r){ target.hurt(this.type==='needle'?2:1); return true; }
      return false;
    }
    draw(){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.rotate(Math.atan2(this.vy,this.vx));
      if(this.type==='needle'){
        ctx.fillStyle='#f973a6';
        ctx.fillRect(-8,-2,16,4);
        ctx.fillStyle='#ffe4f0';
        ctx.fillRect(4,-1.2,6,2.4);
      } else {
        const g = ctx.createRadialGradient(0,0,1,0,0,this.r*1.4);
        g.addColorStop(0,'#ffe6f3');
        g.addColorStop(1,'#ff7aa9');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }
  }

  function handleEnemyDeath(enemy, room){
    if(enemy._dropHandled) return;
    enemy._dropHandled = true;
    if(enemy instanceof EnemyBoss){
      room.bossDefeated = true;
      room.cleared = true;
      spawnHeartBundle(room, enemy.x, enemy.y);
    } else {
      if(rand() < CONFIG.drops.heartPerEnemy){
        const heal = rand() < CONFIG.drops.doubleHeartChance ? 2 : 1;
        room.pickups.push(makeHeartPickup(enemy.x + randRange(-12,12), enemy.y + randRange(-12,12), heal));
      }
    }
  }

  function spawnHeartBundle(room,x,y){
    room.pickups.push(makeHeartPickup(x+randRange(-18,18), y, 2));
    room.pickups.push(makeHeartPickup(x+randRange(-24,24), y+randRange(-20,20), 1));
    room.pickups.push(makeHeartPickup(x+randRange(-24,24), y+randRange(-20,20), 1));
  }

  function makeHeartPickup(x,y,heal){
    return {type:'heart', x:clamp(x,60,CONFIG.roomW-60), y:clamp(y,60,CONFIG.roomH-60), r: heal>1?14:10, heal};
  }

  function queueEnemySpawn(enemy){ pendingEnemySpawns.push(enemy); }

  // ======= 入口 =======
  function showStart(){ showMenu(); lastTime = performance.now(); }
  showStart();

})();
</script>
</body>
</html>
